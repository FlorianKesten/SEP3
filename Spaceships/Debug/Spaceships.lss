
Spaceships.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000009e  00800100  00002fa4  00003038  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002fa4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000006c6  0080019e  0080019e  000030d6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000030d6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00003108  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000660  00000000  00000000  00003148  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000892b  00000000  00000000  000037a8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001d16  00000000  00000000  0000c0d3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000041d8  00000000  00000000  0000dde9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001368  00000000  00000000  00011fc4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002474  00000000  00000000  0001332c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000073b2  00000000  00000000  000157a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000750  00000000  00000000  0001cb52  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 48 00 	jmp	0x90	; 0x90 <__ctors_end>
       4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
       8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
       c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      30:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      34:	0c 94 f3 07 	jmp	0xfe6	; 0xfe6 <__vector_13>
      38:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      40:	0c 94 40 05 	jmp	0xa80	; 0xa80 <__vector_16>
      44:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      48:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      50:	0c 94 e9 08 	jmp	0x11d2	; 0x11d2 <__vector_20>
      54:	0c 94 27 09 	jmp	0x124e	; 0x124e <__vector_21>
      58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      70:	0c 94 6f 09 	jmp	0x12de	; 0x12de <__vector_28>
      74:	0c 94 ad 09 	jmp	0x135a	; 0x135a <__vector_29>
      78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      7c:	1a 16       	cp	r1, r26
      7e:	1a 16       	cp	r1, r26
      80:	1a 16       	cp	r1, r26
      82:	55 16       	cp	r5, r21
      84:	43 16       	cp	r4, r19
      86:	52 16       	cp	r5, r18
      88:	1a 16       	cp	r1, r26
      8a:	1a 16       	cp	r1, r26
      8c:	55 16       	cp	r5, r21
      8e:	43 16       	cp	r4, r19

00000090 <__ctors_end>:
      90:	11 24       	eor	r1, r1
      92:	1f be       	out	0x3f, r1	; 63
      94:	cf ef       	ldi	r28, 0xFF	; 255
      96:	d8 e0       	ldi	r29, 0x08	; 8
      98:	de bf       	out	0x3e, r29	; 62
      9a:	cd bf       	out	0x3d, r28	; 61

0000009c <__do_copy_data>:
      9c:	11 e0       	ldi	r17, 0x01	; 1
      9e:	a0 e0       	ldi	r26, 0x00	; 0
      a0:	b1 e0       	ldi	r27, 0x01	; 1
      a2:	e4 ea       	ldi	r30, 0xA4	; 164
      a4:	ff e2       	ldi	r31, 0x2F	; 47
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x10>
      a8:	05 90       	lpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	ae 39       	cpi	r26, 0x9E	; 158
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0xc>

000000b2 <__do_clear_bss>:
      b2:	28 e0       	ldi	r18, 0x08	; 8
      b4:	ae e9       	ldi	r26, 0x9E	; 158
      b6:	b1 e0       	ldi	r27, 0x01	; 1
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	a4 36       	cpi	r26, 0x64	; 100
      be:	b2 07       	cpc	r27, r18
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	0e 94 1e 02 	call	0x43c	; 0x43c <main>
      c6:	0c 94 d0 17 	jmp	0x2fa0	; 0x2fa0 <_exit>

000000ca <__bad_interrupt>:
      ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <draw_bullets_task>:
}

static void draw_bullets_task(void *pvParameters)
{
	(void)pvParameters;
	vTaskSetApplicationTaskTag( NULL, ( void * ) 6);
      ce:	66 e0       	ldi	r22, 0x06	; 6
      d0:	70 e0       	ldi	r23, 0x00	; 0
      d2:	80 e0       	ldi	r24, 0x00	; 0
      d4:	90 e0       	ldi	r25, 0x00	; 0
      d6:	0e 94 23 12 	call	0x2446	; 0x2446 <vTaskSetApplicationTaskTag>

	while (1)
	{
		if(xSemaphoreTake(xTimerSemaphoreDrawBullets, portMAX_DELAY))
      da:	20 e0       	ldi	r18, 0x00	; 0
      dc:	4f ef       	ldi	r20, 0xFF	; 255
      de:	5f ef       	ldi	r21, 0xFF	; 255
      e0:	60 e0       	ldi	r22, 0x00	; 0
      e2:	70 e0       	ldi	r23, 0x00	; 0
      e4:	80 91 49 08 	lds	r24, 0x0849	; 0x800849 <xTimerSemaphoreDrawBullets>
      e8:	90 91 4a 08 	lds	r25, 0x084A	; 0x80084a <xTimerSemaphoreDrawBullets+0x1>
      ec:	0e 94 dc 0d 	call	0x1bb8	; 0x1bb8 <xQueueGenericReceive>
      f0:	88 23       	and	r24, r24
      f2:	99 f3       	breq	.-26     	; 0xda <draw_bullets_task+0xc>
		{
			if(xSemaphoreTake(xFramebufMutex,portMAX_DELAY))
      f4:	20 e0       	ldi	r18, 0x00	; 0
      f6:	4f ef       	ldi	r20, 0xFF	; 255
      f8:	5f ef       	ldi	r21, 0xFF	; 255
      fa:	60 e0       	ldi	r22, 0x00	; 0
      fc:	70 e0       	ldi	r23, 0x00	; 0
      fe:	80 91 5c 08 	lds	r24, 0x085C	; 0x80085c <xFramebufMutex>
     102:	90 91 5d 08 	lds	r25, 0x085D	; 0x80085d <xFramebufMutex+0x1>
     106:	0e 94 dc 0d 	call	0x1bb8	; 0x1bb8 <xQueueGenericReceive>
     10a:	88 23       	and	r24, r24
     10c:	31 f3       	breq	.-52     	; 0xda <draw_bullets_task+0xc>
			{
				//draw first bullet
				
				if(frame_buf[getY(&bullet1)] != power(2,getX(&bullet1)))
     10e:	8f e9       	ldi	r24, 0x9F	; 159
     110:	91 e0       	ldi	r25, 0x01	; 1
     112:	0e 94 e9 04 	call	0x9d2	; 0x9d2 <getY>
     116:	e8 2f       	mov	r30, r24
     118:	f0 e0       	ldi	r31, 0x00	; 0
     11a:	ee 0f       	add	r30, r30
     11c:	ff 1f       	adc	r31, r31
     11e:	e9 55       	subi	r30, 0x59	; 89
     120:	fe 4f       	sbci	r31, 0xFE	; 254
     122:	c0 81       	ld	r28, Z
     124:	d1 81       	ldd	r29, Z+1	; 0x01
     126:	8f e9       	ldi	r24, 0x9F	; 159
     128:	91 e0       	ldi	r25, 0x01	; 1
     12a:	0e 94 e6 04 	call	0x9cc	; 0x9cc <getX>
     12e:	68 2f       	mov	r22, r24
     130:	70 e0       	ldi	r23, 0x00	; 0
     132:	82 e0       	ldi	r24, 0x02	; 2
     134:	90 e0       	ldi	r25, 0x00	; 0
     136:	0e 94 2d 0b 	call	0x165a	; 0x165a <power>
     13a:	c8 17       	cp	r28, r24
     13c:	d9 07       	cpc	r29, r25
     13e:	d9 f0       	breq	.+54     	; 0x176 <draw_bullets_task+0xa8>
				frame_buf[getY(&bullet1)] += power(2,getX(&bullet1));
     140:	8f e9       	ldi	r24, 0x9F	; 159
     142:	91 e0       	ldi	r25, 0x01	; 1
     144:	0e 94 e6 04 	call	0x9cc	; 0x9cc <getX>
     148:	68 2f       	mov	r22, r24
     14a:	70 e0       	ldi	r23, 0x00	; 0
     14c:	82 e0       	ldi	r24, 0x02	; 2
     14e:	90 e0       	ldi	r25, 0x00	; 0
     150:	0e 94 2d 0b 	call	0x165a	; 0x165a <power>
     154:	ec 01       	movw	r28, r24
     156:	8f e9       	ldi	r24, 0x9F	; 159
     158:	91 e0       	ldi	r25, 0x01	; 1
     15a:	0e 94 e9 04 	call	0x9d2	; 0x9d2 <getY>
     15e:	e8 2f       	mov	r30, r24
     160:	f0 e0       	ldi	r31, 0x00	; 0
     162:	ee 0f       	add	r30, r30
     164:	ff 1f       	adc	r31, r31
     166:	e9 55       	subi	r30, 0x59	; 89
     168:	fe 4f       	sbci	r31, 0xFE	; 254
     16a:	80 81       	ld	r24, Z
     16c:	91 81       	ldd	r25, Z+1	; 0x01
     16e:	c8 0f       	add	r28, r24
     170:	d9 1f       	adc	r29, r25
     172:	d1 83       	std	Z+1, r29	; 0x01
     174:	c0 83       	st	Z, r28

				//draw second bullet
				
				if(frame_buf[getY(&bullet2)] != power(2,getX(&bullet2)))
     176:	81 ea       	ldi	r24, 0xA1	; 161
     178:	91 e0       	ldi	r25, 0x01	; 1
     17a:	0e 94 e9 04 	call	0x9d2	; 0x9d2 <getY>
     17e:	e8 2f       	mov	r30, r24
     180:	f0 e0       	ldi	r31, 0x00	; 0
     182:	ee 0f       	add	r30, r30
     184:	ff 1f       	adc	r31, r31
     186:	e9 55       	subi	r30, 0x59	; 89
     188:	fe 4f       	sbci	r31, 0xFE	; 254
     18a:	c0 81       	ld	r28, Z
     18c:	d1 81       	ldd	r29, Z+1	; 0x01
     18e:	81 ea       	ldi	r24, 0xA1	; 161
     190:	91 e0       	ldi	r25, 0x01	; 1
     192:	0e 94 e6 04 	call	0x9cc	; 0x9cc <getX>
     196:	68 2f       	mov	r22, r24
     198:	70 e0       	ldi	r23, 0x00	; 0
     19a:	82 e0       	ldi	r24, 0x02	; 2
     19c:	90 e0       	ldi	r25, 0x00	; 0
     19e:	0e 94 2d 0b 	call	0x165a	; 0x165a <power>
     1a2:	c8 17       	cp	r28, r24
     1a4:	d9 07       	cpc	r29, r25
     1a6:	d9 f0       	breq	.+54     	; 0x1de <draw_bullets_task+0x110>
				frame_buf[getY(&bullet2)] += power(2,getX(&bullet2));
     1a8:	81 ea       	ldi	r24, 0xA1	; 161
     1aa:	91 e0       	ldi	r25, 0x01	; 1
     1ac:	0e 94 e6 04 	call	0x9cc	; 0x9cc <getX>
     1b0:	68 2f       	mov	r22, r24
     1b2:	70 e0       	ldi	r23, 0x00	; 0
     1b4:	82 e0       	ldi	r24, 0x02	; 2
     1b6:	90 e0       	ldi	r25, 0x00	; 0
     1b8:	0e 94 2d 0b 	call	0x165a	; 0x165a <power>
     1bc:	ec 01       	movw	r28, r24
     1be:	81 ea       	ldi	r24, 0xA1	; 161
     1c0:	91 e0       	ldi	r25, 0x01	; 1
     1c2:	0e 94 e9 04 	call	0x9d2	; 0x9d2 <getY>
     1c6:	e8 2f       	mov	r30, r24
     1c8:	f0 e0       	ldi	r31, 0x00	; 0
     1ca:	ee 0f       	add	r30, r30
     1cc:	ff 1f       	adc	r31, r31
     1ce:	e9 55       	subi	r30, 0x59	; 89
     1d0:	fe 4f       	sbci	r31, 0xFE	; 254
     1d2:	80 81       	ld	r24, Z
     1d4:	91 81       	ldd	r25, Z+1	; 0x01
     1d6:	c8 0f       	add	r28, r24
     1d8:	d9 1f       	adc	r29, r25
     1da:	d1 83       	std	Z+1, r29	; 0x01
     1dc:	c0 83       	st	Z, r28
				xSemaphoreGive(xFramebufMutex);
     1de:	20 e0       	ldi	r18, 0x00	; 0
     1e0:	40 e0       	ldi	r20, 0x00	; 0
     1e2:	50 e0       	ldi	r21, 0x00	; 0
     1e4:	60 e0       	ldi	r22, 0x00	; 0
     1e6:	70 e0       	ldi	r23, 0x00	; 0
     1e8:	80 91 5c 08 	lds	r24, 0x085C	; 0x80085c <xFramebufMutex>
     1ec:	90 91 5d 08 	lds	r25, 0x085D	; 0x80085d <xFramebufMutex+0x1>
     1f0:	0e 94 c6 0c 	call	0x198c	; 0x198c <xQueueGenericSend>
     1f4:	72 cf       	rjmp	.-284    	; 0xda <draw_bullets_task+0xc>

000001f6 <update_bullets_cords_task>:
}

static void update_bullets_cords_task(void *pvParameters)
{
	(void)pvParameters;
	vTaskSetApplicationTaskTag( NULL, ( void * ) 3);
     1f6:	63 e0       	ldi	r22, 0x03	; 3
     1f8:	70 e0       	ldi	r23, 0x00	; 0
     1fa:	80 e0       	ldi	r24, 0x00	; 0
     1fc:	90 e0       	ldi	r25, 0x00	; 0
     1fe:	0e 94 23 12 	call	0x2446	; 0x2446 <vTaskSetApplicationTaskTag>
	while(1)
	{
		if(xSemaphoreTake(xTimerSemaphoreBullets, portMAX_DELAY))
     202:	20 e0       	ldi	r18, 0x00	; 0
     204:	4f ef       	ldi	r20, 0xFF	; 255
     206:	5f ef       	ldi	r21, 0xFF	; 255
     208:	60 e0       	ldi	r22, 0x00	; 0
     20a:	70 e0       	ldi	r23, 0x00	; 0
     20c:	80 91 5e 08 	lds	r24, 0x085E	; 0x80085e <xTimerSemaphoreBullets>
     210:	90 91 5f 08 	lds	r25, 0x085F	; 0x80085f <xTimerSemaphoreBullets+0x1>
     214:	0e 94 dc 0d 	call	0x1bb8	; 0x1bb8 <xQueueGenericReceive>
     218:	88 23       	and	r24, r24
     21a:	99 f3       	breq	.-26     	; 0x202 <update_bullets_cords_task+0xc>
		{
			//update first bullet
			if(getY(&bullet1) > 12)
     21c:	8f e9       	ldi	r24, 0x9F	; 159
     21e:	91 e0       	ldi	r25, 0x01	; 1
     220:	0e 94 e9 04 	call	0x9d2	; 0x9d2 <getY>
     224:	8d 30       	cpi	r24, 0x0D	; 13
     226:	90 f0       	brcs	.+36     	; 0x24c <update_bullets_cords_task+0x56>
			{
				setX(&bullet1,getX(&ship1));
     228:	85 ea       	ldi	r24, 0xA5	; 165
     22a:	91 e0       	ldi	r25, 0x01	; 1
     22c:	0e 94 e6 04 	call	0x9cc	; 0x9cc <getX>
     230:	68 2f       	mov	r22, r24
     232:	8f e9       	ldi	r24, 0x9F	; 159
     234:	91 e0       	ldi	r25, 0x01	; 1
     236:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <setX>
				setY(&bullet1,getY(&ship1));
     23a:	85 ea       	ldi	r24, 0xA5	; 165
     23c:	91 e0       	ldi	r25, 0x01	; 1
     23e:	0e 94 e9 04 	call	0x9d2	; 0x9d2 <getY>
     242:	68 2f       	mov	r22, r24
     244:	8f e9       	ldi	r24, 0x9F	; 159
     246:	91 e0       	ldi	r25, 0x01	; 1
     248:	0e 94 ef 04 	call	0x9de	; 0x9de <setY>

			}
			setY(&bullet1,getY(&bullet1)+1);
     24c:	8f e9       	ldi	r24, 0x9F	; 159
     24e:	91 e0       	ldi	r25, 0x01	; 1
     250:	0e 94 e9 04 	call	0x9d2	; 0x9d2 <getY>
     254:	61 e0       	ldi	r22, 0x01	; 1
     256:	68 0f       	add	r22, r24
     258:	8f e9       	ldi	r24, 0x9F	; 159
     25a:	91 e0       	ldi	r25, 0x01	; 1
     25c:	0e 94 ef 04 	call	0x9de	; 0x9de <setY>

			//update second bullet			
			if(getY(&bullet2) < 1)
     260:	81 ea       	ldi	r24, 0xA1	; 161
     262:	91 e0       	ldi	r25, 0x01	; 1
     264:	0e 94 e9 04 	call	0x9d2	; 0x9d2 <getY>
     268:	81 11       	cpse	r24, r1
     26a:	12 c0       	rjmp	.+36     	; 0x290 <update_bullets_cords_task+0x9a>
			{
				setX(&bullet2,getX(&ship2));
     26c:	83 ea       	ldi	r24, 0xA3	; 163
     26e:	91 e0       	ldi	r25, 0x01	; 1
     270:	0e 94 e6 04 	call	0x9cc	; 0x9cc <getX>
     274:	68 2f       	mov	r22, r24
     276:	81 ea       	ldi	r24, 0xA1	; 161
     278:	91 e0       	ldi	r25, 0x01	; 1
     27a:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <setX>
				setY(&bullet2,getY(&ship2));
     27e:	83 ea       	ldi	r24, 0xA3	; 163
     280:	91 e0       	ldi	r25, 0x01	; 1
     282:	0e 94 e9 04 	call	0x9d2	; 0x9d2 <getY>
     286:	68 2f       	mov	r22, r24
     288:	81 ea       	ldi	r24, 0xA1	; 161
     28a:	91 e0       	ldi	r25, 0x01	; 1
     28c:	0e 94 ef 04 	call	0x9de	; 0x9de <setY>

			}
			setY(&bullet2,getY(&bullet2)-1);
     290:	81 ea       	ldi	r24, 0xA1	; 161
     292:	91 e0       	ldi	r25, 0x01	; 1
     294:	0e 94 e9 04 	call	0x9d2	; 0x9d2 <getY>
     298:	6f ef       	ldi	r22, 0xFF	; 255
     29a:	68 0f       	add	r22, r24
     29c:	81 ea       	ldi	r24, 0xA1	; 161
     29e:	91 e0       	ldi	r25, 0x01	; 1
     2a0:	0e 94 ef 04 	call	0x9de	; 0x9de <setY>
     2a4:	ae cf       	rjmp	.-164    	; 0x202 <update_bullets_cords_task+0xc>

000002a6 <joystick_task>:
}

static void joystick_task(void *pvParameters)
{
	(void)pvParameters;
	vTaskSetApplicationTaskTag( NULL, ( void * ) 2);
     2a6:	62 e0       	ldi	r22, 0x02	; 2
     2a8:	70 e0       	ldi	r23, 0x00	; 0
     2aa:	80 e0       	ldi	r24, 0x00	; 0
     2ac:	90 e0       	ldi	r25, 0x00	; 0
     2ae:	0e 94 23 12 	call	0x2446	; 0x2446 <vTaskSetApplicationTaskTag>
	while(1)
	{
		if(xSemaphoreTake(xTimerSemaphoreJoystick, portMAX_DELAY))
     2b2:	20 e0       	ldi	r18, 0x00	; 0
     2b4:	4f ef       	ldi	r20, 0xFF	; 255
     2b6:	5f ef       	ldi	r21, 0xFF	; 255
     2b8:	60 e0       	ldi	r22, 0x00	; 0
     2ba:	70 e0       	ldi	r23, 0x00	; 0
     2bc:	80 91 47 08 	lds	r24, 0x0847	; 0x800847 <xTimerSemaphoreJoystick>
     2c0:	90 91 48 08 	lds	r25, 0x0848	; 0x800848 <xTimerSemaphoreJoystick+0x1>
     2c4:	0e 94 dc 0d 	call	0x1bb8	; 0x1bb8 <xQueueGenericReceive>
     2c8:	88 23       	and	r24, r24
     2ca:	99 f3       	breq	.-26     	; 0x2b2 <joystick_task+0xc>
		{


			if(joystick_func() == 194) //right
     2cc:	0e 94 06 05 	call	0xa0c	; 0xa0c <joystick_func>
     2d0:	82 3c       	cpi	r24, 0xC2	; 194
     2d2:	91 05       	cpc	r25, r1
     2d4:	b9 f4       	brne	.+46     	; 0x304 <joystick_task+0x5e>
			{
				if(getX(&ship1)> 7)
     2d6:	85 ea       	ldi	r24, 0xA5	; 165
     2d8:	91 e0       	ldi	r25, 0x01	; 1
     2da:	0e 94 e6 04 	call	0x9cc	; 0x9cc <getX>
     2de:	88 30       	cpi	r24, 0x08	; 8
     2e0:	30 f0       	brcs	.+12     	; 0x2ee <joystick_task+0x48>
				{
					setX(&ship1,8);
     2e2:	68 e0       	ldi	r22, 0x08	; 8
     2e4:	85 ea       	ldi	r24, 0xA5	; 165
     2e6:	91 e0       	ldi	r25, 0x01	; 1
     2e8:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <setX>
     2ec:	e2 cf       	rjmp	.-60     	; 0x2b2 <joystick_task+0xc>
				}
				else
				setX(&ship1,getX(&ship1) + 1);
     2ee:	85 ea       	ldi	r24, 0xA5	; 165
     2f0:	91 e0       	ldi	r25, 0x01	; 1
     2f2:	0e 94 e6 04 	call	0x9cc	; 0x9cc <getX>
     2f6:	61 e0       	ldi	r22, 0x01	; 1
     2f8:	68 0f       	add	r22, r24
     2fa:	85 ea       	ldi	r24, 0xA5	; 165
     2fc:	91 e0       	ldi	r25, 0x01	; 1
     2fe:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <setX>
     302:	d7 cf       	rjmp	.-82     	; 0x2b2 <joystick_task+0xc>

			}
			else if(joystick_func() == 131)//left
     304:	0e 94 06 05 	call	0xa0c	; 0xa0c <joystick_func>
     308:	83 38       	cpi	r24, 0x83	; 131
     30a:	91 05       	cpc	r25, r1
     30c:	b9 f4       	brne	.+46     	; 0x33c <joystick_task+0x96>
			{
				if(getX(&ship1) < 2)
     30e:	85 ea       	ldi	r24, 0xA5	; 165
     310:	91 e0       	ldi	r25, 0x01	; 1
     312:	0e 94 e6 04 	call	0x9cc	; 0x9cc <getX>
     316:	82 30       	cpi	r24, 0x02	; 2
     318:	30 f4       	brcc	.+12     	; 0x326 <joystick_task+0x80>
				{
					setX(&ship1,1);
     31a:	61 e0       	ldi	r22, 0x01	; 1
     31c:	85 ea       	ldi	r24, 0xA5	; 165
     31e:	91 e0       	ldi	r25, 0x01	; 1
     320:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <setX>
     324:	c6 cf       	rjmp	.-116    	; 0x2b2 <joystick_task+0xc>
				}
				else
				setX(&ship1,getX(&ship1) - 1);
     326:	85 ea       	ldi	r24, 0xA5	; 165
     328:	91 e0       	ldi	r25, 0x01	; 1
     32a:	0e 94 e6 04 	call	0x9cc	; 0x9cc <getX>
     32e:	6f ef       	ldi	r22, 0xFF	; 255
     330:	68 0f       	add	r22, r24
     332:	85 ea       	ldi	r24, 0xA5	; 165
     334:	91 e0       	ldi	r25, 0x01	; 1
     336:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <setX>
     33a:	bb cf       	rjmp	.-138    	; 0x2b2 <joystick_task+0xc>
			}
			else if(joystick_func() == 67)//down
     33c:	0e 94 06 05 	call	0xa0c	; 0xa0c <joystick_func>
     340:	83 34       	cpi	r24, 0x43	; 67
     342:	91 05       	cpc	r25, r1
     344:	b9 f4       	brne	.+46     	; 0x374 <joystick_task+0xce>
			{
				if(getY(&ship1) < 1)
     346:	85 ea       	ldi	r24, 0xA5	; 165
     348:	91 e0       	ldi	r25, 0x01	; 1
     34a:	0e 94 e9 04 	call	0x9d2	; 0x9d2 <getY>
     34e:	81 11       	cpse	r24, r1
     350:	06 c0       	rjmp	.+12     	; 0x35e <joystick_task+0xb8>
				{
					setY(&ship1,0);
     352:	60 e0       	ldi	r22, 0x00	; 0
     354:	85 ea       	ldi	r24, 0xA5	; 165
     356:	91 e0       	ldi	r25, 0x01	; 1
     358:	0e 94 ef 04 	call	0x9de	; 0x9de <setY>
     35c:	aa cf       	rjmp	.-172    	; 0x2b2 <joystick_task+0xc>
				}
				else
				setY(&ship1,getY(&ship1) - 1);
     35e:	85 ea       	ldi	r24, 0xA5	; 165
     360:	91 e0       	ldi	r25, 0x01	; 1
     362:	0e 94 e9 04 	call	0x9d2	; 0x9d2 <getY>
     366:	6f ef       	ldi	r22, 0xFF	; 255
     368:	68 0f       	add	r22, r24
     36a:	85 ea       	ldi	r24, 0xA5	; 165
     36c:	91 e0       	ldi	r25, 0x01	; 1
     36e:	0e 94 ef 04 	call	0x9de	; 0x9de <setY>
     372:	9f cf       	rjmp	.-194    	; 0x2b2 <joystick_task+0xc>

				
			}
			else if(joystick_func() == 193) //up
     374:	0e 94 06 05 	call	0xa0c	; 0xa0c <joystick_func>
     378:	81 3c       	cpi	r24, 0xC1	; 193
     37a:	91 05       	cpc	r25, r1
     37c:	09 f0       	breq	.+2      	; 0x380 <joystick_task+0xda>
     37e:	99 cf       	rjmp	.-206    	; 0x2b2 <joystick_task+0xc>
			{
				if(getY(&ship1) > 4)
     380:	85 ea       	ldi	r24, 0xA5	; 165
     382:	91 e0       	ldi	r25, 0x01	; 1
     384:	0e 94 e9 04 	call	0x9d2	; 0x9d2 <getY>
     388:	85 30       	cpi	r24, 0x05	; 5
     38a:	30 f0       	brcs	.+12     	; 0x398 <joystick_task+0xf2>
				{
					setY(&ship1,5);
     38c:	65 e0       	ldi	r22, 0x05	; 5
     38e:	85 ea       	ldi	r24, 0xA5	; 165
     390:	91 e0       	ldi	r25, 0x01	; 1
     392:	0e 94 ef 04 	call	0x9de	; 0x9de <setY>
     396:	8d cf       	rjmp	.-230    	; 0x2b2 <joystick_task+0xc>
				}
				else
				setY(&ship1,getY(&ship1) + 1);
     398:	85 ea       	ldi	r24, 0xA5	; 165
     39a:	91 e0       	ldi	r25, 0x01	; 1
     39c:	0e 94 e9 04 	call	0x9d2	; 0x9d2 <getY>
     3a0:	61 e0       	ldi	r22, 0x01	; 1
     3a2:	68 0f       	add	r22, r24
     3a4:	85 ea       	ldi	r24, 0xA5	; 165
     3a6:	91 e0       	ldi	r25, 0x01	; 1
     3a8:	0e 94 ef 04 	call	0x9de	; 0x9de <setY>
     3ac:	82 cf       	rjmp	.-252    	; 0x2b2 <joystick_task+0xc>

000003ae <handle_display>:

void handle_display(void)
{
	static uint8_t col = 0;
	
	if (col == 0)
     3ae:	80 91 9e 01 	lds	r24, 0x019E	; 0x80019e <__data_end>
     3b2:	81 11       	cpse	r24, r1
     3b4:	02 c0       	rjmp	.+4      	; 0x3ba <handle_display+0xc>
	{
		prepare_shiftregister();
     3b6:	0e 94 f2 04 	call	0x9e4	; 0x9e4 <prepare_shiftregister>
	}
	
	load_col_value(frame_buf[col]);
     3ba:	e0 91 9e 01 	lds	r30, 0x019E	; 0x80019e <__data_end>
     3be:	f0 e0       	ldi	r31, 0x00	; 0
     3c0:	ee 0f       	add	r30, r30
     3c2:	ff 1f       	adc	r31, r31
     3c4:	e9 55       	subi	r30, 0x59	; 89
     3c6:	fe 4f       	sbci	r31, 0xFE	; 254
     3c8:	80 81       	ld	r24, Z
     3ca:	91 81       	ldd	r25, Z+1	; 0x01
     3cc:	0e 94 fa 04 	call	0x9f4	; 0x9f4 <load_col_value>
	
	clock_shift_register_and_prepare_for_next_col();
     3d0:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <clock_shift_register_and_prepare_for_next_col>
	
	// count column up - prepare for next
	col++;
     3d4:	80 91 9e 01 	lds	r24, 0x019E	; 0x80019e <__data_end>
     3d8:	8f 5f       	subi	r24, 0xFF	; 255
	if (col > 13)
     3da:	8e 30       	cpi	r24, 0x0E	; 14
     3dc:	18 f4       	brcc	.+6      	; 0x3e4 <handle_display+0x36>
	load_col_value(frame_buf[col]);
	
	clock_shift_register_and_prepare_for_next_col();
	
	// count column up - prepare for next
	col++;
     3de:	80 93 9e 01 	sts	0x019E, r24	; 0x80019e <__data_end>
     3e2:	08 95       	ret
	if (col > 13)
	{
		col = 0;
     3e4:	10 92 9e 01 	sts	0x019E, r1	; 0x80019e <__data_end>
     3e8:	08 95       	ret

000003ea <init_variables>:
	}
}

init_variables()
{
	setX(&bullet1,0);
     3ea:	60 e0       	ldi	r22, 0x00	; 0
     3ec:	8f e9       	ldi	r24, 0x9F	; 159
     3ee:	91 e0       	ldi	r25, 0x01	; 1
     3f0:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <setX>
	setY(&bullet1,15);
     3f4:	6f e0       	ldi	r22, 0x0F	; 15
     3f6:	8f e9       	ldi	r24, 0x9F	; 159
     3f8:	91 e0       	ldi	r25, 0x01	; 1
     3fa:	0e 94 ef 04 	call	0x9de	; 0x9de <setY>
	
	setX(&bullet2,15);
     3fe:	6f e0       	ldi	r22, 0x0F	; 15
     400:	81 ea       	ldi	r24, 0xA1	; 161
     402:	91 e0       	ldi	r25, 0x01	; 1
     404:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <setX>
	setY(&bullet2,0);
     408:	60 e0       	ldi	r22, 0x00	; 0
     40a:	81 ea       	ldi	r24, 0xA1	; 161
     40c:	91 e0       	ldi	r25, 0x01	; 1
     40e:	0e 94 ef 04 	call	0x9de	; 0x9de <setY>
	
	setX(&ship1,4);
     412:	64 e0       	ldi	r22, 0x04	; 4
     414:	85 ea       	ldi	r24, 0xA5	; 165
     416:	91 e0       	ldi	r25, 0x01	; 1
     418:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <setX>
	setY(&ship1,0);
     41c:	60 e0       	ldi	r22, 0x00	; 0
     41e:	85 ea       	ldi	r24, 0xA5	; 165
     420:	91 e0       	ldi	r25, 0x01	; 1
     422:	0e 94 ef 04 	call	0x9de	; 0x9de <setY>
	
	setX(&ship2,4);
     426:	64 e0       	ldi	r22, 0x04	; 4
     428:	83 ea       	ldi	r24, 0xA3	; 163
     42a:	91 e0       	ldi	r25, 0x01	; 1
     42c:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <setX>
	setY(&ship2,13);
     430:	6d e0       	ldi	r22, 0x0D	; 13
     432:	83 ea       	ldi	r24, 0xA3	; 163
     434:	91 e0       	ldi	r25, 0x01	; 1
     436:	0e 94 ef 04 	call	0x9de	; 0x9de <setY>
}
     43a:	08 95       	ret

0000043c <main>:
}
///////////TASKS END HERE///////////

int main(void)
{
	init_board();
     43c:	0e 94 72 05 	call	0xae4	; 0xae4 <init_board>
	
	// Shift register Enable output (G=0)
	PORTD &= ~_BV(PORTD6);
     440:	5e 98       	cbi	0x0b, 6	; 11

	_x_com_received_chars_queue = xQueueCreate( _COM_RX_QUEUE_LENGTH, ( unsigned portBASE_TYPE ) sizeof( uint8_t ) );
     442:	40 e0       	ldi	r20, 0x00	; 0
     444:	61 e0       	ldi	r22, 0x01	; 1
     446:	8e e1       	ldi	r24, 0x1E	; 30
     448:	0e 94 93 0c 	call	0x1926	; 0x1926 <xQueueGenericCreate>
	init_com(_x_com_received_chars_queue);
     44c:	0e 94 29 05 	call	0xa52	; 0xa52 <init_com>

	pc_ship_queue = xQueueCreate(10,sizeof(uint8_t));
     450:	40 e0       	ldi	r20, 0x00	; 0
     452:	61 e0       	ldi	r22, 0x01	; 1
     454:	8a e0       	ldi	r24, 0x0A	; 10
     456:	0e 94 93 0c 	call	0x1926	; 0x1926 <xQueueGenericCreate>
     45a:	90 93 50 08 	sts	0x0850, r25	; 0x800850 <pc_ship_queue+0x1>
     45e:	80 93 4f 08 	sts	0x084F, r24	; 0x80084f <pc_ship_queue>
	
	seq_num = 0;
     462:	10 92 57 08 	sts	0x0857, r1	; 0x800857 <seq_num>
	results[0] = 0;
     466:	e1 e5       	ldi	r30, 0x51	; 81
     468:	f8 e0       	ldi	r31, 0x08	; 8
     46a:	10 82       	st	Z, r1
	results[1] = 0;
     46c:	11 82       	std	Z+1, r1	; 0x01
	init_variables();
     46e:	0e 94 f5 01 	call	0x3ea	; 0x3ea <init_variables>
	init_timers();
     472:	0e 94 44 0a 	call	0x1488	; 0x1488 <init_timers>
	init_semaphores();
     476:	0e 94 67 0a 	call	0x14ce	; 0x14ce <init_semaphores>
	start_timers();
     47a:	0e 94 ae 0a 	call	0x155c	; 0x155c <start_timers>
	
	BaseType_t t1 = xTaskCreate(check_collisions_task, (const char *)"check_collisions_task", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL);
     47e:	e1 2c       	mov	r14, r1
     480:	f1 2c       	mov	r15, r1
     482:	00 e0       	ldi	r16, 0x00	; 0
     484:	20 e0       	ldi	r18, 0x00	; 0
     486:	30 e0       	ldi	r19, 0x00	; 0
     488:	40 e5       	ldi	r20, 0x50	; 80
     48a:	50 e0       	ldi	r21, 0x00	; 0
     48c:	6a e0       	ldi	r22, 0x0A	; 10
     48e:	71 e0       	ldi	r23, 0x01	; 1
     490:	8c e3       	ldi	r24, 0x3C	; 60
     492:	94 e0       	ldi	r25, 0x04	; 4
     494:	0e 94 3c 0f 	call	0x1e78	; 0x1e78 <xTaskCreate>
	BaseType_t t2 = xTaskCreate(joystick_task, (const char *)"joystick_task", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL);
     498:	20 e0       	ldi	r18, 0x00	; 0
     49a:	30 e0       	ldi	r19, 0x00	; 0
     49c:	40 e5       	ldi	r20, 0x50	; 80
     49e:	50 e0       	ldi	r21, 0x00	; 0
     4a0:	60 e2       	ldi	r22, 0x20	; 32
     4a2:	71 e0       	ldi	r23, 0x01	; 1
     4a4:	83 e5       	ldi	r24, 0x53	; 83
     4a6:	91 e0       	ldi	r25, 0x01	; 1
     4a8:	0e 94 3c 0f 	call	0x1e78	; 0x1e78 <xTaskCreate>
	BaseType_t t3 = xTaskCreate(draw_ships_task, (const char *)"draw_ships_task", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL);
     4ac:	20 e0       	ldi	r18, 0x00	; 0
     4ae:	30 e0       	ldi	r19, 0x00	; 0
     4b0:	40 e5       	ldi	r20, 0x50	; 80
     4b2:	50 e0       	ldi	r21, 0x00	; 0
     4b4:	6e e2       	ldi	r22, 0x2E	; 46
     4b6:	71 e0       	ldi	r23, 0x01	; 1
     4b8:	8a e8       	ldi	r24, 0x8A	; 138
     4ba:	92 e0       	ldi	r25, 0x02	; 2
     4bc:	0e 94 3c 0f 	call	0x1e78	; 0x1e78 <xTaskCreate>
	BaseType_t t4 = xTaskCreate(update_bullets_cords_task, (const char *)"bullets_update_task", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL);
     4c0:	20 e0       	ldi	r18, 0x00	; 0
     4c2:	30 e0       	ldi	r19, 0x00	; 0
     4c4:	40 e5       	ldi	r20, 0x50	; 80
     4c6:	50 e0       	ldi	r21, 0x00	; 0
     4c8:	6e e3       	ldi	r22, 0x3E	; 62
     4ca:	71 e0       	ldi	r23, 0x01	; 1
     4cc:	8b ef       	ldi	r24, 0xFB	; 251
     4ce:	90 e0       	ldi	r25, 0x00	; 0
     4d0:	0e 94 3c 0f 	call	0x1e78	; 0x1e78 <xTaskCreate>
	BaseType_t t5 = xTaskCreate(draw_bullets_task, (const char *)"draw_bullets_task", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL);
     4d4:	20 e0       	ldi	r18, 0x00	; 0
     4d6:	30 e0       	ldi	r19, 0x00	; 0
     4d8:	40 e5       	ldi	r20, 0x50	; 80
     4da:	50 e0       	ldi	r21, 0x00	; 0
     4dc:	62 e5       	ldi	r22, 0x52	; 82
     4de:	71 e0       	ldi	r23, 0x01	; 1
     4e0:	87 e6       	ldi	r24, 0x67	; 103
     4e2:	90 e0       	ldi	r25, 0x00	; 0
     4e4:	0e 94 3c 0f 	call	0x1e78	; 0x1e78 <xTaskCreate>
	//BaseType_t t6 = xTaskCreate(PCconn_task, (const char *)"PCconn_task", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL);
	//BaseType_t t7 = xTaskCreate(move_pc_ship_task, (const char *)"move_pc_ship", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL);


	// Start the display handler timer
	init_display_timer(handle_display);
     4e8:	87 ed       	ldi	r24, 0xD7	; 215
     4ea:	91 e0       	ldi	r25, 0x01	; 1
     4ec:	0e 94 2e 05 	call	0xa5c	; 0xa5c <init_display_timer>
	
	sei();
     4f0:	78 94       	sei
	
	//Start the scheduler
	vTaskStartScheduler();
     4f2:	0e 94 58 10 	call	0x20b0	; 0x20b0 <vTaskStartScheduler>
	
	//Should never reach here
	while (1)
	{
		vTaskDelay(1000);
     4f6:	88 ee       	ldi	r24, 0xE8	; 232
     4f8:	93 e0       	ldi	r25, 0x03	; 3
     4fa:	0e 94 d0 11 	call	0x23a0	; 0x23a0 <vTaskDelay>
     4fe:	fb cf       	rjmp	.-10     	; 0x4f6 <main+0xba>

00000500 <clear_frame>:
	setX(&ship2,4);
	setY(&ship2,13);
}

void clear_frame()
{
     500:	e7 ea       	ldi	r30, 0xA7	; 167
     502:	f1 e0       	ldi	r31, 0x01	; 1
     504:	83 ec       	ldi	r24, 0xC3	; 195
     506:	91 e0       	ldi	r25, 0x01	; 1
	for(int i = 0; i < 14; i++)
	{
		frame_buf[i] = 0;
     508:	11 92       	st	Z+, r1
     50a:	11 92       	st	Z+, r1
	setY(&ship2,13);
}

void clear_frame()
{
	for(int i = 0; i < 14; i++)
     50c:	e8 17       	cp	r30, r24
     50e:	f9 07       	cpc	r31, r25
     510:	d9 f7       	brne	.-10     	; 0x508 <clear_frame+0x8>
	{
		frame_buf[i] = 0;
	}
}
     512:	08 95       	ret

00000514 <draw_ships_task>:
}

static void draw_ships_task(void *pvParameters)
{
	(void)pvParameters;
	vTaskSetApplicationTaskTag( NULL, ( void * ) 5);
     514:	65 e0       	ldi	r22, 0x05	; 5
     516:	70 e0       	ldi	r23, 0x00	; 0
     518:	80 e0       	ldi	r24, 0x00	; 0
     51a:	90 e0       	ldi	r25, 0x00	; 0
     51c:	0e 94 23 12 	call	0x2446	; 0x2446 <vTaskSetApplicationTaskTag>
	
	while (1)
	{
		if(xSemaphoreTake(xTimerSemaphoreDrawShips, portMAX_DELAY))
     520:	20 e0       	ldi	r18, 0x00	; 0
     522:	4f ef       	ldi	r20, 0xFF	; 255
     524:	5f ef       	ldi	r21, 0xFF	; 255
     526:	60 e0       	ldi	r22, 0x00	; 0
     528:	70 e0       	ldi	r23, 0x00	; 0
     52a:	80 91 4b 08 	lds	r24, 0x084B	; 0x80084b <xTimerSemaphoreDrawShips>
     52e:	90 91 4c 08 	lds	r25, 0x084C	; 0x80084c <xTimerSemaphoreDrawShips+0x1>
     532:	0e 94 dc 0d 	call	0x1bb8	; 0x1bb8 <xQueueGenericReceive>
     536:	88 23       	and	r24, r24
     538:	99 f3       	breq	.-26     	; 0x520 <draw_ships_task+0xc>
		{
			if(xSemaphoreTake(xFramebufMutex,portMAX_DELAY))
     53a:	20 e0       	ldi	r18, 0x00	; 0
     53c:	4f ef       	ldi	r20, 0xFF	; 255
     53e:	5f ef       	ldi	r21, 0xFF	; 255
     540:	60 e0       	ldi	r22, 0x00	; 0
     542:	70 e0       	ldi	r23, 0x00	; 0
     544:	80 91 5c 08 	lds	r24, 0x085C	; 0x80085c <xFramebufMutex>
     548:	90 91 5d 08 	lds	r25, 0x085D	; 0x80085d <xFramebufMutex+0x1>
     54c:	0e 94 dc 0d 	call	0x1bb8	; 0x1bb8 <xQueueGenericReceive>
     550:	88 23       	and	r24, r24
     552:	31 f3       	breq	.-52     	; 0x520 <draw_ships_task+0xc>
			{
				clear_frame();
     554:	0e 94 80 02 	call	0x500	; 0x500 <clear_frame>
				//draw first ship
				uint16_t a = power(2,getX(&ship1)-1);
     558:	85 ea       	ldi	r24, 0xA5	; 165
     55a:	91 e0       	ldi	r25, 0x01	; 1
     55c:	0e 94 e6 04 	call	0x9cc	; 0x9cc <getX>
     560:	68 2f       	mov	r22, r24
     562:	70 e0       	ldi	r23, 0x00	; 0
     564:	61 50       	subi	r22, 0x01	; 1
     566:	71 09       	sbc	r23, r1
     568:	82 e0       	ldi	r24, 0x02	; 2
     56a:	90 e0       	ldi	r25, 0x00	; 0
     56c:	0e 94 2d 0b 	call	0x165a	; 0x165a <power>
     570:	7c 01       	movw	r14, r24
				uint16_t b = power(2,getX(&ship1));
     572:	85 ea       	ldi	r24, 0xA5	; 165
     574:	91 e0       	ldi	r25, 0x01	; 1
     576:	0e 94 e6 04 	call	0x9cc	; 0x9cc <getX>
     57a:	68 2f       	mov	r22, r24
     57c:	70 e0       	ldi	r23, 0x00	; 0
     57e:	82 e0       	ldi	r24, 0x02	; 2
     580:	90 e0       	ldi	r25, 0x00	; 0
     582:	0e 94 2d 0b 	call	0x165a	; 0x165a <power>
     586:	8c 01       	movw	r16, r24
				uint16_t c = power(2,getX(&ship1)+1);
     588:	85 ea       	ldi	r24, 0xA5	; 165
     58a:	91 e0       	ldi	r25, 0x01	; 1
     58c:	0e 94 e6 04 	call	0x9cc	; 0x9cc <getX>
     590:	68 2f       	mov	r22, r24
     592:	70 e0       	ldi	r23, 0x00	; 0
     594:	6f 5f       	subi	r22, 0xFF	; 255
     596:	7f 4f       	sbci	r23, 0xFF	; 255
     598:	82 e0       	ldi	r24, 0x02	; 2
     59a:	90 e0       	ldi	r25, 0x00	; 0
     59c:	0e 94 2d 0b 	call	0x165a	; 0x165a <power>
     5a0:	ec 01       	movw	r28, r24
				
				frame_buf[getY(&ship1)] = a + b + c;
     5a2:	85 ea       	ldi	r24, 0xA5	; 165
     5a4:	91 e0       	ldi	r25, 0x01	; 1
     5a6:	0e 94 e9 04 	call	0x9d2	; 0x9d2 <getY>
     5aa:	e8 2f       	mov	r30, r24
     5ac:	f0 e0       	ldi	r31, 0x00	; 0
     5ae:	ee 0f       	add	r30, r30
     5b0:	ff 1f       	adc	r31, r31
     5b2:	e9 55       	subi	r30, 0x59	; 89
     5b4:	fe 4f       	sbci	r31, 0xFE	; 254
     5b6:	0e 0d       	add	r16, r14
     5b8:	1f 1d       	adc	r17, r15
     5ba:	c0 0f       	add	r28, r16
     5bc:	d1 1f       	adc	r29, r17
     5be:	d1 83       	std	Z+1, r29	; 0x01
     5c0:	c0 83       	st	Z, r28
				frame_buf[getY(&ship1)+1] = power(2,getX(&ship1));
     5c2:	85 ea       	ldi	r24, 0xA5	; 165
     5c4:	91 e0       	ldi	r25, 0x01	; 1
     5c6:	0e 94 e9 04 	call	0x9d2	; 0x9d2 <getY>
     5ca:	c8 2f       	mov	r28, r24
     5cc:	85 ea       	ldi	r24, 0xA5	; 165
     5ce:	91 e0       	ldi	r25, 0x01	; 1
     5d0:	0e 94 e6 04 	call	0x9cc	; 0x9cc <getX>
     5d4:	68 2f       	mov	r22, r24
     5d6:	70 e0       	ldi	r23, 0x00	; 0
     5d8:	82 e0       	ldi	r24, 0x02	; 2
     5da:	90 e0       	ldi	r25, 0x00	; 0
     5dc:	0e 94 2d 0b 	call	0x165a	; 0x165a <power>
     5e0:	ec 2f       	mov	r30, r28
     5e2:	f0 e0       	ldi	r31, 0x00	; 0
     5e4:	ee 0f       	add	r30, r30
     5e6:	ff 1f       	adc	r31, r31
     5e8:	e7 55       	subi	r30, 0x57	; 87
     5ea:	fe 4f       	sbci	r31, 0xFE	; 254
     5ec:	91 83       	std	Z+1, r25	; 0x01
     5ee:	80 83       	st	Z, r24
				
				//draw second ship
				a = power(2,getX(&ship2)-1);
     5f0:	83 ea       	ldi	r24, 0xA3	; 163
     5f2:	91 e0       	ldi	r25, 0x01	; 1
     5f4:	0e 94 e6 04 	call	0x9cc	; 0x9cc <getX>
     5f8:	68 2f       	mov	r22, r24
     5fa:	70 e0       	ldi	r23, 0x00	; 0
     5fc:	61 50       	subi	r22, 0x01	; 1
     5fe:	71 09       	sbc	r23, r1
     600:	82 e0       	ldi	r24, 0x02	; 2
     602:	90 e0       	ldi	r25, 0x00	; 0
     604:	0e 94 2d 0b 	call	0x165a	; 0x165a <power>
     608:	7c 01       	movw	r14, r24
				b = power(2,getX(&ship2));
     60a:	83 ea       	ldi	r24, 0xA3	; 163
     60c:	91 e0       	ldi	r25, 0x01	; 1
     60e:	0e 94 e6 04 	call	0x9cc	; 0x9cc <getX>
     612:	68 2f       	mov	r22, r24
     614:	70 e0       	ldi	r23, 0x00	; 0
     616:	82 e0       	ldi	r24, 0x02	; 2
     618:	90 e0       	ldi	r25, 0x00	; 0
     61a:	0e 94 2d 0b 	call	0x165a	; 0x165a <power>
     61e:	8c 01       	movw	r16, r24
				c = power(2,getX(&ship2)+1);
     620:	83 ea       	ldi	r24, 0xA3	; 163
     622:	91 e0       	ldi	r25, 0x01	; 1
     624:	0e 94 e6 04 	call	0x9cc	; 0x9cc <getX>
     628:	68 2f       	mov	r22, r24
     62a:	70 e0       	ldi	r23, 0x00	; 0
     62c:	6f 5f       	subi	r22, 0xFF	; 255
     62e:	7f 4f       	sbci	r23, 0xFF	; 255
     630:	82 e0       	ldi	r24, 0x02	; 2
     632:	90 e0       	ldi	r25, 0x00	; 0
     634:	0e 94 2d 0b 	call	0x165a	; 0x165a <power>
     638:	ec 01       	movw	r28, r24
				
				frame_buf[getY(&ship2)] = a + b + c;
     63a:	83 ea       	ldi	r24, 0xA3	; 163
     63c:	91 e0       	ldi	r25, 0x01	; 1
     63e:	0e 94 e9 04 	call	0x9d2	; 0x9d2 <getY>
     642:	e8 2f       	mov	r30, r24
     644:	f0 e0       	ldi	r31, 0x00	; 0
     646:	ee 0f       	add	r30, r30
     648:	ff 1f       	adc	r31, r31
     64a:	e9 55       	subi	r30, 0x59	; 89
     64c:	fe 4f       	sbci	r31, 0xFE	; 254
     64e:	0e 0d       	add	r16, r14
     650:	1f 1d       	adc	r17, r15
     652:	c0 0f       	add	r28, r16
     654:	d1 1f       	adc	r29, r17
     656:	d1 83       	std	Z+1, r29	; 0x01
     658:	c0 83       	st	Z, r28
				frame_buf[getY(&ship2)-1] = power(2,getX(&ship2));
     65a:	83 ea       	ldi	r24, 0xA3	; 163
     65c:	91 e0       	ldi	r25, 0x01	; 1
     65e:	0e 94 e9 04 	call	0x9d2	; 0x9d2 <getY>
     662:	c8 2f       	mov	r28, r24
     664:	83 ea       	ldi	r24, 0xA3	; 163
     666:	91 e0       	ldi	r25, 0x01	; 1
     668:	0e 94 e6 04 	call	0x9cc	; 0x9cc <getX>
     66c:	68 2f       	mov	r22, r24
     66e:	70 e0       	ldi	r23, 0x00	; 0
     670:	82 e0       	ldi	r24, 0x02	; 2
     672:	90 e0       	ldi	r25, 0x00	; 0
     674:	0e 94 2d 0b 	call	0x165a	; 0x165a <power>
     678:	ec 2f       	mov	r30, r28
     67a:	f0 e0       	ldi	r31, 0x00	; 0
     67c:	ee 0f       	add	r30, r30
     67e:	ff 1f       	adc	r31, r31
     680:	eb 55       	subi	r30, 0x5B	; 91
     682:	fe 4f       	sbci	r31, 0xFE	; 254
     684:	91 83       	std	Z+1, r25	; 0x01
     686:	80 83       	st	Z, r24
				xSemaphoreGive(xFramebufMutex);
     688:	20 e0       	ldi	r18, 0x00	; 0
     68a:	40 e0       	ldi	r20, 0x00	; 0
     68c:	50 e0       	ldi	r21, 0x00	; 0
     68e:	60 e0       	ldi	r22, 0x00	; 0
     690:	70 e0       	ldi	r23, 0x00	; 0
     692:	80 91 5c 08 	lds	r24, 0x085C	; 0x80085c <xFramebufMutex>
     696:	90 91 5d 08 	lds	r25, 0x085D	; 0x80085d <xFramebufMutex+0x1>
     69a:	0e 94 c6 0c 	call	0x198c	; 0x198c <xQueueGenericSend>
     69e:	40 cf       	rjmp	.-384    	; 0x520 <draw_ships_task+0xc>

000006a0 <display_points>:
}


void display_points()
{
	clear_frame();
     6a0:	0e 94 80 02 	call	0x500	; 0x500 <clear_frame>
	if(results[1] < 3)
     6a4:	80 91 52 08 	lds	r24, 0x0852	; 0x800852 <results+0x1>
     6a8:	83 30       	cpi	r24, 0x03	; 3
     6aa:	08 f0       	brcs	.+2      	; 0x6ae <display_points+0xe>
     6ac:	6e c0       	rjmp	.+220    	; 0x78a <display_points+0xea>
	{
		if(results[0] == 0)
     6ae:	90 91 51 08 	lds	r25, 0x0851	; 0x800851 <results>
     6b2:	91 11       	cpse	r25, r1
     6b4:	11 c0       	rjmp	.+34     	; 0x6d8 <display_points+0x38>
		{
			frame_buf[1] = 56;
     6b6:	e7 ea       	ldi	r30, 0xA7	; 167
     6b8:	f1 e0       	ldi	r31, 0x01	; 1
     6ba:	48 e3       	ldi	r20, 0x38	; 56
     6bc:	50 e0       	ldi	r21, 0x00	; 0
     6be:	53 83       	std	Z+3, r21	; 0x03
     6c0:	42 83       	std	Z+2, r20	; 0x02
			frame_buf[2] = 40;
     6c2:	28 e2       	ldi	r18, 0x28	; 40
     6c4:	30 e0       	ldi	r19, 0x00	; 0
     6c6:	35 83       	std	Z+5, r19	; 0x05
     6c8:	24 83       	std	Z+4, r18	; 0x04
			frame_buf[3] = 40;
     6ca:	37 83       	std	Z+7, r19	; 0x07
     6cc:	26 83       	std	Z+6, r18	; 0x06
			frame_buf[4] = 40;
     6ce:	31 87       	std	Z+9, r19	; 0x09
     6d0:	20 87       	std	Z+8, r18	; 0x08
			frame_buf[5] = 56;
     6d2:	53 87       	std	Z+11, r21	; 0x0b
     6d4:	42 87       	std	Z+10, r20	; 0x0a
     6d6:	5e c0       	rjmp	.+188    	; 0x794 <display_points+0xf4>
			
		}
		else if(results[0] == 1)
     6d8:	91 30       	cpi	r25, 0x01	; 1
     6da:	99 f4       	brne	.+38     	; 0x702 <display_points+0x62>
		{
			frame_buf[1] = 56;
     6dc:	e7 ea       	ldi	r30, 0xA7	; 167
     6de:	f1 e0       	ldi	r31, 0x01	; 1
     6e0:	28 e3       	ldi	r18, 0x38	; 56
     6e2:	30 e0       	ldi	r19, 0x00	; 0
     6e4:	33 83       	std	Z+3, r19	; 0x03
     6e6:	22 83       	std	Z+2, r18	; 0x02
			frame_buf[2] = 16;
     6e8:	20 e1       	ldi	r18, 0x10	; 16
     6ea:	30 e0       	ldi	r19, 0x00	; 0
     6ec:	35 83       	std	Z+5, r19	; 0x05
     6ee:	24 83       	std	Z+4, r18	; 0x04
			frame_buf[3] = 16;
     6f0:	37 83       	std	Z+7, r19	; 0x07
     6f2:	26 83       	std	Z+6, r18	; 0x06
			frame_buf[4] = 24;
     6f4:	48 e1       	ldi	r20, 0x18	; 24
     6f6:	50 e0       	ldi	r21, 0x00	; 0
     6f8:	51 87       	std	Z+9, r21	; 0x09
     6fa:	40 87       	std	Z+8, r20	; 0x08
			frame_buf[5] = 16;
     6fc:	33 87       	std	Z+11, r19	; 0x0b
     6fe:	22 87       	std	Z+10, r18	; 0x0a
     700:	49 c0       	rjmp	.+146    	; 0x794 <display_points+0xf4>
		}
		else if(results[0] == 2)
     702:	92 30       	cpi	r25, 0x02	; 2
     704:	99 f4       	brne	.+38     	; 0x72c <display_points+0x8c>
		{
			frame_buf[1] = 56;
     706:	e7 ea       	ldi	r30, 0xA7	; 167
     708:	f1 e0       	ldi	r31, 0x01	; 1
     70a:	28 e3       	ldi	r18, 0x38	; 56
     70c:	30 e0       	ldi	r19, 0x00	; 0
     70e:	33 83       	std	Z+3, r19	; 0x03
     710:	22 83       	std	Z+2, r18	; 0x02
			frame_buf[2] = 8;
     712:	48 e0       	ldi	r20, 0x08	; 8
     714:	50 e0       	ldi	r21, 0x00	; 0
     716:	55 83       	std	Z+5, r21	; 0x05
     718:	44 83       	std	Z+4, r20	; 0x04
			frame_buf[3] = 56;
     71a:	37 83       	std	Z+7, r19	; 0x07
     71c:	26 83       	std	Z+6, r18	; 0x06
			frame_buf[4] = 32;
     71e:	40 e2       	ldi	r20, 0x20	; 32
     720:	50 e0       	ldi	r21, 0x00	; 0
     722:	51 87       	std	Z+9, r21	; 0x09
     724:	40 87       	std	Z+8, r20	; 0x08
			frame_buf[5] = 56;
     726:	33 87       	std	Z+11, r19	; 0x0b
     728:	22 87       	std	Z+10, r18	; 0x0a
     72a:	34 c0       	rjmp	.+104    	; 0x794 <display_points+0xf4>
		}
		else if (results[0] == 3)
     72c:	93 30       	cpi	r25, 0x03	; 3
     72e:	69 f5       	brne	.+90     	; 0x78a <display_points+0xea>
		{
			frame_buf[0] = 10;
     730:	e7 ea       	ldi	r30, 0xA7	; 167
     732:	f1 e0       	ldi	r31, 0x01	; 1
     734:	2a e0       	ldi	r18, 0x0A	; 10
     736:	30 e0       	ldi	r19, 0x00	; 0
     738:	31 83       	std	Z+1, r19	; 0x01
     73a:	20 83       	st	Z, r18
			frame_buf[1] = 10;
     73c:	33 83       	std	Z+3, r19	; 0x03
     73e:	22 83       	std	Z+2, r18	; 0x02
			frame_buf[2] = 910;
     740:	4e e8       	ldi	r20, 0x8E	; 142
     742:	53 e0       	ldi	r21, 0x03	; 3
     744:	55 83       	std	Z+5, r21	; 0x05
     746:	44 83       	std	Z+4, r20	; 0x04
			frame_buf[3] = 640;
     748:	80 e8       	ldi	r24, 0x80	; 128
     74a:	92 e0       	ldi	r25, 0x02	; 2
     74c:	97 83       	std	Z+7, r25	; 0x07
     74e:	86 83       	std	Z+6, r24	; 0x06
			frame_buf[4] = 654;
     750:	6e e8       	ldi	r22, 0x8E	; 142
     752:	72 e0       	ldi	r23, 0x02	; 2
     754:	71 87       	std	Z+9, r23	; 0x09
     756:	60 87       	std	Z+8, r22	; 0x08
			frame_buf[5] = 10;
     758:	33 87       	std	Z+11, r19	; 0x0b
     75a:	22 87       	std	Z+10, r18	; 0x0a
			frame_buf[6] = 910;
     75c:	55 87       	std	Z+13, r21	; 0x0d
     75e:	44 87       	std	Z+12, r20	; 0x0c
			frame_buf[7] = 640;
     760:	97 87       	std	Z+15, r25	; 0x0f
     762:	86 87       	std	Z+14, r24	; 0x0e
			frame_buf[8] = 896;
     764:	20 e8       	ldi	r18, 0x80	; 128
     766:	33 e0       	ldi	r19, 0x03	; 3
     768:	31 8b       	std	Z+17, r19	; 0x11
     76a:	20 8b       	std	Z+16, r18	; 0x10
			frame_buf[9] = 31;
     76c:	2f e1       	ldi	r18, 0x1F	; 31
     76e:	30 e0       	ldi	r19, 0x00	; 0
     770:	33 8b       	std	Z+19, r19	; 0x13
     772:	22 8b       	std	Z+18, r18	; 0x12
			frame_buf[10] = 277;
     774:	25 e1       	ldi	r18, 0x15	; 21
     776:	31 e0       	ldi	r19, 0x01	; 1
     778:	35 8b       	std	Z+21, r19	; 0x15
     77a:	24 8b       	std	Z+20, r18	; 0x14
			frame_buf[11] = 277;
     77c:	37 8b       	std	Z+23, r19	; 0x17
     77e:	26 8b       	std	Z+22, r18	; 0x16
			frame_buf[12] = 640;
     780:	91 8f       	std	Z+25, r25	; 0x19
     782:	80 8f       	std	Z+24, r24	; 0x18
			frame_buf[13] = 640;
     784:	93 8f       	std	Z+27, r25	; 0x1b
     786:	82 8f       	std	Z+26, r24	; 0x1a
     788:	08 95       	ret
		}
		}
		
		if(results[0] < 3)
     78a:	90 91 51 08 	lds	r25, 0x0851	; 0x800851 <results>
     78e:	93 30       	cpi	r25, 0x03	; 3
     790:	08 f0       	brcs	.+2      	; 0x794 <display_points+0xf4>
     792:	71 c0       	rjmp	.+226    	; 0x876 <display_points+0x1d6>
		{
			if(results[1] == 0)
     794:	81 11       	cpse	r24, r1
     796:	11 c0       	rjmp	.+34     	; 0x7ba <display_points+0x11a>
			{
				frame_buf[8] = 56;
     798:	e7 ea       	ldi	r30, 0xA7	; 167
     79a:	f1 e0       	ldi	r31, 0x01	; 1
     79c:	28 e3       	ldi	r18, 0x38	; 56
     79e:	30 e0       	ldi	r19, 0x00	; 0
     7a0:	31 8b       	std	Z+17, r19	; 0x11
     7a2:	20 8b       	std	Z+16, r18	; 0x10
				frame_buf[9] = 40;
     7a4:	88 e2       	ldi	r24, 0x28	; 40
     7a6:	90 e0       	ldi	r25, 0x00	; 0
     7a8:	93 8b       	std	Z+19, r25	; 0x13
     7aa:	82 8b       	std	Z+18, r24	; 0x12
				frame_buf[10] = 40;
     7ac:	95 8b       	std	Z+21, r25	; 0x15
     7ae:	84 8b       	std	Z+20, r24	; 0x14
				frame_buf[11] = 40;
     7b0:	97 8b       	std	Z+23, r25	; 0x17
     7b2:	86 8b       	std	Z+22, r24	; 0x16
				frame_buf[12] = 56;
     7b4:	31 8f       	std	Z+25, r19	; 0x19
     7b6:	20 8f       	std	Z+24, r18	; 0x18
     7b8:	08 95       	ret
			}
			else if(results[1] == 1)
     7ba:	81 30       	cpi	r24, 0x01	; 1
     7bc:	99 f4       	brne	.+38     	; 0x7e4 <display_points+0x144>
			{
				frame_buf[8] = 16;
     7be:	e7 ea       	ldi	r30, 0xA7	; 167
     7c0:	f1 e0       	ldi	r31, 0x01	; 1
     7c2:	80 e1       	ldi	r24, 0x10	; 16
     7c4:	90 e0       	ldi	r25, 0x00	; 0
     7c6:	91 8b       	std	Z+17, r25	; 0x11
     7c8:	80 8b       	std	Z+16, r24	; 0x10
				frame_buf[9] = 24;
     7ca:	28 e1       	ldi	r18, 0x18	; 24
     7cc:	30 e0       	ldi	r19, 0x00	; 0
     7ce:	33 8b       	std	Z+19, r19	; 0x13
     7d0:	22 8b       	std	Z+18, r18	; 0x12
				frame_buf[10] = 16;
     7d2:	95 8b       	std	Z+21, r25	; 0x15
     7d4:	84 8b       	std	Z+20, r24	; 0x14
				frame_buf[11] = 16;
     7d6:	97 8b       	std	Z+23, r25	; 0x17
     7d8:	86 8b       	std	Z+22, r24	; 0x16
				frame_buf[12] = 56;
     7da:	88 e3       	ldi	r24, 0x38	; 56
     7dc:	90 e0       	ldi	r25, 0x00	; 0
     7de:	91 8f       	std	Z+25, r25	; 0x19
     7e0:	80 8f       	std	Z+24, r24	; 0x18
     7e2:	08 95       	ret
			}
			else if(results[1] == 2)
     7e4:	82 30       	cpi	r24, 0x02	; 2
     7e6:	99 f4       	brne	.+38     	; 0x80e <display_points+0x16e>
			{
				frame_buf[8] = 56;
     7e8:	e7 ea       	ldi	r30, 0xA7	; 167
     7ea:	f1 e0       	ldi	r31, 0x01	; 1
     7ec:	88 e3       	ldi	r24, 0x38	; 56
     7ee:	90 e0       	ldi	r25, 0x00	; 0
     7f0:	91 8b       	std	Z+17, r25	; 0x11
     7f2:	80 8b       	std	Z+16, r24	; 0x10
				frame_buf[9] = 8;
     7f4:	28 e0       	ldi	r18, 0x08	; 8
     7f6:	30 e0       	ldi	r19, 0x00	; 0
     7f8:	33 8b       	std	Z+19, r19	; 0x13
     7fa:	22 8b       	std	Z+18, r18	; 0x12
				frame_buf[10] = 56;
     7fc:	95 8b       	std	Z+21, r25	; 0x15
     7fe:	84 8b       	std	Z+20, r24	; 0x14
				frame_buf[11] = 32;
     800:	20 e2       	ldi	r18, 0x20	; 32
     802:	30 e0       	ldi	r19, 0x00	; 0
     804:	37 8b       	std	Z+23, r19	; 0x17
     806:	26 8b       	std	Z+22, r18	; 0x16
				frame_buf[12] = 56;
     808:	91 8f       	std	Z+25, r25	; 0x19
     80a:	80 8f       	std	Z+24, r24	; 0x18
     80c:	08 95       	ret
			}
			else if (results[1] == 3)
     80e:	83 30       	cpi	r24, 0x03	; 3
     810:	91 f5       	brne	.+100    	; 0x876 <display_points+0x1d6>
			{
				frame_buf[0] = 21;
     812:	e7 ea       	ldi	r30, 0xA7	; 167
     814:	f1 e0       	ldi	r31, 0x01	; 1
     816:	85 e1       	ldi	r24, 0x15	; 21
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	91 83       	std	Z+1, r25	; 0x01
     81c:	80 83       	st	Z, r24
				frame_buf[1] = 21;
     81e:	93 83       	std	Z+3, r25	; 0x03
     820:	82 83       	std	Z+2, r24	; 0x02
				frame_buf[2] = 671;
     822:	8f e9       	ldi	r24, 0x9F	; 159
     824:	92 e0       	ldi	r25, 0x02	; 2
     826:	95 83       	std	Z+5, r25	; 0x05
     828:	84 83       	std	Z+4, r24	; 0x04
				frame_buf[3] = 640;
     82a:	80 e8       	ldi	r24, 0x80	; 128
     82c:	92 e0       	ldi	r25, 0x02	; 2
     82e:	97 83       	std	Z+7, r25	; 0x07
     830:	86 83       	std	Z+6, r24	; 0x06
				frame_buf[4] = 270;
     832:	2e e0       	ldi	r18, 0x0E	; 14
     834:	31 e0       	ldi	r19, 0x01	; 1
     836:	31 87       	std	Z+9, r19	; 0x09
     838:	20 87       	std	Z+8, r18	; 0x08
				frame_buf[5] = 266;
     83a:	2a e0       	ldi	r18, 0x0A	; 10
     83c:	31 e0       	ldi	r19, 0x01	; 1
     83e:	33 87       	std	Z+11, r19	; 0x0b
     840:	22 87       	std	Z+10, r18	; 0x0a
				frame_buf[6] = 14;
     842:	2e e0       	ldi	r18, 0x0E	; 14
     844:	30 e0       	ldi	r19, 0x00	; 0
     846:	35 87       	std	Z+13, r19	; 0x0d
     848:	24 87       	std	Z+12, r18	; 0x0c
				frame_buf[7] = 896;
     84a:	20 e8       	ldi	r18, 0x80	; 128
     84c:	33 e0       	ldi	r19, 0x03	; 3
     84e:	37 87       	std	Z+15, r19	; 0x0f
     850:	26 87       	std	Z+14, r18	; 0x0e
				frame_buf[8] = 654;
     852:	4e e8       	ldi	r20, 0x8E	; 142
     854:	52 e0       	ldi	r21, 0x02	; 2
     856:	51 8b       	std	Z+17, r21	; 0x11
     858:	40 8b       	std	Z+16, r20	; 0x10
				frame_buf[9] = 906;
     85a:	4a e8       	ldi	r20, 0x8A	; 138
     85c:	53 e0       	ldi	r21, 0x03	; 3
     85e:	53 8b       	std	Z+19, r21	; 0x13
     860:	42 8b       	std	Z+18, r20	; 0x12
				frame_buf[10] = 10;
     862:	4a e0       	ldi	r20, 0x0A	; 10
     864:	50 e0       	ldi	r21, 0x00	; 0
     866:	55 8b       	std	Z+21, r21	; 0x15
     868:	44 8b       	std	Z+20, r20	; 0x14
				frame_buf[11] = 640;
     86a:	97 8b       	std	Z+23, r25	; 0x17
     86c:	86 8b       	std	Z+22, r24	; 0x16
				frame_buf[12] = 640;
     86e:	91 8f       	std	Z+25, r25	; 0x19
     870:	80 8f       	std	Z+24, r24	; 0x18
				frame_buf[13] = 896;
     872:	33 8f       	std	Z+27, r19	; 0x1b
     874:	22 8f       	std	Z+26, r18	; 0x1a
     876:	08 95       	ret

00000878 <check_collisions_task>:
///////////TASKS START HERE///////////
static void check_collisions_task(void *pvParameters)
{
	(void)pvParameters;
	
	vTaskSetApplicationTaskTag( NULL, ( void * ) 1);
     878:	61 e0       	ldi	r22, 0x01	; 1
     87a:	70 e0       	ldi	r23, 0x00	; 0
     87c:	80 e0       	ldi	r24, 0x00	; 0
     87e:	90 e0       	ldi	r25, 0x00	; 0
     880:	0e 94 23 12 	call	0x2446	; 0x2446 <vTaskSetApplicationTaskTag>
 				xTimerStop(xTimerControllersAndDraw,10);
				init_variables();
				wait();
				xTimerStart(xTimerControllersAndDraw,0);
 				
				if(results[0] > 2 || results[1] > 2)
     884:	c1 e5       	ldi	r28, 0x51	; 81
     886:	d8 e0       	ldi	r29, 0x08	; 8
	
	uint8_t ship1shot = 0;
	uint8_t ship2shot = 0;
	while(1)
	{
		if(xSemaphoreTake(xTimerSemaphoreCollisions, portMAX_DELAY))
     888:	20 e0       	ldi	r18, 0x00	; 0
     88a:	4f ef       	ldi	r20, 0xFF	; 255
     88c:	5f ef       	ldi	r21, 0xFF	; 255
     88e:	60 e0       	ldi	r22, 0x00	; 0
     890:	70 e0       	ldi	r23, 0x00	; 0
     892:	80 91 55 08 	lds	r24, 0x0855	; 0x800855 <xTimerSemaphoreCollisions>
     896:	90 91 56 08 	lds	r25, 0x0856	; 0x800856 <xTimerSemaphoreCollisions+0x1>
     89a:	0e 94 dc 0d 	call	0x1bb8	; 0x1bb8 <xQueueGenericReceive>
     89e:	88 23       	and	r24, r24
     8a0:	99 f3       	breq	.-26     	; 0x888 <check_collisions_task+0x10>
		{

			//check for bullet - bullet collision
			if(((getX(&bullet1) == getX(&bullet2)) && (getY(&bullet1) == (getY(&bullet2) - 1))) || ((getX(&bullet1) == getX(&bullet2)) && (getY(&bullet1) == (getY(&bullet2)))))
     8a2:	8f e9       	ldi	r24, 0x9F	; 159
     8a4:	91 e0       	ldi	r25, 0x01	; 1
     8a6:	0e 94 e6 04 	call	0x9cc	; 0x9cc <getX>
     8aa:	18 2f       	mov	r17, r24
     8ac:	81 ea       	ldi	r24, 0xA1	; 161
     8ae:	91 e0       	ldi	r25, 0x01	; 1
     8b0:	0e 94 e6 04 	call	0x9cc	; 0x9cc <getX>
     8b4:	18 13       	cpse	r17, r24
     8b6:	10 c0       	rjmp	.+32     	; 0x8d8 <check_collisions_task+0x60>
     8b8:	8f e9       	ldi	r24, 0x9F	; 159
     8ba:	91 e0       	ldi	r25, 0x01	; 1
     8bc:	0e 94 e9 04 	call	0x9d2	; 0x9d2 <getY>
     8c0:	18 2f       	mov	r17, r24
     8c2:	81 ea       	ldi	r24, 0xA1	; 161
     8c4:	91 e0       	ldi	r25, 0x01	; 1
     8c6:	0e 94 e9 04 	call	0x9d2	; 0x9d2 <getY>
     8ca:	21 2f       	mov	r18, r17
     8cc:	30 e0       	ldi	r19, 0x00	; 0
     8ce:	90 e0       	ldi	r25, 0x00	; 0
     8d0:	01 97       	sbiw	r24, 0x01	; 1
     8d2:	28 17       	cp	r18, r24
     8d4:	39 07       	cpc	r19, r25
     8d6:	b1 f0       	breq	.+44     	; 0x904 <__stack+0x5>
     8d8:	8f e9       	ldi	r24, 0x9F	; 159
     8da:	91 e0       	ldi	r25, 0x01	; 1
     8dc:	0e 94 e6 04 	call	0x9cc	; 0x9cc <getX>
     8e0:	18 2f       	mov	r17, r24
     8e2:	81 ea       	ldi	r24, 0xA1	; 161
     8e4:	91 e0       	ldi	r25, 0x01	; 1
     8e6:	0e 94 e6 04 	call	0x9cc	; 0x9cc <getX>
     8ea:	18 13       	cpse	r17, r24
     8ec:	1a c0       	rjmp	.+52     	; 0x922 <__stack+0x23>
     8ee:	8f e9       	ldi	r24, 0x9F	; 159
     8f0:	91 e0       	ldi	r25, 0x01	; 1
     8f2:	0e 94 e9 04 	call	0x9d2	; 0x9d2 <getY>
     8f6:	18 2f       	mov	r17, r24
     8f8:	81 ea       	ldi	r24, 0xA1	; 161
     8fa:	91 e0       	ldi	r25, 0x01	; 1
     8fc:	0e 94 e9 04 	call	0x9d2	; 0x9d2 <getY>
     900:	18 13       	cpse	r17, r24
     902:	0f c0       	rjmp	.+30     	; 0x922 <__stack+0x23>
			{
				setY(&bullet1,20);
     904:	64 e1       	ldi	r22, 0x14	; 20
     906:	8f e9       	ldi	r24, 0x9F	; 159
     908:	91 e0       	ldi	r25, 0x01	; 1
     90a:	0e 94 ef 04 	call	0x9de	; 0x9de <setY>
				setY(&bullet2,0);
     90e:	60 e0       	ldi	r22, 0x00	; 0
     910:	81 ea       	ldi	r24, 0xA1	; 161
     912:	91 e0       	ldi	r25, 0x01	; 1
     914:	0e 94 ef 04 	call	0x9de	; 0x9de <setY>
				setX(&bullet2,20);
     918:	64 e1       	ldi	r22, 0x14	; 20
     91a:	81 ea       	ldi	r24, 0xA1	; 161
     91c:	91 e0       	ldi	r25, 0x01	; 1
     91e:	0e 94 ec 04 	call	0x9d8	; 0x9d8 <setX>

			}
			
			ship1shot = bullet_ship_collision(&bullet2,&ship1);
     922:	65 ea       	ldi	r22, 0xA5	; 165
     924:	71 e0       	ldi	r23, 0x01	; 1
     926:	81 ea       	ldi	r24, 0xA1	; 161
     928:	91 e0       	ldi	r25, 0x01	; 1
     92a:	0e 94 d9 0a 	call	0x15b2	; 0x15b2 <bullet_ship_collision>
     92e:	18 2f       	mov	r17, r24
			ship2shot = bullet_ship_collision(&bullet1,&ship2);
     930:	63 ea       	ldi	r22, 0xA3	; 163
     932:	71 e0       	ldi	r23, 0x01	; 1
     934:	8f e9       	ldi	r24, 0x9F	; 159
     936:	91 e0       	ldi	r25, 0x01	; 1
     938:	0e 94 d9 0a 	call	0x15b2	; 0x15b2 <bullet_ship_collision>
			

			if(ship1shot || ship2shot)
     93c:	11 11       	cpse	r17, r1
     93e:	03 c0       	rjmp	.+6      	; 0x946 <__stack+0x47>
     940:	81 11       	cpse	r24, r1
     942:	0d c0       	rjmp	.+26     	; 0x95e <__stack+0x5f>
     944:	a1 cf       	rjmp	.-190    	; 0x888 <check_collisions_task+0x10>
			{
				if(ship1shot && !ship2shot)
     946:	81 11       	cpse	r24, r1
     948:	14 c0       	rjmp	.+40     	; 0x972 <__stack+0x73>
				{
					results[1]++;
     94a:	89 81       	ldd	r24, Y+1	; 0x01
     94c:	8f 5f       	subi	r24, 0xFF	; 255
     94e:	89 83       	std	Y+1, r24	; 0x01
					display_points();
     950:	0e 94 50 03 	call	0x6a0	; 0x6a0 <display_points>
					com_send_bytes((uint8_t *)results, 2); //change it so it's showing the score
     954:	62 e0       	ldi	r22, 0x02	; 2
     956:	ce 01       	movw	r24, r28
     958:	0e 94 69 05 	call	0xad2	; 0xad2 <com_send_bytes>
     95c:	0e c0       	rjmp	.+28     	; 0x97a <__stack+0x7b>
								
				}
				else if(ship2shot && !ship1shot)
				{
					results[0]++;
     95e:	88 81       	ld	r24, Y
     960:	8f 5f       	subi	r24, 0xFF	; 255
     962:	88 83       	st	Y, r24
					display_points();
     964:	0e 94 50 03 	call	0x6a0	; 0x6a0 <display_points>
					com_send_bytes((uint8_t *)results, 2); //change it so it's showing the score
     968:	62 e0       	ldi	r22, 0x02	; 2
     96a:	ce 01       	movw	r24, r28
     96c:	0e 94 69 05 	call	0xad2	; 0xad2 <com_send_bytes>
     970:	04 c0       	rjmp	.+8      	; 0x97a <__stack+0x7b>

				}
				else 
				{
					com_send_bytes((uint8_t *)results, 2);
     972:	62 e0       	ldi	r22, 0x02	; 2
     974:	ce 01       	movw	r24, r28
     976:	0e 94 69 05 	call	0xad2	; 0xad2 <com_send_bytes>
				}
				

 				xTimerStop(xTimerControllersAndDraw,10);
     97a:	0a e0       	ldi	r16, 0x0A	; 10
     97c:	10 e0       	ldi	r17, 0x00	; 0
     97e:	20 e0       	ldi	r18, 0x00	; 0
     980:	30 e0       	ldi	r19, 0x00	; 0
     982:	40 e0       	ldi	r20, 0x00	; 0
     984:	50 e0       	ldi	r21, 0x00	; 0
     986:	63 e0       	ldi	r22, 0x03	; 3
     988:	80 91 53 08 	lds	r24, 0x0853	; 0x800853 <xTimerControllersAndDraw>
     98c:	90 91 54 08 	lds	r25, 0x0854	; 0x800854 <xTimerControllersAndDraw+0x1>
     990:	0e 94 cf 14 	call	0x299e	; 0x299e <xTimerGenericCommand>
				init_variables();
     994:	0e 94 f5 01 	call	0x3ea	; 0x3ea <init_variables>
				wait();
     998:	0e 94 cd 0a 	call	0x159a	; 0x159a <wait>
				xTimerStart(xTimerControllersAndDraw,0);
     99c:	0e 94 8c 10 	call	0x2118	; 0x2118 <xTaskGetTickCount>
     9a0:	00 e0       	ldi	r16, 0x00	; 0
     9a2:	10 e0       	ldi	r17, 0x00	; 0
     9a4:	20 e0       	ldi	r18, 0x00	; 0
     9a6:	30 e0       	ldi	r19, 0x00	; 0
     9a8:	ac 01       	movw	r20, r24
     9aa:	61 e0       	ldi	r22, 0x01	; 1
     9ac:	80 91 53 08 	lds	r24, 0x0853	; 0x800853 <xTimerControllersAndDraw>
     9b0:	90 91 54 08 	lds	r25, 0x0854	; 0x800854 <xTimerControllersAndDraw+0x1>
     9b4:	0e 94 cf 14 	call	0x299e	; 0x299e <xTimerGenericCommand>
 				
				if(results[0] > 2 || results[1] > 2)
     9b8:	88 81       	ld	r24, Y
     9ba:	83 30       	cpi	r24, 0x03	; 3
     9bc:	20 f4       	brcc	.+8      	; 0x9c6 <__stack+0xc7>
     9be:	89 81       	ldd	r24, Y+1	; 0x01
     9c0:	83 30       	cpi	r24, 0x03	; 3
     9c2:	08 f4       	brcc	.+2      	; 0x9c6 <__stack+0xc7>
     9c4:	61 cf       	rjmp	.-318    	; 0x888 <check_collisions_task+0x10>
 				{
 					vTaskSuspendAll();
     9c6:	0e 94 86 10 	call	0x210c	; 0x210c <vTaskSuspendAll>
     9ca:	5e cf       	rjmp	.-324    	; 0x888 <check_collisions_task+0x10>

000009cc <getX>:
}

uint8_t getX(struct point *self)
{
		return self->x;
}
     9cc:	fc 01       	movw	r30, r24
     9ce:	80 81       	ld	r24, Z
     9d0:	08 95       	ret

000009d2 <getY>:

uint8_t getY(struct point *self)
{
		return self->y;
}
     9d2:	fc 01       	movw	r30, r24
     9d4:	81 81       	ldd	r24, Z+1	; 0x01
     9d6:	08 95       	ret

000009d8 <setX>:

void setX(struct point *self, uint8_t x)
{
		self->x = x;
     9d8:	fc 01       	movw	r30, r24
     9da:	60 83       	st	Z, r22
     9dc:	08 95       	ret

000009de <setY>:
}

void setY(struct point *self, uint8_t y)
{
		self->y = y;
     9de:	fc 01       	movw	r30, r24
     9e0:	61 83       	std	Z+1, r22	; 0x01
     9e2:	08 95       	ret

000009e4 <prepare_shiftregister>:
#include "RTOS_utils.h"

void prepare_shiftregister()
{
	// Set SER to 1
	PORTD |= _BV(PORTD2);
     9e4:	5a 9a       	sbi	0x0b, 2	; 11
     9e6:	08 95       	ret

000009e8 <clock_shift_register_and_prepare_for_next_col>:

// clock shift-register
void clock_shift_register_and_prepare_for_next_col()
{
	// one SCK pulse
	PORTD |= _BV(PORTD5);
     9e8:	5d 9a       	sbi	0x0b, 5	; 11
	PORTD &= ~_BV(PORTD5);
     9ea:	5d 98       	cbi	0x0b, 5	; 11
	
	// one RCK pulse
	PORTD |= _BV(PORTD4);
     9ec:	5c 9a       	sbi	0x0b, 4	; 11
	PORTD &= ~_BV(PORTD4);
     9ee:	5c 98       	cbi	0x0b, 4	; 11
	
	// Set SER to 0 - for next column
	PORTD &= ~_BV(PORTD2);
     9f0:	5a 98       	cbi	0x0b, 2	; 11
     9f2:	08 95       	ret

000009f4 <load_col_value>:
}

// Load column value for column to show
void load_col_value(uint16_t col_value)
{
	PORTA = ~(col_value & 0xFF);
     9f4:	80 95       	com	r24
     9f6:	82 b9       	out	0x02, r24	; 2
	
	// Manipulate only with PB0 and PB1
	PORTB |= 0x03;
     9f8:	85 b1       	in	r24, 0x05	; 5
     9fa:	83 60       	ori	r24, 0x03	; 3
     9fc:	85 b9       	out	0x05, r24	; 5
	PORTB &= ~((col_value >> 8) & 0x03);
     9fe:	85 b1       	in	r24, 0x05	; 5
     a00:	93 70       	andi	r25, 0x03	; 3
     a02:	90 95       	com	r25
     a04:	89 23       	and	r24, r25
     a06:	85 b9       	out	0x05, r24	; 5
     a08:	08 95       	ret

00000a0a <vApplicationIdleHook>:
}

//-----------------------------------------
void vApplicationIdleHook( void )
{
     a0a:	08 95       	ret

00000a0c <joystick_func>:

//method used to calculate the power of number with base, and power - p

int joystick_func()
{
	uint16_t output = PINC;
     a0c:	86 b1       	in	r24, 0x06	; 6
	uint16_t mask = 0b11000011;
	return output & mask; // | is supposed to be used for "OR"
     a0e:	83 7c       	andi	r24, 0xC3	; 195
}
     a10:	90 e0       	ldi	r25, 0x00	; 0
     a12:	08 95       	ret

00000a14 <_com_call_back>:

// Pointer to application display handler
static display_callback_ptr_t cb_ptr = NULL;

// ----------------------------------------------------------------------------------------------------------------------
static void _com_call_back(serial_p _com_serial_instance, uint8_t serial_last_received_byte) {
     a14:	cf 93       	push	r28
     a16:	df 93       	push	r29
     a18:	00 d0       	rcall	.+0      	; 0xa1a <_com_call_back+0x6>
     a1a:	cd b7       	in	r28, 0x3d	; 61
     a1c:	de b7       	in	r29, 0x3e	; 62
     a1e:	6a 83       	std	Y+2, r22	; 0x02
	if (_x_rx_com_queue) {
     a20:	80 91 0b 02 	lds	r24, 0x020B	; 0x80020b <_x_rx_com_queue>
     a24:	90 91 0c 02 	lds	r25, 0x020C	; 0x80020c <_x_rx_com_queue+0x1>
     a28:	00 97       	sbiw	r24, 0x00	; 0
     a2a:	71 f0       	breq	.+28     	; 0xa48 <_com_call_back+0x34>
		signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
     a2c:	19 82       	std	Y+1, r1	; 0x01

		xQueueSendFromISR( _x_rx_com_queue, &serial_last_received_byte, &xHigherPriorityTaskWoken );
     a2e:	20 e0       	ldi	r18, 0x00	; 0
     a30:	ae 01       	movw	r20, r28
     a32:	4f 5f       	subi	r20, 0xFF	; 255
     a34:	5f 4f       	sbci	r21, 0xFF	; 255
     a36:	be 01       	movw	r22, r28
     a38:	6e 5f       	subi	r22, 0xFE	; 254
     a3a:	7f 4f       	sbci	r23, 0xFF	; 255
     a3c:	0e 94 8f 0d 	call	0x1b1e	; 0x1b1e <xQueueGenericSendFromISR>

		if( xHigherPriorityTaskWoken != pdFALSE )
     a40:	89 81       	ldd	r24, Y+1	; 0x01
     a42:	81 11       	cpse	r24, r1
		{
			taskYIELD();
     a44:	0e 94 3e 07 	call	0xe7c	; 0xe7c <vPortYield>
		}
	}
}
     a48:	0f 90       	pop	r0
     a4a:	0f 90       	pop	r0
     a4c:	df 91       	pop	r29
     a4e:	cf 91       	pop	r28
     a50:	08 95       	ret

00000a52 <init_com>:

// ----------------------------------------------------------------------------------------------------------------------
void init_com(QueueHandle_t x_rx_queue) {
	_x_rx_com_queue = x_rx_queue;
     a52:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <_x_rx_com_queue+0x1>
     a56:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <_x_rx_com_queue>
     a5a:	08 95       	ret

00000a5c <init_display_timer>:
}

// ----------------------------------------------------------------------------------------------------------------------
void init_display_timer(display_callback_ptr_t cb)
{
	cb_ptr = cb;
     a5c:	90 93 0a 02 	sts	0x020A, r25	; 0x80020a <cb_ptr+0x1>
     a60:	80 93 09 02 	sts	0x0209, r24	; 0x800209 <cb_ptr>
	
	// Setup timer T0 to CTC, ~1309 Hz
	OCR0A = 10;
     a64:	8a e0       	ldi	r24, 0x0A	; 10
     a66:	87 bd       	out	0x27, r24	; 39
	TCCR0A |= _BV(WGM01); // Mode 2
     a68:	84 b5       	in	r24, 0x24	; 36
     a6a:	82 60       	ori	r24, 0x02	; 2
     a6c:	84 bd       	out	0x24, r24	; 36
	TIMSK0 |= _BV(OCIE0A); // Enable interrupt
     a6e:	ee e6       	ldi	r30, 0x6E	; 110
     a70:	f0 e0       	ldi	r31, 0x00	; 0
     a72:	80 81       	ld	r24, Z
     a74:	82 60       	ori	r24, 0x02	; 2
     a76:	80 83       	st	Z, r24
	TCCR0B |= _BV(CS00) | _BV(CS02); // Prescaler 1024 - and start timer
     a78:	85 b5       	in	r24, 0x25	; 37
     a7a:	85 60       	ori	r24, 0x05	; 5
     a7c:	85 bd       	out	0x25, r24	; 37
     a7e:	08 95       	ret

00000a80 <__vector_16>:
}

// ----------------------------------------------------------------------------------------------------------------------
//ISR for display timer
ISR(TIMER0_COMPA_vect)
{
     a80:	1f 92       	push	r1
     a82:	0f 92       	push	r0
     a84:	0f b6       	in	r0, 0x3f	; 63
     a86:	0f 92       	push	r0
     a88:	11 24       	eor	r1, r1
     a8a:	2f 93       	push	r18
     a8c:	3f 93       	push	r19
     a8e:	4f 93       	push	r20
     a90:	5f 93       	push	r21
     a92:	6f 93       	push	r22
     a94:	7f 93       	push	r23
     a96:	8f 93       	push	r24
     a98:	9f 93       	push	r25
     a9a:	af 93       	push	r26
     a9c:	bf 93       	push	r27
     a9e:	ef 93       	push	r30
     aa0:	ff 93       	push	r31
	if (cb_ptr)
     aa2:	e0 91 09 02 	lds	r30, 0x0209	; 0x800209 <cb_ptr>
     aa6:	f0 91 0a 02 	lds	r31, 0x020A	; 0x80020a <cb_ptr+0x1>
     aaa:	30 97       	sbiw	r30, 0x00	; 0
     aac:	09 f0       	breq	.+2      	; 0xab0 <__vector_16+0x30>
	{
		cb_ptr();
     aae:	09 95       	icall
	}
}
     ab0:	ff 91       	pop	r31
     ab2:	ef 91       	pop	r30
     ab4:	bf 91       	pop	r27
     ab6:	af 91       	pop	r26
     ab8:	9f 91       	pop	r25
     aba:	8f 91       	pop	r24
     abc:	7f 91       	pop	r23
     abe:	6f 91       	pop	r22
     ac0:	5f 91       	pop	r21
     ac2:	4f 91       	pop	r20
     ac4:	3f 91       	pop	r19
     ac6:	2f 91       	pop	r18
     ac8:	0f 90       	pop	r0
     aca:	0f be       	out	0x3f, r0	; 63
     acc:	0f 90       	pop	r0
     ace:	1f 90       	pop	r1
     ad0:	18 95       	reti

00000ad2 <com_send_bytes>:

// ----------------------------------------------------------------------------------------------------------------------
void com_send_bytes(uint8_t *bytes, uint8_t len) {
     ad2:	46 2f       	mov	r20, r22
	serial_send_bytes(_com_serial_instance, bytes, len);
     ad4:	bc 01       	movw	r22, r24
     ad6:	80 91 0d 02 	lds	r24, 0x020D	; 0x80020d <_com_serial_instance>
     ada:	90 91 0e 02 	lds	r25, 0x020E	; 0x80020e <_com_serial_instance+0x1>
     ade:	0e 94 a6 08 	call	0x114c	; 0x114c <serial_send_bytes>
     ae2:	08 95       	ret

00000ae4 <init_board>:
}

// ----------------------------------------------------------------------------------------------------------------------
void init_board(void) {
     ae4:	8f 92       	push	r8
     ae6:	9f 92       	push	r9
     ae8:	af 92       	push	r10
     aea:	bf 92       	push	r11
     aec:	cf 92       	push	r12
     aee:	df 92       	push	r13
     af0:	ef 92       	push	r14
     af2:	0f 93       	push	r16
	static buffer_struct_t _com_rx_buffer;
	static buffer_struct_t _com_tx_buffer;
	buffer_init(&_com_rx_buffer);
     af4:	86 ee       	ldi	r24, 0xE6	; 230
     af6:	91 e0       	ldi	r25, 0x01	; 1
     af8:	0e 94 cb 05 	call	0xb96	; 0xb96 <buffer_init>
	buffer_init(&_com_tx_buffer);
     afc:	83 ec       	ldi	r24, 0xC3	; 195
     afe:	91 e0       	ldi	r25, 0x01	; 1
     b00:	0e 94 cb 05 	call	0xb96	; 0xb96 <buffer_init>
	_com_serial_instance = serial_new_instance(ser_USART0, 115200UL, ser_BITS_8, ser_STOP_1, ser_NO_PARITY, &_com_rx_buffer, &_com_tx_buffer, _com_call_back);
     b04:	0f 2e       	mov	r0, r31
     b06:	fa e0       	ldi	r31, 0x0A	; 10
     b08:	8f 2e       	mov	r8, r31
     b0a:	f5 e0       	ldi	r31, 0x05	; 5
     b0c:	9f 2e       	mov	r9, r31
     b0e:	f0 2d       	mov	r31, r0
     b10:	0f 2e       	mov	r0, r31
     b12:	f3 ec       	ldi	r31, 0xC3	; 195
     b14:	af 2e       	mov	r10, r31
     b16:	f1 e0       	ldi	r31, 0x01	; 1
     b18:	bf 2e       	mov	r11, r31
     b1a:	f0 2d       	mov	r31, r0
     b1c:	0f 2e       	mov	r0, r31
     b1e:	f6 ee       	ldi	r31, 0xE6	; 230
     b20:	cf 2e       	mov	r12, r31
     b22:	f1 e0       	ldi	r31, 0x01	; 1
     b24:	df 2e       	mov	r13, r31
     b26:	f0 2d       	mov	r31, r0
     b28:	e1 2c       	mov	r14, r1
     b2a:	00 e0       	ldi	r16, 0x00	; 0
     b2c:	23 e0       	ldi	r18, 0x03	; 3
     b2e:	40 e0       	ldi	r20, 0x00	; 0
     b30:	52 ec       	ldi	r21, 0xC2	; 194
     b32:	61 e0       	ldi	r22, 0x01	; 1
     b34:	70 e0       	ldi	r23, 0x00	; 0
     b36:	80 e0       	ldi	r24, 0x00	; 0
     b38:	0e 94 2c 08 	call	0x1058	; 0x1058 <serial_new_instance>
     b3c:	90 93 0e 02 	sts	0x020E, r25	; 0x80020e <_com_serial_instance+0x1>
     b40:	80 93 0d 02 	sts	0x020D, r24	; 0x80020d <_com_serial_instance>
	
	// Pull up on Joystick inputs
	PORTC |= _BV(PORTC0) | _BV(PORTC1) | _BV(PORTC6) | _BV(PORTC7);
     b44:	88 b1       	in	r24, 0x08	; 8
     b46:	83 6c       	ori	r24, 0xC3	; 195
     b48:	88 b9       	out	0x08, r24	; 8
	PORTD |= _BV(PORTD3);
     b4a:	5b 9a       	sbi	0x0b, 3	; 11
	
	// Shift register control pins to output
	// SER, RCK, SCK, G (enable output)
	DDRD |= _BV(DDD2) | _BV(DDD4) | _BV(DDD5) | _BV(DDD6);
     b4c:	8a b1       	in	r24, 0x0a	; 10
     b4e:	84 67       	ori	r24, 0x74	; 116
     b50:	8a b9       	out	0x0a, r24	; 10
	// G (enable output) high
	PORTD |= _BV(PORTD6);
     b52:	5e 9a       	sbi	0x0b, 6	; 11
	
	// Column pins to output
	DDRA |= 0xFF;
     b54:	81 b1       	in	r24, 0x01	; 1
     b56:	8f ef       	ldi	r24, 0xFF	; 255
     b58:	81 b9       	out	0x01, r24	; 1
	DDRB |= _BV(DDB0) | _BV(DDB1);
     b5a:	84 b1       	in	r24, 0x04	; 4
     b5c:	83 60       	ori	r24, 0x03	; 3
     b5e:	84 b9       	out	0x04, r24	; 4
	
	// Trace pins Task Monitor (R2R)
	DDRB |= _BV(DDB2) | _BV(DDB3) | _BV(DDB4) | _BV(DDB5);
     b60:	84 b1       	in	r24, 0x04	; 4
     b62:	8c 63       	ori	r24, 0x3C	; 60
     b64:	84 b9       	out	0x04, r24	; 4
}
     b66:	0f 91       	pop	r16
     b68:	ef 90       	pop	r14
     b6a:	df 90       	pop	r13
     b6c:	cf 90       	pop	r12
     b6e:	bf 90       	pop	r11
     b70:	af 90       	pop	r10
     b72:	9f 90       	pop	r9
     b74:	8f 90       	pop	r8
     b76:	08 95       	ret

00000b78 <switch_in>:
	
	 Called by the the traceTASK_SWITCHED_IN() macro in FreeRTOS.
	 Are enabled in FreeRTOSConfig.h
	 **********************************************************************/
	void switch_in(uint8_t task_no) {
		PORTB &= 0b11000011;
     b78:	95 b1       	in	r25, 0x05	; 5
     b7a:	93 7c       	andi	r25, 0xC3	; 195
     b7c:	95 b9       	out	0x05, r25	; 5
		PORTB |= task_no << 2;
     b7e:	25 b1       	in	r18, 0x05	; 5
     b80:	34 e0       	ldi	r19, 0x04	; 4
     b82:	83 9f       	mul	r24, r19
     b84:	c0 01       	movw	r24, r0
     b86:	11 24       	eor	r1, r1
     b88:	82 2b       	or	r24, r18
     b8a:	85 b9       	out	0x05, r24	; 5
     b8c:	08 95       	ret

00000b8e <switch_out>:
	
	 Called by the the traceTASK_SWITCHED_OUT() macro in FreeRTOS.
	 Are enabled in FreeRTOSConfig.h
	 **********************************************************************/
	void switch_out(uint8_t task_no) {
		PORTB &= 0b11000011;
     b8e:	85 b1       	in	r24, 0x05	; 5
     b90:	83 7c       	andi	r24, 0xC3	; 195
     b92:	85 b9       	out	0x05, r24	; 5
     b94:	08 95       	ret

00000b96 <buffer_init>:
  @endcode

 @note The buffer structure must be initialized before any of the buffer functions must be called.
 @param *buffer Pointer to the buffer structure to be used.
 ***********************************************/
void buffer_init(buffer_struct_t *buffer) {
     b96:	fc 01       	movw	r30, r24
	buffer->in_i = 0;
     b98:	10 a2       	std	Z+32, r1	; 0x20
	buffer->out_i = 0;
     b9a:	11 a2       	std	Z+33, r1	; 0x21
	buffer->no_in_buffer = 0;
     b9c:	12 a2       	std	Z+34, r1	; 0x22
     b9e:	08 95       	ret

00000ba0 <buffer_get_item>:
 @return BUFFER_OK: item removed from buffer and returned in item.\n
    BUFFER_EMPTY: The buffer is empty, item is not updated.
 @param *buffer pointer to the buffer structure.
 @param *item pointer to the variable where the value of the item is returned.
 ***********************************************/
uint8_t buffer_get_item(buffer_struct_t *buffer, uint8_t *item) {
     ba0:	fc 01       	movw	r30, r24
	if (buffer->no_in_buffer > 0) {
     ba2:	82 a1       	ldd	r24, Z+34	; 0x22
     ba4:	88 23       	and	r24, r24
     ba6:	d9 f0       	breq	.+54     	; 0xbde <buffer_get_item+0x3e>
		*item = buffer->storage[buffer->out_i];
     ba8:	81 a1       	ldd	r24, Z+33	; 0x21
     baa:	df 01       	movw	r26, r30
     bac:	a8 0f       	add	r26, r24
     bae:	b1 1d       	adc	r27, r1
     bb0:	8c 91       	ld	r24, X
     bb2:	db 01       	movw	r26, r22
     bb4:	8c 93       	st	X, r24
		buffer->out_i = INCREMENT(buffer->out_i);
     bb6:	21 a1       	ldd	r18, Z+33	; 0x21
     bb8:	30 e0       	ldi	r19, 0x00	; 0
     bba:	2f 5f       	subi	r18, 0xFF	; 255
     bbc:	3f 4f       	sbci	r19, 0xFF	; 255
     bbe:	2f 71       	andi	r18, 0x1F	; 31
     bc0:	30 78       	andi	r19, 0x80	; 128
     bc2:	33 23       	and	r19, r19
     bc4:	34 f4       	brge	.+12     	; 0xbd2 <buffer_get_item+0x32>
     bc6:	21 50       	subi	r18, 0x01	; 1
     bc8:	31 09       	sbc	r19, r1
     bca:	20 6e       	ori	r18, 0xE0	; 224
     bcc:	3f 6f       	ori	r19, 0xFF	; 255
     bce:	2f 5f       	subi	r18, 0xFF	; 255
     bd0:	3f 4f       	sbci	r19, 0xFF	; 255
     bd2:	21 a3       	std	Z+33, r18	; 0x21
		buffer->no_in_buffer--;
     bd4:	82 a1       	ldd	r24, Z+34	; 0x22
     bd6:	81 50       	subi	r24, 0x01	; 1
     bd8:	82 a3       	std	Z+34, r24	; 0x22
		return BUFFER_OK;
     bda:	80 e0       	ldi	r24, 0x00	; 0
     bdc:	08 95       	ret
	}
	return BUFFER_EMPTY;
     bde:	81 e0       	ldi	r24, 0x01	; 1
}
     be0:	08 95       	ret

00000be2 <buffer_put_item>:
    BUFFER_FULL: The buffer is full, item is not stored.
 @param *buffer pointer to the buffer structure.
 @param item to be stored in the buffer.
 ***********************************************/
uint8_t buffer_put_item(buffer_struct_t *buffer, uint8_t item) {
	if (buffer->no_in_buffer<BUFFER_SIZE) {
     be2:	fc 01       	movw	r30, r24
     be4:	42 a1       	ldd	r20, Z+34	; 0x22
     be6:	40 32       	cpi	r20, 0x20	; 32
     be8:	b8 f4       	brcc	.+46     	; 0xc18 <buffer_put_item+0x36>
		buffer->storage[buffer->in_i] = item;
     bea:	20 a1       	ldd	r18, Z+32	; 0x20
     bec:	30 e0       	ldi	r19, 0x00	; 0
     bee:	e2 0f       	add	r30, r18
     bf0:	f3 1f       	adc	r31, r19
     bf2:	60 83       	st	Z, r22
		buffer->in_i = INCREMENT(buffer->in_i);
     bf4:	2f 5f       	subi	r18, 0xFF	; 255
     bf6:	3f 4f       	sbci	r19, 0xFF	; 255
     bf8:	2f 71       	andi	r18, 0x1F	; 31
     bfa:	30 78       	andi	r19, 0x80	; 128
     bfc:	33 23       	and	r19, r19
     bfe:	34 f4       	brge	.+12     	; 0xc0c <buffer_put_item+0x2a>
     c00:	21 50       	subi	r18, 0x01	; 1
     c02:	31 09       	sbc	r19, r1
     c04:	20 6e       	ori	r18, 0xE0	; 224
     c06:	3f 6f       	ori	r19, 0xFF	; 255
     c08:	2f 5f       	subi	r18, 0xFF	; 255
     c0a:	3f 4f       	sbci	r19, 0xFF	; 255
     c0c:	fc 01       	movw	r30, r24
     c0e:	20 a3       	std	Z+32, r18	; 0x20
		buffer->no_in_buffer++;
     c10:	4f 5f       	subi	r20, 0xFF	; 255
     c12:	42 a3       	std	Z+34, r20	; 0x22
		return BUFFER_OK;
     c14:	80 e0       	ldi	r24, 0x00	; 0
     c16:	08 95       	ret
	}
	return BUFFER_FULL;
     c18:	82 e0       	ldi	r24, 0x02	; 2
}
     c1a:	08 95       	ret

00000c1c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     c1c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     c1e:	03 96       	adiw	r24, 0x03	; 3
     c20:	92 83       	std	Z+2, r25	; 0x02
     c22:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     c24:	2f ef       	ldi	r18, 0xFF	; 255
     c26:	3f ef       	ldi	r19, 0xFF	; 255
     c28:	34 83       	std	Z+4, r19	; 0x04
     c2a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     c2c:	96 83       	std	Z+6, r25	; 0x06
     c2e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     c30:	90 87       	std	Z+8, r25	; 0x08
     c32:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     c34:	10 82       	st	Z, r1
     c36:	08 95       	ret

00000c38 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     c38:	fc 01       	movw	r30, r24
     c3a:	11 86       	std	Z+9, r1	; 0x09
     c3c:	10 86       	std	Z+8, r1	; 0x08
     c3e:	08 95       	ret

00000c40 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     c40:	cf 93       	push	r28
     c42:	df 93       	push	r29
     c44:	9c 01       	movw	r18, r24
     c46:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     c48:	dc 01       	movw	r26, r24
     c4a:	11 96       	adiw	r26, 0x01	; 1
     c4c:	cd 91       	ld	r28, X+
     c4e:	dc 91       	ld	r29, X
     c50:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     c52:	d3 83       	std	Z+3, r29	; 0x03
     c54:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     c56:	8c 81       	ldd	r24, Y+4	; 0x04
     c58:	9d 81       	ldd	r25, Y+5	; 0x05
     c5a:	95 83       	std	Z+5, r25	; 0x05
     c5c:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     c5e:	8c 81       	ldd	r24, Y+4	; 0x04
     c60:	9d 81       	ldd	r25, Y+5	; 0x05
     c62:	dc 01       	movw	r26, r24
     c64:	13 96       	adiw	r26, 0x03	; 3
     c66:	7c 93       	st	X, r23
     c68:	6e 93       	st	-X, r22
     c6a:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     c6c:	7d 83       	std	Y+5, r23	; 0x05
     c6e:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     c70:	31 87       	std	Z+9, r19	; 0x09
     c72:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     c74:	f9 01       	movw	r30, r18
     c76:	80 81       	ld	r24, Z
     c78:	8f 5f       	subi	r24, 0xFF	; 255
     c7a:	80 83       	st	Z, r24
}
     c7c:	df 91       	pop	r29
     c7e:	cf 91       	pop	r28
     c80:	08 95       	ret

00000c82 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     c82:	cf 93       	push	r28
     c84:	df 93       	push	r29
     c86:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     c88:	48 81       	ld	r20, Y
     c8a:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     c8c:	4f 3f       	cpi	r20, 0xFF	; 255
     c8e:	2f ef       	ldi	r18, 0xFF	; 255
     c90:	52 07       	cpc	r21, r18
     c92:	21 f4       	brne	.+8      	; 0xc9c <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     c94:	fc 01       	movw	r30, r24
     c96:	a7 81       	ldd	r26, Z+7	; 0x07
     c98:	b0 85       	ldd	r27, Z+8	; 0x08
     c9a:	0d c0       	rjmp	.+26     	; 0xcb6 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     c9c:	dc 01       	movw	r26, r24
     c9e:	13 96       	adiw	r26, 0x03	; 3
     ca0:	01 c0       	rjmp	.+2      	; 0xca4 <vListInsert+0x22>
     ca2:	df 01       	movw	r26, r30
     ca4:	12 96       	adiw	r26, 0x02	; 2
     ca6:	ed 91       	ld	r30, X+
     ca8:	fc 91       	ld	r31, X
     caa:	13 97       	sbiw	r26, 0x03	; 3
     cac:	20 81       	ld	r18, Z
     cae:	31 81       	ldd	r19, Z+1	; 0x01
     cb0:	42 17       	cp	r20, r18
     cb2:	53 07       	cpc	r21, r19
     cb4:	b0 f7       	brcc	.-20     	; 0xca2 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     cb6:	12 96       	adiw	r26, 0x02	; 2
     cb8:	ed 91       	ld	r30, X+
     cba:	fc 91       	ld	r31, X
     cbc:	13 97       	sbiw	r26, 0x03	; 3
     cbe:	fb 83       	std	Y+3, r31	; 0x03
     cc0:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     cc2:	d5 83       	std	Z+5, r29	; 0x05
     cc4:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     cc6:	bd 83       	std	Y+5, r27	; 0x05
     cc8:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     cca:	13 96       	adiw	r26, 0x03	; 3
     ccc:	dc 93       	st	X, r29
     cce:	ce 93       	st	-X, r28
     cd0:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     cd2:	99 87       	std	Y+9, r25	; 0x09
     cd4:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     cd6:	fc 01       	movw	r30, r24
     cd8:	20 81       	ld	r18, Z
     cda:	2f 5f       	subi	r18, 0xFF	; 255
     cdc:	20 83       	st	Z, r18
}
     cde:	df 91       	pop	r29
     ce0:	cf 91       	pop	r28
     ce2:	08 95       	ret

00000ce4 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     ce4:	cf 93       	push	r28
     ce6:	df 93       	push	r29
     ce8:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     cea:	a0 85       	ldd	r26, Z+8	; 0x08
     cec:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     cee:	c2 81       	ldd	r28, Z+2	; 0x02
     cf0:	d3 81       	ldd	r29, Z+3	; 0x03
     cf2:	84 81       	ldd	r24, Z+4	; 0x04
     cf4:	95 81       	ldd	r25, Z+5	; 0x05
     cf6:	9d 83       	std	Y+5, r25	; 0x05
     cf8:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     cfa:	c4 81       	ldd	r28, Z+4	; 0x04
     cfc:	d5 81       	ldd	r29, Z+5	; 0x05
     cfe:	82 81       	ldd	r24, Z+2	; 0x02
     d00:	93 81       	ldd	r25, Z+3	; 0x03
     d02:	9b 83       	std	Y+3, r25	; 0x03
     d04:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     d06:	11 96       	adiw	r26, 0x01	; 1
     d08:	8d 91       	ld	r24, X+
     d0a:	9c 91       	ld	r25, X
     d0c:	12 97       	sbiw	r26, 0x02	; 2
     d0e:	e8 17       	cp	r30, r24
     d10:	f9 07       	cpc	r31, r25
     d12:	31 f4       	brne	.+12     	; 0xd20 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     d14:	84 81       	ldd	r24, Z+4	; 0x04
     d16:	95 81       	ldd	r25, Z+5	; 0x05
     d18:	12 96       	adiw	r26, 0x02	; 2
     d1a:	9c 93       	st	X, r25
     d1c:	8e 93       	st	-X, r24
     d1e:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     d20:	11 86       	std	Z+9, r1	; 0x09
     d22:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     d24:	8c 91       	ld	r24, X
     d26:	81 50       	subi	r24, 0x01	; 1
     d28:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     d2a:	df 91       	pop	r29
     d2c:	cf 91       	pop	r28
     d2e:	08 95       	ret

00000d30 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     d30:	31 e1       	ldi	r19, 0x11	; 17
     d32:	fc 01       	movw	r30, r24
     d34:	30 83       	st	Z, r19
     d36:	31 97       	sbiw	r30, 0x01	; 1
     d38:	22 e2       	ldi	r18, 0x22	; 34
     d3a:	20 83       	st	Z, r18
     d3c:	31 97       	sbiw	r30, 0x01	; 1
     d3e:	a3 e3       	ldi	r26, 0x33	; 51
     d40:	a0 83       	st	Z, r26
     d42:	31 97       	sbiw	r30, 0x01	; 1
     d44:	60 83       	st	Z, r22
     d46:	31 97       	sbiw	r30, 0x01	; 1
     d48:	70 83       	st	Z, r23
     d4a:	31 97       	sbiw	r30, 0x01	; 1
     d4c:	10 82       	st	Z, r1
     d4e:	31 97       	sbiw	r30, 0x01	; 1
     d50:	60 e8       	ldi	r22, 0x80	; 128
     d52:	60 83       	st	Z, r22
     d54:	31 97       	sbiw	r30, 0x01	; 1
     d56:	10 82       	st	Z, r1
     d58:	31 97       	sbiw	r30, 0x01	; 1
     d5a:	62 e0       	ldi	r22, 0x02	; 2
     d5c:	60 83       	st	Z, r22
     d5e:	31 97       	sbiw	r30, 0x01	; 1
     d60:	63 e0       	ldi	r22, 0x03	; 3
     d62:	60 83       	st	Z, r22
     d64:	31 97       	sbiw	r30, 0x01	; 1
     d66:	64 e0       	ldi	r22, 0x04	; 4
     d68:	60 83       	st	Z, r22
     d6a:	31 97       	sbiw	r30, 0x01	; 1
     d6c:	65 e0       	ldi	r22, 0x05	; 5
     d6e:	60 83       	st	Z, r22
     d70:	31 97       	sbiw	r30, 0x01	; 1
     d72:	66 e0       	ldi	r22, 0x06	; 6
     d74:	60 83       	st	Z, r22
     d76:	31 97       	sbiw	r30, 0x01	; 1
     d78:	67 e0       	ldi	r22, 0x07	; 7
     d7a:	60 83       	st	Z, r22
     d7c:	31 97       	sbiw	r30, 0x01	; 1
     d7e:	68 e0       	ldi	r22, 0x08	; 8
     d80:	60 83       	st	Z, r22
     d82:	31 97       	sbiw	r30, 0x01	; 1
     d84:	69 e0       	ldi	r22, 0x09	; 9
     d86:	60 83       	st	Z, r22
     d88:	31 97       	sbiw	r30, 0x01	; 1
     d8a:	60 e1       	ldi	r22, 0x10	; 16
     d8c:	60 83       	st	Z, r22
     d8e:	31 97       	sbiw	r30, 0x01	; 1
     d90:	30 83       	st	Z, r19
     d92:	31 97       	sbiw	r30, 0x01	; 1
     d94:	32 e1       	ldi	r19, 0x12	; 18
     d96:	30 83       	st	Z, r19
     d98:	31 97       	sbiw	r30, 0x01	; 1
     d9a:	33 e1       	ldi	r19, 0x13	; 19
     d9c:	30 83       	st	Z, r19
     d9e:	31 97       	sbiw	r30, 0x01	; 1
     da0:	34 e1       	ldi	r19, 0x14	; 20
     da2:	30 83       	st	Z, r19
     da4:	31 97       	sbiw	r30, 0x01	; 1
     da6:	35 e1       	ldi	r19, 0x15	; 21
     da8:	30 83       	st	Z, r19
     daa:	31 97       	sbiw	r30, 0x01	; 1
     dac:	36 e1       	ldi	r19, 0x16	; 22
     dae:	30 83       	st	Z, r19
     db0:	31 97       	sbiw	r30, 0x01	; 1
     db2:	37 e1       	ldi	r19, 0x17	; 23
     db4:	30 83       	st	Z, r19
     db6:	31 97       	sbiw	r30, 0x01	; 1
     db8:	38 e1       	ldi	r19, 0x18	; 24
     dba:	30 83       	st	Z, r19
     dbc:	31 97       	sbiw	r30, 0x01	; 1
     dbe:	39 e1       	ldi	r19, 0x19	; 25
     dc0:	30 83       	st	Z, r19
     dc2:	31 97       	sbiw	r30, 0x01	; 1
     dc4:	30 e2       	ldi	r19, 0x20	; 32
     dc6:	30 83       	st	Z, r19
     dc8:	31 97       	sbiw	r30, 0x01	; 1
     dca:	31 e2       	ldi	r19, 0x21	; 33
     dcc:	30 83       	st	Z, r19
     dce:	31 97       	sbiw	r30, 0x01	; 1
     dd0:	20 83       	st	Z, r18
     dd2:	31 97       	sbiw	r30, 0x01	; 1
     dd4:	23 e2       	ldi	r18, 0x23	; 35
     dd6:	20 83       	st	Z, r18
     dd8:	31 97       	sbiw	r30, 0x01	; 1
     dda:	40 83       	st	Z, r20
     ddc:	31 97       	sbiw	r30, 0x01	; 1
     dde:	50 83       	st	Z, r21
     de0:	31 97       	sbiw	r30, 0x01	; 1
     de2:	26 e2       	ldi	r18, 0x26	; 38
     de4:	20 83       	st	Z, r18
     de6:	31 97       	sbiw	r30, 0x01	; 1
     de8:	27 e2       	ldi	r18, 0x27	; 39
     dea:	20 83       	st	Z, r18
     dec:	31 97       	sbiw	r30, 0x01	; 1
     dee:	28 e2       	ldi	r18, 0x28	; 40
     df0:	20 83       	st	Z, r18
     df2:	31 97       	sbiw	r30, 0x01	; 1
     df4:	29 e2       	ldi	r18, 0x29	; 41
     df6:	20 83       	st	Z, r18
     df8:	31 97       	sbiw	r30, 0x01	; 1
     dfa:	20 e3       	ldi	r18, 0x30	; 48
     dfc:	20 83       	st	Z, r18
     dfe:	31 97       	sbiw	r30, 0x01	; 1
     e00:	21 e3       	ldi	r18, 0x31	; 49
     e02:	20 83       	st	Z, r18
     e04:	86 97       	sbiw	r24, 0x26	; 38
     e06:	08 95       	ret

00000e08 <xPortStartScheduler>:
     e08:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     e0c:	85 ee       	ldi	r24, 0xE5	; 229
     e0e:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
     e12:	8b e0       	ldi	r24, 0x0B	; 11
     e14:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
     e18:	ef e6       	ldi	r30, 0x6F	; 111
     e1a:	f0 e0       	ldi	r31, 0x00	; 0
     e1c:	80 81       	ld	r24, Z
     e1e:	82 60       	ori	r24, 0x02	; 2
     e20:	80 83       	st	Z, r24
     e22:	a0 91 29 08 	lds	r26, 0x0829	; 0x800829 <pxCurrentTCB>
     e26:	b0 91 2a 08 	lds	r27, 0x082A	; 0x80082a <pxCurrentTCB+0x1>
     e2a:	cd 91       	ld	r28, X+
     e2c:	cd bf       	out	0x3d, r28	; 61
     e2e:	dd 91       	ld	r29, X+
     e30:	de bf       	out	0x3e, r29	; 62
     e32:	ff 91       	pop	r31
     e34:	ef 91       	pop	r30
     e36:	df 91       	pop	r29
     e38:	cf 91       	pop	r28
     e3a:	bf 91       	pop	r27
     e3c:	af 91       	pop	r26
     e3e:	9f 91       	pop	r25
     e40:	8f 91       	pop	r24
     e42:	7f 91       	pop	r23
     e44:	6f 91       	pop	r22
     e46:	5f 91       	pop	r21
     e48:	4f 91       	pop	r20
     e4a:	3f 91       	pop	r19
     e4c:	2f 91       	pop	r18
     e4e:	1f 91       	pop	r17
     e50:	0f 91       	pop	r16
     e52:	ff 90       	pop	r15
     e54:	ef 90       	pop	r14
     e56:	df 90       	pop	r13
     e58:	cf 90       	pop	r12
     e5a:	bf 90       	pop	r11
     e5c:	af 90       	pop	r10
     e5e:	9f 90       	pop	r9
     e60:	8f 90       	pop	r8
     e62:	7f 90       	pop	r7
     e64:	6f 90       	pop	r6
     e66:	5f 90       	pop	r5
     e68:	4f 90       	pop	r4
     e6a:	3f 90       	pop	r3
     e6c:	2f 90       	pop	r2
     e6e:	1f 90       	pop	r1
     e70:	0f 90       	pop	r0
     e72:	0f be       	out	0x3f, r0	; 63
     e74:	0f 90       	pop	r0
     e76:	08 95       	ret
     e78:	81 e0       	ldi	r24, 0x01	; 1
     e7a:	08 95       	ret

00000e7c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     e7c:	0f 92       	push	r0
     e7e:	0f b6       	in	r0, 0x3f	; 63
     e80:	f8 94       	cli
     e82:	0f 92       	push	r0
     e84:	1f 92       	push	r1
     e86:	11 24       	eor	r1, r1
     e88:	2f 92       	push	r2
     e8a:	3f 92       	push	r3
     e8c:	4f 92       	push	r4
     e8e:	5f 92       	push	r5
     e90:	6f 92       	push	r6
     e92:	7f 92       	push	r7
     e94:	8f 92       	push	r8
     e96:	9f 92       	push	r9
     e98:	af 92       	push	r10
     e9a:	bf 92       	push	r11
     e9c:	cf 92       	push	r12
     e9e:	df 92       	push	r13
     ea0:	ef 92       	push	r14
     ea2:	ff 92       	push	r15
     ea4:	0f 93       	push	r16
     ea6:	1f 93       	push	r17
     ea8:	2f 93       	push	r18
     eaa:	3f 93       	push	r19
     eac:	4f 93       	push	r20
     eae:	5f 93       	push	r21
     eb0:	6f 93       	push	r22
     eb2:	7f 93       	push	r23
     eb4:	8f 93       	push	r24
     eb6:	9f 93       	push	r25
     eb8:	af 93       	push	r26
     eba:	bf 93       	push	r27
     ebc:	cf 93       	push	r28
     ebe:	df 93       	push	r29
     ec0:	ef 93       	push	r30
     ec2:	ff 93       	push	r31
     ec4:	a0 91 29 08 	lds	r26, 0x0829	; 0x800829 <pxCurrentTCB>
     ec8:	b0 91 2a 08 	lds	r27, 0x082A	; 0x80082a <pxCurrentTCB+0x1>
     ecc:	0d b6       	in	r0, 0x3d	; 61
     ece:	0d 92       	st	X+, r0
     ed0:	0e b6       	in	r0, 0x3e	; 62
     ed2:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     ed4:	0e 94 32 12 	call	0x2464	; 0x2464 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     ed8:	a0 91 29 08 	lds	r26, 0x0829	; 0x800829 <pxCurrentTCB>
     edc:	b0 91 2a 08 	lds	r27, 0x082A	; 0x80082a <pxCurrentTCB+0x1>
     ee0:	cd 91       	ld	r28, X+
     ee2:	cd bf       	out	0x3d, r28	; 61
     ee4:	dd 91       	ld	r29, X+
     ee6:	de bf       	out	0x3e, r29	; 62
     ee8:	ff 91       	pop	r31
     eea:	ef 91       	pop	r30
     eec:	df 91       	pop	r29
     eee:	cf 91       	pop	r28
     ef0:	bf 91       	pop	r27
     ef2:	af 91       	pop	r26
     ef4:	9f 91       	pop	r25
     ef6:	8f 91       	pop	r24
     ef8:	7f 91       	pop	r23
     efa:	6f 91       	pop	r22
     efc:	5f 91       	pop	r21
     efe:	4f 91       	pop	r20
     f00:	3f 91       	pop	r19
     f02:	2f 91       	pop	r18
     f04:	1f 91       	pop	r17
     f06:	0f 91       	pop	r16
     f08:	ff 90       	pop	r15
     f0a:	ef 90       	pop	r14
     f0c:	df 90       	pop	r13
     f0e:	cf 90       	pop	r12
     f10:	bf 90       	pop	r11
     f12:	af 90       	pop	r10
     f14:	9f 90       	pop	r9
     f16:	8f 90       	pop	r8
     f18:	7f 90       	pop	r7
     f1a:	6f 90       	pop	r6
     f1c:	5f 90       	pop	r5
     f1e:	4f 90       	pop	r4
     f20:	3f 90       	pop	r3
     f22:	2f 90       	pop	r2
     f24:	1f 90       	pop	r1
     f26:	0f 90       	pop	r0
     f28:	0f be       	out	0x3f, r0	; 63
     f2a:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f2c:	08 95       	ret

00000f2e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     f2e:	0f 92       	push	r0
     f30:	0f b6       	in	r0, 0x3f	; 63
     f32:	f8 94       	cli
     f34:	0f 92       	push	r0
     f36:	1f 92       	push	r1
     f38:	11 24       	eor	r1, r1
     f3a:	2f 92       	push	r2
     f3c:	3f 92       	push	r3
     f3e:	4f 92       	push	r4
     f40:	5f 92       	push	r5
     f42:	6f 92       	push	r6
     f44:	7f 92       	push	r7
     f46:	8f 92       	push	r8
     f48:	9f 92       	push	r9
     f4a:	af 92       	push	r10
     f4c:	bf 92       	push	r11
     f4e:	cf 92       	push	r12
     f50:	df 92       	push	r13
     f52:	ef 92       	push	r14
     f54:	ff 92       	push	r15
     f56:	0f 93       	push	r16
     f58:	1f 93       	push	r17
     f5a:	2f 93       	push	r18
     f5c:	3f 93       	push	r19
     f5e:	4f 93       	push	r20
     f60:	5f 93       	push	r21
     f62:	6f 93       	push	r22
     f64:	7f 93       	push	r23
     f66:	8f 93       	push	r24
     f68:	9f 93       	push	r25
     f6a:	af 93       	push	r26
     f6c:	bf 93       	push	r27
     f6e:	cf 93       	push	r28
     f70:	df 93       	push	r29
     f72:	ef 93       	push	r30
     f74:	ff 93       	push	r31
     f76:	a0 91 29 08 	lds	r26, 0x0829	; 0x800829 <pxCurrentTCB>
     f7a:	b0 91 2a 08 	lds	r27, 0x082A	; 0x80082a <pxCurrentTCB+0x1>
     f7e:	0d b6       	in	r0, 0x3d	; 61
     f80:	0d 92       	st	X+, r0
     f82:	0e b6       	in	r0, 0x3e	; 62
     f84:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     f86:	0e 94 96 10 	call	0x212c	; 0x212c <xTaskIncrementTick>
     f8a:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     f8c:	0e 94 32 12 	call	0x2464	; 0x2464 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     f90:	a0 91 29 08 	lds	r26, 0x0829	; 0x800829 <pxCurrentTCB>
     f94:	b0 91 2a 08 	lds	r27, 0x082A	; 0x80082a <pxCurrentTCB+0x1>
     f98:	cd 91       	ld	r28, X+
     f9a:	cd bf       	out	0x3d, r28	; 61
     f9c:	dd 91       	ld	r29, X+
     f9e:	de bf       	out	0x3e, r29	; 62
     fa0:	ff 91       	pop	r31
     fa2:	ef 91       	pop	r30
     fa4:	df 91       	pop	r29
     fa6:	cf 91       	pop	r28
     fa8:	bf 91       	pop	r27
     faa:	af 91       	pop	r26
     fac:	9f 91       	pop	r25
     fae:	8f 91       	pop	r24
     fb0:	7f 91       	pop	r23
     fb2:	6f 91       	pop	r22
     fb4:	5f 91       	pop	r21
     fb6:	4f 91       	pop	r20
     fb8:	3f 91       	pop	r19
     fba:	2f 91       	pop	r18
     fbc:	1f 91       	pop	r17
     fbe:	0f 91       	pop	r16
     fc0:	ff 90       	pop	r15
     fc2:	ef 90       	pop	r14
     fc4:	df 90       	pop	r13
     fc6:	cf 90       	pop	r12
     fc8:	bf 90       	pop	r11
     fca:	af 90       	pop	r10
     fcc:	9f 90       	pop	r9
     fce:	8f 90       	pop	r8
     fd0:	7f 90       	pop	r7
     fd2:	6f 90       	pop	r6
     fd4:	5f 90       	pop	r5
     fd6:	4f 90       	pop	r4
     fd8:	3f 90       	pop	r3
     fda:	2f 90       	pop	r2
     fdc:	1f 90       	pop	r1
     fde:	0f 90       	pop	r0
     fe0:	0f be       	out	0x3f, r0	; 63
     fe2:	0f 90       	pop	r0

	asm volatile ( "ret" );
     fe4:	08 95       	ret

00000fe6 <__vector_13>:
	 */
// 	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
// 	void SIG_OUTPUT_COMPARE1A( void )
ISR(TIMER1_COMPA_vect, ISR_NAKED)  // IHA
	{
		vPortYieldFromTick();
     fe6:	0e 94 97 07 	call	0xf2e	; 0xf2e <vPortYieldFromTick>
		asm volatile ( "reti" );
     fea:	18 95       	reti

00000fec <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     fec:	cf 93       	push	r28
     fee:	df 93       	push	r29
     ff0:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     ff2:	0e 94 86 10 	call	0x210c	; 0x210c <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     ff6:	80 91 0f 02 	lds	r24, 0x020F	; 0x80020f <pucAlignedHeap.2085>
     ffa:	90 91 10 02 	lds	r25, 0x0210	; 0x800210 <pucAlignedHeap.2085+0x1>
     ffe:	89 2b       	or	r24, r25
    1000:	31 f4       	brne	.+12     	; 0x100e <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1002:	84 e1       	ldi	r24, 0x14	; 20
    1004:	92 e0       	ldi	r25, 0x02	; 2
    1006:	90 93 10 02 	sts	0x0210, r25	; 0x800210 <pucAlignedHeap.2085+0x1>
    100a:	80 93 0f 02 	sts	0x020F, r24	; 0x80020f <pucAlignedHeap.2085>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    100e:	20 91 11 02 	lds	r18, 0x0211	; 0x800211 <xNextFreeByte>
    1012:	30 91 12 02 	lds	r19, 0x0212	; 0x800212 <xNextFreeByte+0x1>
    1016:	c9 01       	movw	r24, r18
    1018:	8c 0f       	add	r24, r28
    101a:	9d 1f       	adc	r25, r29
    101c:	87 37       	cpi	r24, 0x77	; 119
    101e:	45 e0       	ldi	r20, 0x05	; 5
    1020:	94 07       	cpc	r25, r20
    1022:	70 f4       	brcc	.+28     	; 0x1040 <pvPortMalloc+0x54>
    1024:	28 17       	cp	r18, r24
    1026:	39 07       	cpc	r19, r25
    1028:	70 f4       	brcc	.+28     	; 0x1046 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    102a:	c0 91 0f 02 	lds	r28, 0x020F	; 0x80020f <pucAlignedHeap.2085>
    102e:	d0 91 10 02 	lds	r29, 0x0210	; 0x800210 <pucAlignedHeap.2085+0x1>
    1032:	c2 0f       	add	r28, r18
    1034:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    1036:	90 93 12 02 	sts	0x0212, r25	; 0x800212 <xNextFreeByte+0x1>
    103a:	80 93 11 02 	sts	0x0211, r24	; 0x800211 <xNextFreeByte>
    103e:	05 c0       	rjmp	.+10     	; 0x104a <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    1040:	c0 e0       	ldi	r28, 0x00	; 0
    1042:	d0 e0       	ldi	r29, 0x00	; 0
    1044:	02 c0       	rjmp	.+4      	; 0x104a <pvPortMalloc+0x5e>
    1046:	c0 e0       	ldi	r28, 0x00	; 0
    1048:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    104a:	0e 94 51 11 	call	0x22a2	; 0x22a2 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    104e:	ce 01       	movw	r24, r28
    1050:	df 91       	pop	r29
    1052:	cf 91       	pop	r28
    1054:	08 95       	ret

00001056 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1056:	08 95       	ret

00001058 <serial_new_instance>:
			_serial_tx_int_on(handle->ser_UDR);
			return BUFFER_OK;
		}
	}
	return BUFFER_FULL;
}
    1058:	4f 92       	push	r4
    105a:	5f 92       	push	r5
    105c:	6f 92       	push	r6
    105e:	7f 92       	push	r7
    1060:	8f 92       	push	r8
    1062:	9f 92       	push	r9
    1064:	af 92       	push	r10
    1066:	bf 92       	push	r11
    1068:	cf 92       	push	r12
    106a:	df 92       	push	r13
    106c:	ff 92       	push	r15
    106e:	0f 93       	push	r16
    1070:	1f 93       	push	r17
    1072:	cf 93       	push	r28
    1074:	df 93       	push	r29
    1076:	cd b7       	in	r28, 0x3d	; 61
    1078:	de b7       	in	r29, 0x3e	; 62
    107a:	f8 2e       	mov	r15, r24
    107c:	2a 01       	movw	r4, r20
    107e:	3b 01       	movw	r6, r22
    1080:	88 e0       	ldi	r24, 0x08	; 8
    1082:	90 e0       	ldi	r25, 0x00	; 0
    1084:	0e 94 9f 16 	call	0x2d3e	; 0x2d3e <malloc>
    1088:	8c 01       	movw	r16, r24
    108a:	8f 2d       	mov	r24, r15
    108c:	90 e0       	ldi	r25, 0x00	; 0
    108e:	88 0f       	add	r24, r24
    1090:	99 1f       	adc	r25, r25
    1092:	fc 01       	movw	r30, r24
    1094:	e5 57       	subi	r30, 0x75	; 117
    1096:	f8 4f       	sbci	r31, 0xF8	; 248
    1098:	11 83       	std	Z+1, r17	; 0x01
    109a:	00 83       	st	Z, r16
    109c:	fc 01       	movw	r30, r24
    109e:	ea 5f       	subi	r30, 0xFA	; 250
    10a0:	fe 4f       	sbci	r31, 0xFE	; 254
    10a2:	80 81       	ld	r24, Z
    10a4:	91 81       	ldd	r25, Z+1	; 0x01
    10a6:	d8 01       	movw	r26, r16
    10a8:	11 96       	adiw	r26, 0x01	; 1
    10aa:	9c 93       	st	X, r25
    10ac:	8e 93       	st	-X, r24
    10ae:	13 96       	adiw	r26, 0x03	; 3
    10b0:	bc 92       	st	X, r11
    10b2:	ae 92       	st	-X, r10
    10b4:	12 97       	sbiw	r26, 0x02	; 2
    10b6:	15 96       	adiw	r26, 0x05	; 5
    10b8:	dc 92       	st	X, r13
    10ba:	ce 92       	st	-X, r12
    10bc:	14 97       	sbiw	r26, 0x04	; 4
    10be:	17 96       	adiw	r26, 0x07	; 7
    10c0:	9c 92       	st	X, r9
    10c2:	8e 92       	st	-X, r8
    10c4:	16 97       	sbiw	r26, 0x06	; 6
    10c6:	ff b6       	in	r15, 0x3f	; 63
    10c8:	f8 94       	cli
    10ca:	ed 91       	ld	r30, X+
    10cc:	fc 91       	ld	r31, X
    10ce:	11 97       	sbiw	r26, 0x01	; 1
    10d0:	36 97       	sbiw	r30, 0x06	; 6
    10d2:	80 81       	ld	r24, Z
    10d4:	82 60       	ori	r24, 0x02	; 2
    10d6:	80 83       	st	Z, r24
    10d8:	cd 90       	ld	r12, X+
    10da:	dc 90       	ld	r13, X
    10dc:	d3 01       	movw	r26, r6
    10de:	c2 01       	movw	r24, r4
    10e0:	88 0f       	add	r24, r24
    10e2:	99 1f       	adc	r25, r25
    10e4:	aa 1f       	adc	r26, r26
    10e6:	bb 1f       	adc	r27, r27
    10e8:	88 0f       	add	r24, r24
    10ea:	99 1f       	adc	r25, r25
    10ec:	aa 1f       	adc	r26, r26
    10ee:	bb 1f       	adc	r27, r27
    10f0:	9c 01       	movw	r18, r24
    10f2:	ad 01       	movw	r20, r26
    10f4:	22 0f       	add	r18, r18
    10f6:	33 1f       	adc	r19, r19
    10f8:	44 1f       	adc	r20, r20
    10fa:	55 1f       	adc	r21, r21
    10fc:	60 e0       	ldi	r22, 0x00	; 0
    10fe:	70 e0       	ldi	r23, 0x00	; 0
    1100:	81 ee       	ldi	r24, 0xE1	; 225
    1102:	90 e0       	ldi	r25, 0x00	; 0
    1104:	0e 94 77 16 	call	0x2cee	; 0x2cee <__udivmodsi4>
    1108:	21 50       	subi	r18, 0x01	; 1
    110a:	f6 01       	movw	r30, r12
    110c:	32 97       	sbiw	r30, 0x02	; 2
    110e:	20 83       	st	Z, r18
    1110:	d8 01       	movw	r26, r16
    1112:	ed 91       	ld	r30, X+
    1114:	fc 91       	ld	r31, X
    1116:	11 97       	sbiw	r26, 0x01	; 1
    1118:	35 97       	sbiw	r30, 0x05	; 5
    111a:	88 e9       	ldi	r24, 0x98	; 152
    111c:	80 83       	st	Z, r24
    111e:	ed 91       	ld	r30, X+
    1120:	fc 91       	ld	r31, X
    1122:	34 97       	sbiw	r30, 0x04	; 4
    1124:	86 e0       	ldi	r24, 0x06	; 6
    1126:	80 83       	st	Z, r24
    1128:	ff be       	out	0x3f, r15	; 63
    112a:	c8 01       	movw	r24, r16
    112c:	df 91       	pop	r29
    112e:	cf 91       	pop	r28
    1130:	1f 91       	pop	r17
    1132:	0f 91       	pop	r16
    1134:	ff 90       	pop	r15
    1136:	df 90       	pop	r13
    1138:	cf 90       	pop	r12
    113a:	bf 90       	pop	r11
    113c:	af 90       	pop	r10
    113e:	9f 90       	pop	r9
    1140:	8f 90       	pop	r8
    1142:	7f 90       	pop	r7
    1144:	6f 90       	pop	r6
    1146:	5f 90       	pop	r5
    1148:	4f 90       	pop	r4
    114a:	08 95       	ret

0000114c <serial_send_bytes>:

/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
    114c:	ef 92       	push	r14
    114e:	ff 92       	push	r15
    1150:	0f 93       	push	r16
    1152:	1f 93       	push	r17
    1154:	cf 93       	push	r28
    1156:	df 93       	push	r29
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
    1158:	fc 01       	movw	r30, r24
    115a:	a2 81       	ldd	r26, Z+2	; 0x02
    115c:	b3 81       	ldd	r27, Z+3	; 0x03
    115e:	10 97       	sbiw	r26, 0x00	; 0
    1160:	79 f0       	breq	.+30     	; 0x1180 <serial_send_bytes+0x34>
    1162:	e4 2f       	mov	r30, r20
    1164:	f0 e0       	ldi	r31, 0x00	; 0
    1166:	92 96       	adiw	r26, 0x22	; 34
    1168:	5c 91       	ld	r21, X
    116a:	20 e2       	ldi	r18, 0x20	; 32
    116c:	30 e0       	ldi	r19, 0x00	; 0
    116e:	25 1b       	sub	r18, r21
    1170:	31 09       	sbc	r19, r1
    1172:	2e 17       	cp	r18, r30
    1174:	3f 07       	cpc	r19, r31
    1176:	1c f1       	brlt	.+70     	; 0x11be <serial_send_bytes+0x72>
    1178:	7c 01       	movw	r14, r24
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
    117a:	41 11       	cpse	r20, r1
    117c:	04 c0       	rjmp	.+8      	; 0x1186 <serial_send_bytes+0x3a>
    117e:	16 c0       	rjmp	.+44     	; 0x11ac <serial_send_bytes+0x60>

/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
    1180:	42 30       	cpi	r20, 0x02	; 2
    1182:	f8 f4       	brcc	.+62     	; 0x11c2 <serial_send_bytes+0x76>
    1184:	f9 cf       	rjmp	.-14     	; 0x1178 <serial_send_bytes+0x2c>
    1186:	eb 01       	movw	r28, r22
    1188:	41 50       	subi	r20, 0x01	; 1
    118a:	04 2f       	mov	r16, r20
    118c:	10 e0       	ldi	r17, 0x00	; 0
    118e:	0f 5f       	subi	r16, 0xFF	; 255
    1190:	1f 4f       	sbci	r17, 0xFF	; 255
    1192:	06 0f       	add	r16, r22
    1194:	17 1f       	adc	r17, r23
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
    1196:	69 91       	ld	r22, Y+
    1198:	d7 01       	movw	r26, r14
    119a:	12 96       	adiw	r26, 0x02	; 2
    119c:	8d 91       	ld	r24, X+
    119e:	9c 91       	ld	r25, X
    11a0:	13 97       	sbiw	r26, 0x03	; 3
    11a2:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <buffer_put_item>
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
		return BUFFER_FULL;
	}
	
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
    11a6:	c0 17       	cp	r28, r16
    11a8:	d1 07       	cpc	r29, r17
    11aa:	a9 f7       	brne	.-22     	; 0x1196 <serial_send_bytes+0x4a>
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
    11ac:	d7 01       	movw	r26, r14
    11ae:	ed 91       	ld	r30, X+
    11b0:	fc 91       	ld	r31, X
SREG = _sreg;


/*-----------------------------------------------------------*/
static void _serial_tx_int_on(volatile uint8_t *UDR_reg) {
	*(UDR_reg  - UCSRB_off) |= serTX_INT_ENABLE;
    11b2:	35 97       	sbiw	r30, 0x05	; 5
    11b4:	80 81       	ld	r24, Z
    11b6:	80 62       	ori	r24, 0x20	; 32
    11b8:	80 83       	st	Z, r24
	// Put in the tx buffer
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
	return BUFFER_OK;
    11ba:	80 e0       	ldi	r24, 0x00	; 0
    11bc:	03 c0       	rjmp	.+6      	; 0x11c4 <serial_send_bytes+0x78>
/*-----------------------------------------------------------*/
uint8_t serial_send_bytes(serial_p handle, uint8_t *buf, uint8_t len )
{
	// Check if buffer is full
	if ( ((handle->_tx_buf != 0) && (len > (BUFFER_SIZE - handle->_tx_buf->no_in_buffer))) || ((handle->_tx_buf == 0) && (len > 1)) ) {
		return BUFFER_FULL;
    11be:	82 e0       	ldi	r24, 0x02	; 2
    11c0:	01 c0       	rjmp	.+2      	; 0x11c4 <serial_send_bytes+0x78>
    11c2:	82 e0       	ldi	r24, 0x02	; 2
	for (uint8_t i = 0; i < len; i++) {
		buffer_put_item(handle->_tx_buf, buf[i]);
	}
	_serial_tx_int_on(handle->ser_UDR);
	return BUFFER_OK;
}
    11c4:	df 91       	pop	r29
    11c6:	cf 91       	pop	r28
    11c8:	1f 91       	pop	r17
    11ca:	0f 91       	pop	r16
    11cc:	ff 90       	pop	r15
    11ce:	ef 90       	pop	r14
    11d0:	08 95       	ret

000011d2 <__vector_20>:

/*-----------------------------------------------------------*/
ISR(USART0_RX_vect)
{
    11d2:	1f 92       	push	r1
    11d4:	0f 92       	push	r0
    11d6:	0f b6       	in	r0, 0x3f	; 63
    11d8:	0f 92       	push	r0
    11da:	11 24       	eor	r1, r1
    11dc:	2f 93       	push	r18
    11de:	3f 93       	push	r19
    11e0:	4f 93       	push	r20
    11e2:	5f 93       	push	r21
    11e4:	6f 93       	push	r22
    11e6:	7f 93       	push	r23
    11e8:	8f 93       	push	r24
    11ea:	9f 93       	push	r25
    11ec:	af 93       	push	r26
    11ee:	bf 93       	push	r27
    11f0:	cf 93       	push	r28
    11f2:	ef 93       	push	r30
    11f4:	ff 93       	push	r31
	uint8_t item;
	if (_ser_handle[ser_USART0]) {
    11f6:	e0 91 8b 07 	lds	r30, 0x078B	; 0x80078b <_ser_handle>
    11fa:	f0 91 8c 07 	lds	r31, 0x078C	; 0x80078c <_ser_handle+0x1>
    11fe:	30 97       	sbiw	r30, 0x00	; 0
    1200:	a1 f0       	breq	.+40     	; 0x122a <__vector_20+0x58>
		item = UDR0;
    1202:	c0 91 c6 00 	lds	r28, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
		buffer_put_item(_ser_handle[ser_USART0]->_rx_buf, item);
    1206:	6c 2f       	mov	r22, r28
    1208:	84 81       	ldd	r24, Z+4	; 0x04
    120a:	95 81       	ldd	r25, Z+5	; 0x05
    120c:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <buffer_put_item>
		
		if (_ser_handle[ser_USART0]->_call_back) {
    1210:	80 91 8b 07 	lds	r24, 0x078B	; 0x80078b <_ser_handle>
    1214:	90 91 8c 07 	lds	r25, 0x078C	; 0x80078c <_ser_handle+0x1>
    1218:	dc 01       	movw	r26, r24
    121a:	16 96       	adiw	r26, 0x06	; 6
    121c:	ed 91       	ld	r30, X+
    121e:	fc 91       	ld	r31, X
    1220:	17 97       	sbiw	r26, 0x07	; 7
    1222:	30 97       	sbiw	r30, 0x00	; 0
    1224:	11 f0       	breq	.+4      	; 0x122a <__vector_20+0x58>
			_ser_handle[ser_USART0]->_call_back(_ser_handle[ser_USART0], item);
    1226:	6c 2f       	mov	r22, r28
    1228:	09 95       	icall
		}
	}
}
    122a:	ff 91       	pop	r31
    122c:	ef 91       	pop	r30
    122e:	cf 91       	pop	r28
    1230:	bf 91       	pop	r27
    1232:	af 91       	pop	r26
    1234:	9f 91       	pop	r25
    1236:	8f 91       	pop	r24
    1238:	7f 91       	pop	r23
    123a:	6f 91       	pop	r22
    123c:	5f 91       	pop	r21
    123e:	4f 91       	pop	r20
    1240:	3f 91       	pop	r19
    1242:	2f 91       	pop	r18
    1244:	0f 90       	pop	r0
    1246:	0f be       	out	0x3f, r0	; 63
    1248:	0f 90       	pop	r0
    124a:	1f 90       	pop	r1
    124c:	18 95       	reti

0000124e <__vector_21>:

/*-----------------------------------------------------------*/
ISR(USART0_UDRE_vect)
{
    124e:	1f 92       	push	r1
    1250:	0f 92       	push	r0
    1252:	0f b6       	in	r0, 0x3f	; 63
    1254:	0f 92       	push	r0
    1256:	11 24       	eor	r1, r1
    1258:	2f 93       	push	r18
    125a:	3f 93       	push	r19
    125c:	4f 93       	push	r20
    125e:	5f 93       	push	r21
    1260:	6f 93       	push	r22
    1262:	7f 93       	push	r23
    1264:	8f 93       	push	r24
    1266:	9f 93       	push	r25
    1268:	af 93       	push	r26
    126a:	bf 93       	push	r27
    126c:	ef 93       	push	r30
    126e:	ff 93       	push	r31
    1270:	cf 93       	push	r28
    1272:	df 93       	push	r29
    1274:	1f 92       	push	r1
    1276:	cd b7       	in	r28, 0x3d	; 61
    1278:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	if (_ser_handle[ser_USART0]) {
    127a:	e0 91 8b 07 	lds	r30, 0x078B	; 0x80078b <_ser_handle>
    127e:	f0 91 8c 07 	lds	r31, 0x078C	; 0x80078c <_ser_handle+0x1>
    1282:	30 97       	sbiw	r30, 0x00	; 0
    1284:	99 f0       	breq	.+38     	; 0x12ac <__vector_21+0x5e>
		if ((buffer_get_item(_ser_handle[ser_USART0]->_tx_buf, &item) == BUFFER_OK)) {
    1286:	be 01       	movw	r22, r28
    1288:	6f 5f       	subi	r22, 0xFF	; 255
    128a:	7f 4f       	sbci	r23, 0xFF	; 255
    128c:	82 81       	ldd	r24, Z+2	; 0x02
    128e:	93 81       	ldd	r25, Z+3	; 0x03
    1290:	0e 94 d0 05 	call	0xba0	; 0xba0 <buffer_get_item>
    1294:	81 11       	cpse	r24, r1
    1296:	04 c0       	rjmp	.+8      	; 0x12a0 <__vector_21+0x52>
			UDR0 = item;
    1298:	89 81       	ldd	r24, Y+1	; 0x01
    129a:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
    129e:	0b c0       	rjmp	.+22     	; 0x12b6 <__vector_21+0x68>
		}
		else
		{
			SERIAL_TX_INT_OFF(UCSR0B);
    12a0:	e1 ec       	ldi	r30, 0xC1	; 193
    12a2:	f0 e0       	ldi	r31, 0x00	; 0
    12a4:	80 81       	ld	r24, Z
    12a6:	8f 7d       	andi	r24, 0xDF	; 223
    12a8:	80 83       	st	Z, r24
    12aa:	05 c0       	rjmp	.+10     	; 0x12b6 <__vector_21+0x68>
		}
	}
	
	else
	{
		SERIAL_TX_INT_OFF(UCSR0B);
    12ac:	e1 ec       	ldi	r30, 0xC1	; 193
    12ae:	f0 e0       	ldi	r31, 0x00	; 0
    12b0:	80 81       	ld	r24, Z
    12b2:	8f 7d       	andi	r24, 0xDF	; 223
    12b4:	80 83       	st	Z, r24
	}
}
    12b6:	0f 90       	pop	r0
    12b8:	df 91       	pop	r29
    12ba:	cf 91       	pop	r28
    12bc:	ff 91       	pop	r31
    12be:	ef 91       	pop	r30
    12c0:	bf 91       	pop	r27
    12c2:	af 91       	pop	r26
    12c4:	9f 91       	pop	r25
    12c6:	8f 91       	pop	r24
    12c8:	7f 91       	pop	r23
    12ca:	6f 91       	pop	r22
    12cc:	5f 91       	pop	r21
    12ce:	4f 91       	pop	r20
    12d0:	3f 91       	pop	r19
    12d2:	2f 91       	pop	r18
    12d4:	0f 90       	pop	r0
    12d6:	0f be       	out	0x3f, r0	; 63
    12d8:	0f 90       	pop	r0
    12da:	1f 90       	pop	r1
    12dc:	18 95       	reti

000012de <__vector_28>:

/*-----------------------------------------------------------*/
ISR(USART1_RX_vect)
{
    12de:	1f 92       	push	r1
    12e0:	0f 92       	push	r0
    12e2:	0f b6       	in	r0, 0x3f	; 63
    12e4:	0f 92       	push	r0
    12e6:	11 24       	eor	r1, r1
    12e8:	2f 93       	push	r18
    12ea:	3f 93       	push	r19
    12ec:	4f 93       	push	r20
    12ee:	5f 93       	push	r21
    12f0:	6f 93       	push	r22
    12f2:	7f 93       	push	r23
    12f4:	8f 93       	push	r24
    12f6:	9f 93       	push	r25
    12f8:	af 93       	push	r26
    12fa:	bf 93       	push	r27
    12fc:	cf 93       	push	r28
    12fe:	ef 93       	push	r30
    1300:	ff 93       	push	r31
	uint8_t item;
	if (_ser_handle[ser_USART1]) {
    1302:	e0 91 8d 07 	lds	r30, 0x078D	; 0x80078d <_ser_handle+0x2>
    1306:	f0 91 8e 07 	lds	r31, 0x078E	; 0x80078e <_ser_handle+0x3>
    130a:	30 97       	sbiw	r30, 0x00	; 0
    130c:	a1 f0       	breq	.+40     	; 0x1336 <__vector_28+0x58>
		item = UDR1;
    130e:	c0 91 ce 00 	lds	r28, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
		buffer_put_item(_ser_handle[ser_USART1]->_rx_buf, item);
    1312:	6c 2f       	mov	r22, r28
    1314:	84 81       	ldd	r24, Z+4	; 0x04
    1316:	95 81       	ldd	r25, Z+5	; 0x05
    1318:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <buffer_put_item>
		if (_ser_handle[ser_USART1]->_call_back) {
    131c:	80 91 8d 07 	lds	r24, 0x078D	; 0x80078d <_ser_handle+0x2>
    1320:	90 91 8e 07 	lds	r25, 0x078E	; 0x80078e <_ser_handle+0x3>
    1324:	dc 01       	movw	r26, r24
    1326:	16 96       	adiw	r26, 0x06	; 6
    1328:	ed 91       	ld	r30, X+
    132a:	fc 91       	ld	r31, X
    132c:	17 97       	sbiw	r26, 0x07	; 7
    132e:	30 97       	sbiw	r30, 0x00	; 0
    1330:	11 f0       	breq	.+4      	; 0x1336 <__vector_28+0x58>
			_ser_handle[ser_USART1]->_call_back(_ser_handle[ser_USART1], item);
    1332:	6c 2f       	mov	r22, r28
    1334:	09 95       	icall
		}
	}
}
    1336:	ff 91       	pop	r31
    1338:	ef 91       	pop	r30
    133a:	cf 91       	pop	r28
    133c:	bf 91       	pop	r27
    133e:	af 91       	pop	r26
    1340:	9f 91       	pop	r25
    1342:	8f 91       	pop	r24
    1344:	7f 91       	pop	r23
    1346:	6f 91       	pop	r22
    1348:	5f 91       	pop	r21
    134a:	4f 91       	pop	r20
    134c:	3f 91       	pop	r19
    134e:	2f 91       	pop	r18
    1350:	0f 90       	pop	r0
    1352:	0f be       	out	0x3f, r0	; 63
    1354:	0f 90       	pop	r0
    1356:	1f 90       	pop	r1
    1358:	18 95       	reti

0000135a <__vector_29>:

/*-----------------------------------------------------------*/
ISR(USART1_UDRE_vect)
{
    135a:	1f 92       	push	r1
    135c:	0f 92       	push	r0
    135e:	0f b6       	in	r0, 0x3f	; 63
    1360:	0f 92       	push	r0
    1362:	11 24       	eor	r1, r1
    1364:	2f 93       	push	r18
    1366:	3f 93       	push	r19
    1368:	4f 93       	push	r20
    136a:	5f 93       	push	r21
    136c:	6f 93       	push	r22
    136e:	7f 93       	push	r23
    1370:	8f 93       	push	r24
    1372:	9f 93       	push	r25
    1374:	af 93       	push	r26
    1376:	bf 93       	push	r27
    1378:	ef 93       	push	r30
    137a:	ff 93       	push	r31
    137c:	cf 93       	push	r28
    137e:	df 93       	push	r29
    1380:	1f 92       	push	r1
    1382:	cd b7       	in	r28, 0x3d	; 61
    1384:	de b7       	in	r29, 0x3e	; 62
	uint8_t item;
	if (_ser_handle[ser_USART1]) {
    1386:	e0 91 8d 07 	lds	r30, 0x078D	; 0x80078d <_ser_handle+0x2>
    138a:	f0 91 8e 07 	lds	r31, 0x078E	; 0x80078e <_ser_handle+0x3>
    138e:	30 97       	sbiw	r30, 0x00	; 0
    1390:	99 f0       	breq	.+38     	; 0x13b8 <__vector_29+0x5e>
		if ((buffer_get_item(_ser_handle[ser_USART1]->_tx_buf, &item) == BUFFER_OK)) {
    1392:	be 01       	movw	r22, r28
    1394:	6f 5f       	subi	r22, 0xFF	; 255
    1396:	7f 4f       	sbci	r23, 0xFF	; 255
    1398:	82 81       	ldd	r24, Z+2	; 0x02
    139a:	93 81       	ldd	r25, Z+3	; 0x03
    139c:	0e 94 d0 05 	call	0xba0	; 0xba0 <buffer_get_item>
    13a0:	81 11       	cpse	r24, r1
    13a2:	04 c0       	rjmp	.+8      	; 0x13ac <__vector_29+0x52>
			UDR1 = item;
    13a4:	89 81       	ldd	r24, Y+1	; 0x01
    13a6:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
    13aa:	0b c0       	rjmp	.+22     	; 0x13c2 <__vector_29+0x68>
		}
		else
		{
			SERIAL_TX_INT_OFF(UCSR1B);
    13ac:	e9 ec       	ldi	r30, 0xC9	; 201
    13ae:	f0 e0       	ldi	r31, 0x00	; 0
    13b0:	80 81       	ld	r24, Z
    13b2:	8f 7d       	andi	r24, 0xDF	; 223
    13b4:	80 83       	st	Z, r24
    13b6:	05 c0       	rjmp	.+10     	; 0x13c2 <__vector_29+0x68>
		}
	}
	
	else
	{
		SERIAL_TX_INT_OFF(UCSR1B);
    13b8:	e9 ec       	ldi	r30, 0xC9	; 201
    13ba:	f0 e0       	ldi	r31, 0x00	; 0
    13bc:	80 81       	ld	r24, Z
    13be:	8f 7d       	andi	r24, 0xDF	; 223
    13c0:	80 83       	st	Z, r24
	}
}
    13c2:	0f 90       	pop	r0
    13c4:	df 91       	pop	r29
    13c6:	cf 91       	pop	r28
    13c8:	ff 91       	pop	r31
    13ca:	ef 91       	pop	r30
    13cc:	bf 91       	pop	r27
    13ce:	af 91       	pop	r26
    13d0:	9f 91       	pop	r25
    13d2:	8f 91       	pop	r24
    13d4:	7f 91       	pop	r23
    13d6:	6f 91       	pop	r22
    13d8:	5f 91       	pop	r21
    13da:	4f 91       	pop	r20
    13dc:	3f 91       	pop	r19
    13de:	2f 91       	pop	r18
    13e0:	0f 90       	pop	r0
    13e2:	0f be       	out	0x3f, r0	; 63
    13e4:	0f 90       	pop	r0
    13e6:	1f 90       	pop	r1
    13e8:	18 95       	reti

000013ea <vTimerCallbackCollisions>:
		{
			return size;
		}
	}
	return size;
}
    13ea:	20 e0       	ldi	r18, 0x00	; 0
    13ec:	40 e0       	ldi	r20, 0x00	; 0
    13ee:	50 e0       	ldi	r21, 0x00	; 0
    13f0:	60 e0       	ldi	r22, 0x00	; 0
    13f2:	70 e0       	ldi	r23, 0x00	; 0
    13f4:	80 91 55 08 	lds	r24, 0x0855	; 0x800855 <xTimerSemaphoreCollisions>
    13f8:	90 91 56 08 	lds	r25, 0x0856	; 0x800856 <xTimerSemaphoreCollisions+0x1>
    13fc:	0e 94 c6 0c 	call	0x198c	; 0x198c <xQueueGenericSend>
    1400:	08 95       	ret

00001402 <vTimerCallbackControllersAndDraw>:
    1402:	20 e0       	ldi	r18, 0x00	; 0
    1404:	40 e0       	ldi	r20, 0x00	; 0
    1406:	50 e0       	ldi	r21, 0x00	; 0
    1408:	60 e0       	ldi	r22, 0x00	; 0
    140a:	70 e0       	ldi	r23, 0x00	; 0
    140c:	80 91 4b 08 	lds	r24, 0x084B	; 0x80084b <xTimerSemaphoreDrawShips>
    1410:	90 91 4c 08 	lds	r25, 0x084C	; 0x80084c <xTimerSemaphoreDrawShips+0x1>
    1414:	0e 94 c6 0c 	call	0x198c	; 0x198c <xQueueGenericSend>
    1418:	20 e0       	ldi	r18, 0x00	; 0
    141a:	40 e0       	ldi	r20, 0x00	; 0
    141c:	50 e0       	ldi	r21, 0x00	; 0
    141e:	60 e0       	ldi	r22, 0x00	; 0
    1420:	70 e0       	ldi	r23, 0x00	; 0
    1422:	80 91 47 08 	lds	r24, 0x0847	; 0x800847 <xTimerSemaphoreJoystick>
    1426:	90 91 48 08 	lds	r25, 0x0848	; 0x800848 <xTimerSemaphoreJoystick+0x1>
    142a:	0e 94 c6 0c 	call	0x198c	; 0x198c <xQueueGenericSend>
    142e:	20 e0       	ldi	r18, 0x00	; 0
    1430:	40 e0       	ldi	r20, 0x00	; 0
    1432:	50 e0       	ldi	r21, 0x00	; 0
    1434:	60 e0       	ldi	r22, 0x00	; 0
    1436:	70 e0       	ldi	r23, 0x00	; 0
    1438:	80 91 5a 08 	lds	r24, 0x085A	; 0x80085a <xTimerSemaphorePCConn>
    143c:	90 91 5b 08 	lds	r25, 0x085B	; 0x80085b <xTimerSemaphorePCConn+0x1>
    1440:	0e 94 c6 0c 	call	0x198c	; 0x198c <xQueueGenericSend>
    1444:	20 e0       	ldi	r18, 0x00	; 0
    1446:	40 e0       	ldi	r20, 0x00	; 0
    1448:	50 e0       	ldi	r21, 0x00	; 0
    144a:	60 e0       	ldi	r22, 0x00	; 0
    144c:	70 e0       	ldi	r23, 0x00	; 0
    144e:	80 91 49 08 	lds	r24, 0x0849	; 0x800849 <xTimerSemaphoreDrawBullets>
    1452:	90 91 4a 08 	lds	r25, 0x084A	; 0x80084a <xTimerSemaphoreDrawBullets+0x1>
    1456:	0e 94 c6 0c 	call	0x198c	; 0x198c <xQueueGenericSend>
    145a:	20 e0       	ldi	r18, 0x00	; 0
    145c:	40 e0       	ldi	r20, 0x00	; 0
    145e:	50 e0       	ldi	r21, 0x00	; 0
    1460:	60 e0       	ldi	r22, 0x00	; 0
    1462:	70 e0       	ldi	r23, 0x00	; 0
    1464:	80 91 5e 08 	lds	r24, 0x085E	; 0x80085e <xTimerSemaphoreBullets>
    1468:	90 91 5f 08 	lds	r25, 0x085F	; 0x80085f <xTimerSemaphoreBullets+0x1>
    146c:	0e 94 c6 0c 	call	0x198c	; 0x198c <xQueueGenericSend>
    1470:	20 e0       	ldi	r18, 0x00	; 0
    1472:	40 e0       	ldi	r20, 0x00	; 0
    1474:	50 e0       	ldi	r21, 0x00	; 0
    1476:	60 e0       	ldi	r22, 0x00	; 0
    1478:	70 e0       	ldi	r23, 0x00	; 0
    147a:	80 91 4d 08 	lds	r24, 0x084D	; 0x80084d <xTimerSemaphoreMoveShip>
    147e:	90 91 4e 08 	lds	r25, 0x084E	; 0x80084e <xTimerSemaphoreMoveShip+0x1>
    1482:	0e 94 c6 0c 	call	0x198c	; 0x198c <xQueueGenericSend>
    1486:	08 95       	ret

00001488 <init_timers>:
    1488:	0f 93       	push	r16
    148a:	1f 93       	push	r17
    148c:	05 ef       	ldi	r16, 0xF5	; 245
    148e:	19 e0       	ldi	r17, 0x09	; 9
    1490:	20 e0       	ldi	r18, 0x00	; 0
    1492:	30 e0       	ldi	r19, 0x00	; 0
    1494:	41 e0       	ldi	r20, 0x01	; 1
    1496:	60 e5       	ldi	r22, 0x50	; 80
    1498:	70 e0       	ldi	r23, 0x00	; 0
    149a:	84 e6       	ldi	r24, 0x64	; 100
    149c:	91 e0       	ldi	r25, 0x01	; 1
    149e:	0e 94 9d 14 	call	0x293a	; 0x293a <xTimerCreate>
    14a2:	90 93 59 08 	sts	0x0859, r25	; 0x800859 <xTimerCollisions+0x1>
    14a6:	80 93 58 08 	sts	0x0858, r24	; 0x800858 <xTimerCollisions>
    14aa:	01 e0       	ldi	r16, 0x01	; 1
    14ac:	1a e0       	ldi	r17, 0x0A	; 10
    14ae:	20 e0       	ldi	r18, 0x00	; 0
    14b0:	30 e0       	ldi	r19, 0x00	; 0
    14b2:	41 e0       	ldi	r20, 0x01	; 1
    14b4:	64 e6       	ldi	r22, 0x64	; 100
    14b6:	70 e0       	ldi	r23, 0x00	; 0
    14b8:	85 e7       	ldi	r24, 0x75	; 117
    14ba:	91 e0       	ldi	r25, 0x01	; 1
    14bc:	0e 94 9d 14 	call	0x293a	; 0x293a <xTimerCreate>
    14c0:	90 93 54 08 	sts	0x0854, r25	; 0x800854 <xTimerControllersAndDraw+0x1>
    14c4:	80 93 53 08 	sts	0x0853, r24	; 0x800853 <xTimerControllersAndDraw>
    14c8:	1f 91       	pop	r17
    14ca:	0f 91       	pop	r16
    14cc:	08 95       	ret

000014ce <init_semaphores>:
    14ce:	43 e0       	ldi	r20, 0x03	; 3
    14d0:	60 e0       	ldi	r22, 0x00	; 0
    14d2:	81 e0       	ldi	r24, 0x01	; 1
    14d4:	0e 94 93 0c 	call	0x1926	; 0x1926 <xQueueGenericCreate>
    14d8:	90 93 48 08 	sts	0x0848, r25	; 0x800848 <xTimerSemaphoreJoystick+0x1>
    14dc:	80 93 47 08 	sts	0x0847, r24	; 0x800847 <xTimerSemaphoreJoystick>
    14e0:	43 e0       	ldi	r20, 0x03	; 3
    14e2:	60 e0       	ldi	r22, 0x00	; 0
    14e4:	81 e0       	ldi	r24, 0x01	; 1
    14e6:	0e 94 93 0c 	call	0x1926	; 0x1926 <xQueueGenericCreate>
    14ea:	90 93 4c 08 	sts	0x084C, r25	; 0x80084c <xTimerSemaphoreDrawShips+0x1>
    14ee:	80 93 4b 08 	sts	0x084B, r24	; 0x80084b <xTimerSemaphoreDrawShips>
    14f2:	43 e0       	ldi	r20, 0x03	; 3
    14f4:	60 e0       	ldi	r22, 0x00	; 0
    14f6:	81 e0       	ldi	r24, 0x01	; 1
    14f8:	0e 94 93 0c 	call	0x1926	; 0x1926 <xQueueGenericCreate>
    14fc:	90 93 4a 08 	sts	0x084A, r25	; 0x80084a <xTimerSemaphoreDrawBullets+0x1>
    1500:	80 93 49 08 	sts	0x0849, r24	; 0x800849 <xTimerSemaphoreDrawBullets>
    1504:	43 e0       	ldi	r20, 0x03	; 3
    1506:	60 e0       	ldi	r22, 0x00	; 0
    1508:	81 e0       	ldi	r24, 0x01	; 1
    150a:	0e 94 93 0c 	call	0x1926	; 0x1926 <xQueueGenericCreate>
    150e:	90 93 5b 08 	sts	0x085B, r25	; 0x80085b <xTimerSemaphorePCConn+0x1>
    1512:	80 93 5a 08 	sts	0x085A, r24	; 0x80085a <xTimerSemaphorePCConn>
    1516:	43 e0       	ldi	r20, 0x03	; 3
    1518:	60 e0       	ldi	r22, 0x00	; 0
    151a:	81 e0       	ldi	r24, 0x01	; 1
    151c:	0e 94 93 0c 	call	0x1926	; 0x1926 <xQueueGenericCreate>
    1520:	90 93 5f 08 	sts	0x085F, r25	; 0x80085f <xTimerSemaphoreBullets+0x1>
    1524:	80 93 5e 08 	sts	0x085E, r24	; 0x80085e <xTimerSemaphoreBullets>
    1528:	43 e0       	ldi	r20, 0x03	; 3
    152a:	60 e0       	ldi	r22, 0x00	; 0
    152c:	81 e0       	ldi	r24, 0x01	; 1
    152e:	0e 94 93 0c 	call	0x1926	; 0x1926 <xQueueGenericCreate>
    1532:	90 93 56 08 	sts	0x0856, r25	; 0x800856 <xTimerSemaphoreCollisions+0x1>
    1536:	80 93 55 08 	sts	0x0855, r24	; 0x800855 <xTimerSemaphoreCollisions>
    153a:	43 e0       	ldi	r20, 0x03	; 3
    153c:	60 e0       	ldi	r22, 0x00	; 0
    153e:	81 e0       	ldi	r24, 0x01	; 1
    1540:	0e 94 93 0c 	call	0x1926	; 0x1926 <xQueueGenericCreate>
    1544:	90 93 4e 08 	sts	0x084E, r25	; 0x80084e <xTimerSemaphoreMoveShip+0x1>
    1548:	80 93 4d 08 	sts	0x084D, r24	; 0x80084d <xTimerSemaphoreMoveShip>
    154c:	81 e0       	ldi	r24, 0x01	; 1
    154e:	0e 94 75 0d 	call	0x1aea	; 0x1aea <xQueueCreateMutex>
    1552:	90 93 5d 08 	sts	0x085D, r25	; 0x80085d <xFramebufMutex+0x1>
    1556:	80 93 5c 08 	sts	0x085C, r24	; 0x80085c <xFramebufMutex>
    155a:	08 95       	ret

0000155c <start_timers>:
    155c:	0f 93       	push	r16
    155e:	1f 93       	push	r17
    1560:	0e 94 8c 10 	call	0x2118	; 0x2118 <xTaskGetTickCount>
    1564:	00 e0       	ldi	r16, 0x00	; 0
    1566:	10 e0       	ldi	r17, 0x00	; 0
    1568:	20 e0       	ldi	r18, 0x00	; 0
    156a:	30 e0       	ldi	r19, 0x00	; 0
    156c:	ac 01       	movw	r20, r24
    156e:	61 e0       	ldi	r22, 0x01	; 1
    1570:	80 91 58 08 	lds	r24, 0x0858	; 0x800858 <xTimerCollisions>
    1574:	90 91 59 08 	lds	r25, 0x0859	; 0x800859 <xTimerCollisions+0x1>
    1578:	0e 94 cf 14 	call	0x299e	; 0x299e <xTimerGenericCommand>
    157c:	0e 94 8c 10 	call	0x2118	; 0x2118 <xTaskGetTickCount>
    1580:	20 e0       	ldi	r18, 0x00	; 0
    1582:	30 e0       	ldi	r19, 0x00	; 0
    1584:	ac 01       	movw	r20, r24
    1586:	61 e0       	ldi	r22, 0x01	; 1
    1588:	80 91 53 08 	lds	r24, 0x0853	; 0x800853 <xTimerControllersAndDraw>
    158c:	90 91 54 08 	lds	r25, 0x0854	; 0x800854 <xTimerControllersAndDraw+0x1>
    1590:	0e 94 cf 14 	call	0x299e	; 0x299e <xTimerGenericCommand>
    1594:	1f 91       	pop	r17
    1596:	0f 91       	pop	r16
    1598:	08 95       	ret

0000159a <wait>:
    159a:	20 ed       	ldi	r18, 0xD0	; 208
    159c:	37 e0       	ldi	r19, 0x07	; 7
    159e:	05 c0       	rjmp	.+10     	; 0x15aa <wait+0x10>
    15a0:	01 97       	sbiw	r24, 0x01	; 1
    15a2:	f1 f7       	brne	.-4      	; 0x15a0 <wait+0x6>
    15a4:	21 50       	subi	r18, 0x01	; 1
    15a6:	31 09       	sbc	r19, r1
    15a8:	19 f0       	breq	.+6      	; 0x15b0 <wait+0x16>
    15aa:	80 ed       	ldi	r24, 0xD0	; 208
    15ac:	97 e0       	ldi	r25, 0x07	; 7
    15ae:	f8 cf       	rjmp	.-16     	; 0x15a0 <wait+0x6>
    15b0:	08 95       	ret

000015b2 <bullet_ship_collision>:
    15b2:	ef 92       	push	r14
    15b4:	ff 92       	push	r15
    15b6:	0f 93       	push	r16
    15b8:	1f 93       	push	r17
    15ba:	cf 93       	push	r28
    15bc:	df 93       	push	r29
    15be:	8c 01       	movw	r16, r24
    15c0:	eb 01       	movw	r28, r22
    15c2:	0e 94 e9 04 	call	0x9d2	; 0x9d2 <getY>
    15c6:	7c 01       	movw	r14, r24
    15c8:	ce 01       	movw	r24, r28
    15ca:	0e 94 e9 04 	call	0x9d2	; 0x9d2 <getY>
    15ce:	e8 16       	cp	r14, r24
    15d0:	f9 06       	cpc	r15, r25
    15d2:	e1 f4       	brne	.+56     	; 0x160c <bullet_ship_collision+0x5a>
    15d4:	c8 01       	movw	r24, r16
    15d6:	0e 94 e6 04 	call	0x9cc	; 0x9cc <getX>
    15da:	7c 01       	movw	r14, r24
    15dc:	ce 01       	movw	r24, r28
    15de:	0e 94 e6 04 	call	0x9cc	; 0x9cc <getX>
    15e2:	01 97       	sbiw	r24, 0x01	; 1
    15e4:	e8 16       	cp	r14, r24
    15e6:	f9 06       	cpc	r15, r25
    15e8:	61 f1       	breq	.+88     	; 0x1642 <bullet_ship_collision+0x90>
    15ea:	c8 01       	movw	r24, r16
    15ec:	0e 94 e6 04 	call	0x9cc	; 0x9cc <getX>
    15f0:	8c 01       	movw	r16, r24
    15f2:	ce 01       	movw	r24, r28
    15f4:	0e 94 e6 04 	call	0x9cc	; 0x9cc <getX>
    15f8:	9c 01       	movw	r18, r24
    15fa:	2f 5f       	subi	r18, 0xFF	; 255
    15fc:	3f 4f       	sbci	r19, 0xFF	; 255
    15fe:	81 e0       	ldi	r24, 0x01	; 1
    1600:	90 e0       	ldi	r25, 0x00	; 0
    1602:	20 17       	cp	r18, r16
    1604:	31 07       	cpc	r19, r17
    1606:	11 f1       	breq	.+68     	; 0x164c <bullet_ship_collision+0x9a>
    1608:	80 e0       	ldi	r24, 0x00	; 0
    160a:	20 c0       	rjmp	.+64     	; 0x164c <bullet_ship_collision+0x9a>
    160c:	c8 01       	movw	r24, r16
    160e:	0e 94 e6 04 	call	0x9cc	; 0x9cc <getX>
    1612:	7c 01       	movw	r14, r24
    1614:	ce 01       	movw	r24, r28
    1616:	0e 94 e6 04 	call	0x9cc	; 0x9cc <getX>
    161a:	e8 16       	cp	r14, r24
    161c:	f9 06       	cpc	r15, r25
    161e:	a1 f4       	brne	.+40     	; 0x1648 <bullet_ship_collision+0x96>
    1620:	c8 01       	movw	r24, r16
    1622:	0e 94 e9 04 	call	0x9d2	; 0x9d2 <getY>
    1626:	8c 01       	movw	r16, r24
    1628:	ce 01       	movw	r24, r28
    162a:	0e 94 e9 04 	call	0x9d2	; 0x9d2 <getY>
    162e:	9c 01       	movw	r18, r24
    1630:	2f 5f       	subi	r18, 0xFF	; 255
    1632:	3f 4f       	sbci	r19, 0xFF	; 255
    1634:	81 e0       	ldi	r24, 0x01	; 1
    1636:	90 e0       	ldi	r25, 0x00	; 0
    1638:	20 17       	cp	r18, r16
    163a:	31 07       	cpc	r19, r17
    163c:	39 f0       	breq	.+14     	; 0x164c <bullet_ship_collision+0x9a>
    163e:	80 e0       	ldi	r24, 0x00	; 0
    1640:	05 c0       	rjmp	.+10     	; 0x164c <bullet_ship_collision+0x9a>
    1642:	81 e0       	ldi	r24, 0x01	; 1
    1644:	90 e0       	ldi	r25, 0x00	; 0
    1646:	02 c0       	rjmp	.+4      	; 0x164c <bullet_ship_collision+0x9a>
    1648:	80 e0       	ldi	r24, 0x00	; 0
    164a:	90 e0       	ldi	r25, 0x00	; 0
    164c:	df 91       	pop	r29
    164e:	cf 91       	pop	r28
    1650:	1f 91       	pop	r17
    1652:	0f 91       	pop	r16
    1654:	ff 90       	pop	r15
    1656:	ef 90       	pop	r14
    1658:	08 95       	ret

0000165a <power>:

int power(uint16_t base, uint16_t p)
{
	if(base == 0 || p < 0)
    165a:	00 97       	sbiw	r24, 0x00	; 0
    165c:	b9 f0       	breq	.+46     	; 0x168c <power+0x32>
	{
		return 0;
	}
	
	int result = 1;
	for(int i = 0; i < p; i++)
    165e:	61 15       	cp	r22, r1
    1660:	71 05       	cpc	r23, r1
    1662:	b9 f0       	breq	.+46     	; 0x1692 <power+0x38>
    1664:	20 e0       	ldi	r18, 0x00	; 0
    1666:	30 e0       	ldi	r19, 0x00	; 0
    1668:	41 e0       	ldi	r20, 0x01	; 1
    166a:	50 e0       	ldi	r21, 0x00	; 0
	{
		result *= base;
    166c:	fa 01       	movw	r30, r20
    166e:	e8 9f       	mul	r30, r24
    1670:	a0 01       	movw	r20, r0
    1672:	e9 9f       	mul	r30, r25
    1674:	50 0d       	add	r21, r0
    1676:	f8 9f       	mul	r31, r24
    1678:	50 0d       	add	r21, r0
    167a:	11 24       	eor	r1, r1
	{
		return 0;
	}
	
	int result = 1;
	for(int i = 0; i < p; i++)
    167c:	2f 5f       	subi	r18, 0xFF	; 255
    167e:	3f 4f       	sbci	r19, 0xFF	; 255
    1680:	26 17       	cp	r18, r22
    1682:	37 07       	cpc	r19, r23
    1684:	99 f7       	brne	.-26     	; 0x166c <power+0x12>
	{
		result *= base;
    1686:	84 2f       	mov	r24, r20
    1688:	95 2f       	mov	r25, r21
    168a:	08 95       	ret

int power(uint16_t base, uint16_t p)
{
	if(base == 0 || p < 0)
	{
		return 0;
    168c:	80 e0       	ldi	r24, 0x00	; 0
    168e:	90 e0       	ldi	r25, 0x00	; 0
    1690:	08 95       	ret
	}
	
	int result = 1;
	for(int i = 0; i < p; i++)
    1692:	81 e0       	ldi	r24, 0x01	; 1
    1694:	90 e0       	ldi	r25, 0x00	; 0
	{
		result *= base;
	}
	return result;
}
    1696:	08 95       	ret

00001698 <prvCopyDataToQueue>:
		{
			xReturn = pdFAIL;
		}

		return xReturn;
	}
    1698:	0f 93       	push	r16
    169a:	1f 93       	push	r17
    169c:	cf 93       	push	r28
    169e:	df 93       	push	r29
    16a0:	ec 01       	movw	r28, r24
    16a2:	04 2f       	mov	r16, r20
    16a4:	1a 8d       	ldd	r17, Y+26	; 0x1a
    16a6:	4c 8d       	ldd	r20, Y+28	; 0x1c
    16a8:	41 11       	cpse	r20, r1
    16aa:	0c c0       	rjmp	.+24     	; 0x16c4 <prvCopyDataToQueue+0x2c>
    16ac:	88 81       	ld	r24, Y
    16ae:	99 81       	ldd	r25, Y+1	; 0x01
    16b0:	89 2b       	or	r24, r25
    16b2:	09 f0       	breq	.+2      	; 0x16b6 <prvCopyDataToQueue+0x1e>
    16b4:	42 c0       	rjmp	.+132    	; 0x173a <prvCopyDataToQueue+0xa2>
    16b6:	8a 81       	ldd	r24, Y+2	; 0x02
    16b8:	9b 81       	ldd	r25, Y+3	; 0x03
    16ba:	0e 94 d1 13 	call	0x27a2	; 0x27a2 <xTaskPriorityDisinherit>
    16be:	1b 82       	std	Y+3, r1	; 0x03
    16c0:	1a 82       	std	Y+2, r1	; 0x02
    16c2:	42 c0       	rjmp	.+132    	; 0x1748 <prvCopyDataToQueue+0xb0>
    16c4:	01 11       	cpse	r16, r1
    16c6:	17 c0       	rjmp	.+46     	; 0x16f6 <prvCopyDataToQueue+0x5e>
    16c8:	50 e0       	ldi	r21, 0x00	; 0
    16ca:	8c 81       	ldd	r24, Y+4	; 0x04
    16cc:	9d 81       	ldd	r25, Y+5	; 0x05
    16ce:	0e 94 c0 17 	call	0x2f80	; 0x2f80 <memcpy>
    16d2:	2c 8d       	ldd	r18, Y+28	; 0x1c
    16d4:	8c 81       	ldd	r24, Y+4	; 0x04
    16d6:	9d 81       	ldd	r25, Y+5	; 0x05
    16d8:	82 0f       	add	r24, r18
    16da:	91 1d       	adc	r25, r1
    16dc:	9d 83       	std	Y+5, r25	; 0x05
    16de:	8c 83       	std	Y+4, r24	; 0x04
    16e0:	2a 81       	ldd	r18, Y+2	; 0x02
    16e2:	3b 81       	ldd	r19, Y+3	; 0x03
    16e4:	82 17       	cp	r24, r18
    16e6:	93 07       	cpc	r25, r19
    16e8:	50 f1       	brcs	.+84     	; 0x173e <prvCopyDataToQueue+0xa6>
    16ea:	88 81       	ld	r24, Y
    16ec:	99 81       	ldd	r25, Y+1	; 0x01
    16ee:	9d 83       	std	Y+5, r25	; 0x05
    16f0:	8c 83       	std	Y+4, r24	; 0x04
    16f2:	80 e0       	ldi	r24, 0x00	; 0
    16f4:	29 c0       	rjmp	.+82     	; 0x1748 <prvCopyDataToQueue+0xb0>
    16f6:	50 e0       	ldi	r21, 0x00	; 0
    16f8:	8e 81       	ldd	r24, Y+6	; 0x06
    16fa:	9f 81       	ldd	r25, Y+7	; 0x07
    16fc:	0e 94 c0 17 	call	0x2f80	; 0x2f80 <memcpy>
    1700:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1702:	90 e0       	ldi	r25, 0x00	; 0
    1704:	91 95       	neg	r25
    1706:	81 95       	neg	r24
    1708:	91 09       	sbc	r25, r1
    170a:	2e 81       	ldd	r18, Y+6	; 0x06
    170c:	3f 81       	ldd	r19, Y+7	; 0x07
    170e:	28 0f       	add	r18, r24
    1710:	39 1f       	adc	r19, r25
    1712:	3f 83       	std	Y+7, r19	; 0x07
    1714:	2e 83       	std	Y+6, r18	; 0x06
    1716:	48 81       	ld	r20, Y
    1718:	59 81       	ldd	r21, Y+1	; 0x01
    171a:	24 17       	cp	r18, r20
    171c:	35 07       	cpc	r19, r21
    171e:	30 f4       	brcc	.+12     	; 0x172c <prvCopyDataToQueue+0x94>
    1720:	2a 81       	ldd	r18, Y+2	; 0x02
    1722:	3b 81       	ldd	r19, Y+3	; 0x03
    1724:	82 0f       	add	r24, r18
    1726:	93 1f       	adc	r25, r19
    1728:	9f 83       	std	Y+7, r25	; 0x07
    172a:	8e 83       	std	Y+6, r24	; 0x06
    172c:	02 30       	cpi	r16, 0x02	; 2
    172e:	49 f4       	brne	.+18     	; 0x1742 <prvCopyDataToQueue+0xaa>
    1730:	11 23       	and	r17, r17
    1732:	49 f0       	breq	.+18     	; 0x1746 <prvCopyDataToQueue+0xae>
    1734:	11 50       	subi	r17, 0x01	; 1
    1736:	80 e0       	ldi	r24, 0x00	; 0
    1738:	07 c0       	rjmp	.+14     	; 0x1748 <prvCopyDataToQueue+0xb0>
    173a:	80 e0       	ldi	r24, 0x00	; 0
    173c:	05 c0       	rjmp	.+10     	; 0x1748 <prvCopyDataToQueue+0xb0>
    173e:	80 e0       	ldi	r24, 0x00	; 0
    1740:	03 c0       	rjmp	.+6      	; 0x1748 <prvCopyDataToQueue+0xb0>
    1742:	80 e0       	ldi	r24, 0x00	; 0
    1744:	01 c0       	rjmp	.+2      	; 0x1748 <prvCopyDataToQueue+0xb0>
    1746:	80 e0       	ldi	r24, 0x00	; 0
    1748:	1f 5f       	subi	r17, 0xFF	; 255
    174a:	1a 8f       	std	Y+26, r17	; 0x1a
    174c:	df 91       	pop	r29
    174e:	cf 91       	pop	r28
    1750:	1f 91       	pop	r17
    1752:	0f 91       	pop	r16
    1754:	08 95       	ret

00001756 <prvNotifyQueueSetContainer>:
    1756:	ef 92       	push	r14
    1758:	ff 92       	push	r15
    175a:	0f 93       	push	r16
    175c:	1f 93       	push	r17
    175e:	cf 93       	push	r28
    1760:	df 93       	push	r29
    1762:	00 d0       	rcall	.+0      	; 0x1764 <prvNotifyQueueSetContainer+0xe>
    1764:	cd b7       	in	r28, 0x3d	; 61
    1766:	de b7       	in	r29, 0x3e	; 62
    1768:	9a 83       	std	Y+2, r25	; 0x02
    176a:	89 83       	std	Y+1, r24	; 0x01
    176c:	fc 01       	movw	r30, r24
    176e:	07 8d       	ldd	r16, Z+31	; 0x1f
    1770:	10 a1       	ldd	r17, Z+32	; 0x20
    1772:	f8 01       	movw	r30, r16
    1774:	92 8d       	ldd	r25, Z+26	; 0x1a
    1776:	83 8d       	ldd	r24, Z+27	; 0x1b
    1778:	98 17       	cp	r25, r24
    177a:	e8 f4       	brcc	.+58     	; 0x17b6 <prvNotifyQueueSetContainer+0x60>
    177c:	46 2f       	mov	r20, r22
    177e:	e6 8c       	ldd	r14, Z+30	; 0x1e
    1780:	be 01       	movw	r22, r28
    1782:	6f 5f       	subi	r22, 0xFF	; 255
    1784:	7f 4f       	sbci	r23, 0xFF	; 255
    1786:	c8 01       	movw	r24, r16
    1788:	0e 94 4c 0b 	call	0x1698	; 0x1698 <prvCopyDataToQueue>
    178c:	f8 2e       	mov	r15, r24
    178e:	ff ef       	ldi	r31, 0xFF	; 255
    1790:	ef 12       	cpse	r14, r31
    1792:	0d c0       	rjmp	.+26     	; 0x17ae <prvNotifyQueueSetContainer+0x58>
    1794:	f8 01       	movw	r30, r16
    1796:	81 89       	ldd	r24, Z+17	; 0x11
    1798:	88 23       	and	r24, r24
    179a:	71 f0       	breq	.+28     	; 0x17b8 <prvNotifyQueueSetContainer+0x62>
    179c:	c8 01       	movw	r24, r16
    179e:	41 96       	adiw	r24, 0x11	; 17
    17a0:	0e 94 d1 12 	call	0x25a2	; 0x25a2 <xTaskRemoveFromEventList>
    17a4:	88 23       	and	r24, r24
    17a6:	41 f0       	breq	.+16     	; 0x17b8 <prvNotifyQueueSetContainer+0x62>
    17a8:	ff 24       	eor	r15, r15
    17aa:	f3 94       	inc	r15
    17ac:	05 c0       	rjmp	.+10     	; 0x17b8 <prvNotifyQueueSetContainer+0x62>
    17ae:	e3 94       	inc	r14
    17b0:	f8 01       	movw	r30, r16
    17b2:	e6 8e       	std	Z+30, r14	; 0x1e
    17b4:	01 c0       	rjmp	.+2      	; 0x17b8 <prvNotifyQueueSetContainer+0x62>
    17b6:	f1 2c       	mov	r15, r1
    17b8:	8f 2d       	mov	r24, r15
    17ba:	0f 90       	pop	r0
    17bc:	0f 90       	pop	r0
    17be:	df 91       	pop	r29
    17c0:	cf 91       	pop	r28
    17c2:	1f 91       	pop	r17
    17c4:	0f 91       	pop	r16
    17c6:	ff 90       	pop	r15
    17c8:	ef 90       	pop	r14
    17ca:	08 95       	ret

000017cc <prvCopyDataFromQueue>:
    17cc:	fc 01       	movw	r30, r24
    17ce:	44 8d       	ldd	r20, Z+28	; 0x1c
    17d0:	44 23       	and	r20, r20
    17d2:	a9 f0       	breq	.+42     	; 0x17fe <prvCopyDataFromQueue+0x32>
    17d4:	50 e0       	ldi	r21, 0x00	; 0
    17d6:	26 81       	ldd	r18, Z+6	; 0x06
    17d8:	37 81       	ldd	r19, Z+7	; 0x07
    17da:	24 0f       	add	r18, r20
    17dc:	35 1f       	adc	r19, r21
    17de:	37 83       	std	Z+7, r19	; 0x07
    17e0:	26 83       	std	Z+6, r18	; 0x06
    17e2:	82 81       	ldd	r24, Z+2	; 0x02
    17e4:	93 81       	ldd	r25, Z+3	; 0x03
    17e6:	28 17       	cp	r18, r24
    17e8:	39 07       	cpc	r19, r25
    17ea:	20 f0       	brcs	.+8      	; 0x17f4 <prvCopyDataFromQueue+0x28>
    17ec:	80 81       	ld	r24, Z
    17ee:	91 81       	ldd	r25, Z+1	; 0x01
    17f0:	97 83       	std	Z+7, r25	; 0x07
    17f2:	86 83       	std	Z+6, r24	; 0x06
    17f4:	cb 01       	movw	r24, r22
    17f6:	66 81       	ldd	r22, Z+6	; 0x06
    17f8:	77 81       	ldd	r23, Z+7	; 0x07
    17fa:	0e 94 c0 17 	call	0x2f80	; 0x2f80 <memcpy>
    17fe:	08 95       	ret

00001800 <prvUnlockQueue>:
    1800:	ef 92       	push	r14
    1802:	ff 92       	push	r15
    1804:	0f 93       	push	r16
    1806:	1f 93       	push	r17
    1808:	cf 93       	push	r28
    180a:	8c 01       	movw	r16, r24
    180c:	0f b6       	in	r0, 0x3f	; 63
    180e:	f8 94       	cli
    1810:	0f 92       	push	r0
    1812:	fc 01       	movw	r30, r24
    1814:	c6 8d       	ldd	r28, Z+30	; 0x1e
    1816:	1c 16       	cp	r1, r28
    1818:	f4 f4       	brge	.+60     	; 0x1856 <prvUnlockQueue+0x56>
    181a:	7c 01       	movw	r14, r24
    181c:	f1 e1       	ldi	r31, 0x11	; 17
    181e:	ef 0e       	add	r14, r31
    1820:	f1 1c       	adc	r15, r1
    1822:	f8 01       	movw	r30, r16
    1824:	87 8d       	ldd	r24, Z+31	; 0x1f
    1826:	90 a1       	ldd	r25, Z+32	; 0x20
    1828:	89 2b       	or	r24, r25
    182a:	49 f0       	breq	.+18     	; 0x183e <prvUnlockQueue+0x3e>
    182c:	60 e0       	ldi	r22, 0x00	; 0
    182e:	c8 01       	movw	r24, r16
    1830:	0e 94 ab 0b 	call	0x1756	; 0x1756 <prvNotifyQueueSetContainer>
    1834:	88 23       	and	r24, r24
    1836:	69 f0       	breq	.+26     	; 0x1852 <prvUnlockQueue+0x52>
    1838:	0e 94 5d 13 	call	0x26ba	; 0x26ba <vTaskMissedYield>
    183c:	0a c0       	rjmp	.+20     	; 0x1852 <prvUnlockQueue+0x52>
    183e:	f8 01       	movw	r30, r16
    1840:	81 89       	ldd	r24, Z+17	; 0x11
    1842:	88 23       	and	r24, r24
    1844:	41 f0       	breq	.+16     	; 0x1856 <prvUnlockQueue+0x56>
    1846:	c7 01       	movw	r24, r14
    1848:	0e 94 d1 12 	call	0x25a2	; 0x25a2 <xTaskRemoveFromEventList>
    184c:	81 11       	cpse	r24, r1
    184e:	0e 94 5d 13 	call	0x26ba	; 0x26ba <vTaskMissedYield>
    1852:	c1 50       	subi	r28, 0x01	; 1
    1854:	31 f7       	brne	.-52     	; 0x1822 <prvUnlockQueue+0x22>
    1856:	8f ef       	ldi	r24, 0xFF	; 255
    1858:	f8 01       	movw	r30, r16
    185a:	86 8f       	std	Z+30, r24	; 0x1e
    185c:	0f 90       	pop	r0
    185e:	0f be       	out	0x3f, r0	; 63
    1860:	0f b6       	in	r0, 0x3f	; 63
    1862:	f8 94       	cli
    1864:	0f 92       	push	r0
    1866:	c5 8d       	ldd	r28, Z+29	; 0x1d
    1868:	1c 16       	cp	r1, r28
    186a:	ac f4       	brge	.+42     	; 0x1896 <prvUnlockQueue+0x96>
    186c:	80 85       	ldd	r24, Z+8	; 0x08
    186e:	81 11       	cpse	r24, r1
    1870:	06 c0       	rjmp	.+12     	; 0x187e <prvUnlockQueue+0x7e>
    1872:	11 c0       	rjmp	.+34     	; 0x1896 <prvUnlockQueue+0x96>
    1874:	f8 01       	movw	r30, r16
    1876:	80 85       	ldd	r24, Z+8	; 0x08
    1878:	81 11       	cpse	r24, r1
    187a:	05 c0       	rjmp	.+10     	; 0x1886 <prvUnlockQueue+0x86>
    187c:	0c c0       	rjmp	.+24     	; 0x1896 <prvUnlockQueue+0x96>
    187e:	78 01       	movw	r14, r16
    1880:	f8 e0       	ldi	r31, 0x08	; 8
    1882:	ef 0e       	add	r14, r31
    1884:	f1 1c       	adc	r15, r1
    1886:	c7 01       	movw	r24, r14
    1888:	0e 94 d1 12 	call	0x25a2	; 0x25a2 <xTaskRemoveFromEventList>
    188c:	81 11       	cpse	r24, r1
    188e:	0e 94 5d 13 	call	0x26ba	; 0x26ba <vTaskMissedYield>
    1892:	c1 50       	subi	r28, 0x01	; 1
    1894:	79 f7       	brne	.-34     	; 0x1874 <prvUnlockQueue+0x74>
    1896:	8f ef       	ldi	r24, 0xFF	; 255
    1898:	f8 01       	movw	r30, r16
    189a:	85 8f       	std	Z+29, r24	; 0x1d
    189c:	0f 90       	pop	r0
    189e:	0f be       	out	0x3f, r0	; 63
    18a0:	cf 91       	pop	r28
    18a2:	1f 91       	pop	r17
    18a4:	0f 91       	pop	r16
    18a6:	ff 90       	pop	r15
    18a8:	ef 90       	pop	r14
    18aa:	08 95       	ret

000018ac <xQueueGenericReset>:
    18ac:	cf 93       	push	r28
    18ae:	df 93       	push	r29
    18b0:	ec 01       	movw	r28, r24
    18b2:	0f b6       	in	r0, 0x3f	; 63
    18b4:	f8 94       	cli
    18b6:	0f 92       	push	r0
    18b8:	48 81       	ld	r20, Y
    18ba:	59 81       	ldd	r21, Y+1	; 0x01
    18bc:	2c 8d       	ldd	r18, Y+28	; 0x1c
    18be:	30 e0       	ldi	r19, 0x00	; 0
    18c0:	7b 8d       	ldd	r23, Y+27	; 0x1b
    18c2:	72 9f       	mul	r23, r18
    18c4:	c0 01       	movw	r24, r0
    18c6:	73 9f       	mul	r23, r19
    18c8:	90 0d       	add	r25, r0
    18ca:	11 24       	eor	r1, r1
    18cc:	fa 01       	movw	r30, r20
    18ce:	e8 0f       	add	r30, r24
    18d0:	f9 1f       	adc	r31, r25
    18d2:	fb 83       	std	Y+3, r31	; 0x03
    18d4:	ea 83       	std	Y+2, r30	; 0x02
    18d6:	1a 8e       	std	Y+26, r1	; 0x1a
    18d8:	5d 83       	std	Y+5, r21	; 0x05
    18da:	4c 83       	std	Y+4, r20	; 0x04
    18dc:	82 1b       	sub	r24, r18
    18de:	93 0b       	sbc	r25, r19
    18e0:	84 0f       	add	r24, r20
    18e2:	95 1f       	adc	r25, r21
    18e4:	9f 83       	std	Y+7, r25	; 0x07
    18e6:	8e 83       	std	Y+6, r24	; 0x06
    18e8:	8f ef       	ldi	r24, 0xFF	; 255
    18ea:	8d 8f       	std	Y+29, r24	; 0x1d
    18ec:	8e 8f       	std	Y+30, r24	; 0x1e
    18ee:	61 11       	cpse	r22, r1
    18f0:	0c c0       	rjmp	.+24     	; 0x190a <xQueueGenericReset+0x5e>
    18f2:	88 85       	ldd	r24, Y+8	; 0x08
    18f4:	88 23       	and	r24, r24
    18f6:	89 f0       	breq	.+34     	; 0x191a <xQueueGenericReset+0x6e>
    18f8:	ce 01       	movw	r24, r28
    18fa:	08 96       	adiw	r24, 0x08	; 8
    18fc:	0e 94 d1 12 	call	0x25a2	; 0x25a2 <xTaskRemoveFromEventList>
    1900:	88 23       	and	r24, r24
    1902:	59 f0       	breq	.+22     	; 0x191a <xQueueGenericReset+0x6e>
    1904:	0e 94 3e 07 	call	0xe7c	; 0xe7c <vPortYield>
    1908:	08 c0       	rjmp	.+16     	; 0x191a <xQueueGenericReset+0x6e>
    190a:	ce 01       	movw	r24, r28
    190c:	08 96       	adiw	r24, 0x08	; 8
    190e:	0e 94 0e 06 	call	0xc1c	; 0xc1c <vListInitialise>
    1912:	ce 01       	movw	r24, r28
    1914:	41 96       	adiw	r24, 0x11	; 17
    1916:	0e 94 0e 06 	call	0xc1c	; 0xc1c <vListInitialise>
    191a:	0f 90       	pop	r0
    191c:	0f be       	out	0x3f, r0	; 63
    191e:	81 e0       	ldi	r24, 0x01	; 1
    1920:	df 91       	pop	r29
    1922:	cf 91       	pop	r28
    1924:	08 95       	ret

00001926 <xQueueGenericCreate>:
    1926:	ff 92       	push	r15
    1928:	0f 93       	push	r16
    192a:	1f 93       	push	r17
    192c:	cf 93       	push	r28
    192e:	df 93       	push	r29
    1930:	08 2f       	mov	r16, r24
    1932:	16 2f       	mov	r17, r22
    1934:	f4 2e       	mov	r15, r20
    1936:	66 23       	and	r22, r22
    1938:	d9 f0       	breq	.+54     	; 0x1970 <xQueueGenericCreate+0x4a>
    193a:	86 9f       	mul	r24, r22
    193c:	c0 01       	movw	r24, r0
    193e:	11 24       	eor	r1, r1
    1940:	83 96       	adiw	r24, 0x23	; 35
    1942:	0e 94 f6 07 	call	0xfec	; 0xfec <pvPortMalloc>
    1946:	ec 01       	movw	r28, r24
    1948:	00 97       	sbiw	r24, 0x00	; 0
    194a:	59 f4       	brne	.+22     	; 0x1962 <xQueueGenericCreate+0x3c>
    194c:	18 c0       	rjmp	.+48     	; 0x197e <xQueueGenericCreate+0x58>
    194e:	0b 8f       	std	Y+27, r16	; 0x1b
    1950:	1c 8f       	std	Y+28, r17	; 0x1c
    1952:	61 e0       	ldi	r22, 0x01	; 1
    1954:	ce 01       	movw	r24, r28
    1956:	0e 94 56 0c 	call	0x18ac	; 0x18ac <xQueueGenericReset>
    195a:	fa a2       	std	Y+34, r15	; 0x22
    195c:	18 a2       	std	Y+32, r1	; 0x20
    195e:	1f 8e       	std	Y+31, r1	; 0x1f
    1960:	0e c0       	rjmp	.+28     	; 0x197e <xQueueGenericCreate+0x58>
    1962:	83 96       	adiw	r24, 0x23	; 35
    1964:	99 83       	std	Y+1, r25	; 0x01
    1966:	88 83       	st	Y, r24
    1968:	f2 cf       	rjmp	.-28     	; 0x194e <xQueueGenericCreate+0x28>
    196a:	d9 83       	std	Y+1, r29	; 0x01
    196c:	c8 83       	st	Y, r28
    196e:	ef cf       	rjmp	.-34     	; 0x194e <xQueueGenericCreate+0x28>
    1970:	83 e2       	ldi	r24, 0x23	; 35
    1972:	90 e0       	ldi	r25, 0x00	; 0
    1974:	0e 94 f6 07 	call	0xfec	; 0xfec <pvPortMalloc>
    1978:	ec 01       	movw	r28, r24
    197a:	89 2b       	or	r24, r25
    197c:	b1 f7       	brne	.-20     	; 0x196a <xQueueGenericCreate+0x44>
    197e:	ce 01       	movw	r24, r28
    1980:	df 91       	pop	r29
    1982:	cf 91       	pop	r28
    1984:	1f 91       	pop	r17
    1986:	0f 91       	pop	r16
    1988:	ff 90       	pop	r15
    198a:	08 95       	ret

0000198c <xQueueGenericSend>:
    198c:	9f 92       	push	r9
    198e:	af 92       	push	r10
    1990:	bf 92       	push	r11
    1992:	cf 92       	push	r12
    1994:	df 92       	push	r13
    1996:	ef 92       	push	r14
    1998:	ff 92       	push	r15
    199a:	0f 93       	push	r16
    199c:	1f 93       	push	r17
    199e:	cf 93       	push	r28
    19a0:	df 93       	push	r29
    19a2:	00 d0       	rcall	.+0      	; 0x19a4 <xQueueGenericSend+0x18>
    19a4:	00 d0       	rcall	.+0      	; 0x19a6 <xQueueGenericSend+0x1a>
    19a6:	1f 92       	push	r1
    19a8:	cd b7       	in	r28, 0x3d	; 61
    19aa:	de b7       	in	r29, 0x3e	; 62
    19ac:	8c 01       	movw	r16, r24
    19ae:	6b 01       	movw	r12, r22
    19b0:	5d 83       	std	Y+5, r21	; 0x05
    19b2:	4c 83       	std	Y+4, r20	; 0x04
    19b4:	a2 2e       	mov	r10, r18
    19b6:	b1 2c       	mov	r11, r1
    19b8:	99 24       	eor	r9, r9
    19ba:	93 94       	inc	r9
    19bc:	7c 01       	movw	r14, r24
    19be:	88 e0       	ldi	r24, 0x08	; 8
    19c0:	e8 0e       	add	r14, r24
    19c2:	f1 1c       	adc	r15, r1
    19c4:	0f b6       	in	r0, 0x3f	; 63
    19c6:	f8 94       	cli
    19c8:	0f 92       	push	r0
    19ca:	f8 01       	movw	r30, r16
    19cc:	92 8d       	ldd	r25, Z+26	; 0x1a
    19ce:	83 8d       	ldd	r24, Z+27	; 0x1b
    19d0:	98 17       	cp	r25, r24
    19d2:	18 f0       	brcs	.+6      	; 0x19da <xQueueGenericSend+0x4e>
    19d4:	f2 e0       	ldi	r31, 0x02	; 2
    19d6:	af 12       	cpse	r10, r31
    19d8:	27 c0       	rjmp	.+78     	; 0x1a28 <xQueueGenericSend+0x9c>
    19da:	4a 2d       	mov	r20, r10
    19dc:	b6 01       	movw	r22, r12
    19de:	c8 01       	movw	r24, r16
    19e0:	0e 94 4c 0b 	call	0x1698	; 0x1698 <prvCopyDataToQueue>
    19e4:	f8 01       	movw	r30, r16
    19e6:	27 8d       	ldd	r18, Z+31	; 0x1f
    19e8:	30 a1       	ldd	r19, Z+32	; 0x20
    19ea:	23 2b       	or	r18, r19
    19ec:	49 f0       	breq	.+18     	; 0x1a00 <xQueueGenericSend+0x74>
    19ee:	6a 2d       	mov	r22, r10
    19f0:	c8 01       	movw	r24, r16
    19f2:	0e 94 ab 0b 	call	0x1756	; 0x1756 <prvNotifyQueueSetContainer>
    19f6:	88 23       	and	r24, r24
    19f8:	99 f0       	breq	.+38     	; 0x1a20 <xQueueGenericSend+0x94>
    19fa:	0e 94 3e 07 	call	0xe7c	; 0xe7c <vPortYield>
    19fe:	10 c0       	rjmp	.+32     	; 0x1a20 <xQueueGenericSend+0x94>
    1a00:	f8 01       	movw	r30, r16
    1a02:	91 89       	ldd	r25, Z+17	; 0x11
    1a04:	99 23       	and	r25, r25
    1a06:	49 f0       	breq	.+18     	; 0x1a1a <xQueueGenericSend+0x8e>
    1a08:	c8 01       	movw	r24, r16
    1a0a:	41 96       	adiw	r24, 0x11	; 17
    1a0c:	0e 94 d1 12 	call	0x25a2	; 0x25a2 <xTaskRemoveFromEventList>
    1a10:	88 23       	and	r24, r24
    1a12:	31 f0       	breq	.+12     	; 0x1a20 <xQueueGenericSend+0x94>
    1a14:	0e 94 3e 07 	call	0xe7c	; 0xe7c <vPortYield>
    1a18:	03 c0       	rjmp	.+6      	; 0x1a20 <xQueueGenericSend+0x94>
    1a1a:	81 11       	cpse	r24, r1
    1a1c:	0e 94 3e 07 	call	0xe7c	; 0xe7c <vPortYield>
    1a20:	0f 90       	pop	r0
    1a22:	0f be       	out	0x3f, r0	; 63
    1a24:	81 e0       	ldi	r24, 0x01	; 1
    1a26:	50 c0       	rjmp	.+160    	; 0x1ac8 <xQueueGenericSend+0x13c>
    1a28:	8c 81       	ldd	r24, Y+4	; 0x04
    1a2a:	9d 81       	ldd	r25, Y+5	; 0x05
    1a2c:	89 2b       	or	r24, r25
    1a2e:	21 f4       	brne	.+8      	; 0x1a38 <xQueueGenericSend+0xac>
    1a30:	0f 90       	pop	r0
    1a32:	0f be       	out	0x3f, r0	; 63
    1a34:	80 e0       	ldi	r24, 0x00	; 0
    1a36:	48 c0       	rjmp	.+144    	; 0x1ac8 <xQueueGenericSend+0x13c>
    1a38:	b1 10       	cpse	r11, r1
    1a3a:	05 c0       	rjmp	.+10     	; 0x1a46 <xQueueGenericSend+0xba>
    1a3c:	ce 01       	movw	r24, r28
    1a3e:	01 96       	adiw	r24, 0x01	; 1
    1a40:	0e 94 19 13 	call	0x2632	; 0x2632 <vTaskSetTimeOutState>
    1a44:	b9 2c       	mov	r11, r9
    1a46:	0f 90       	pop	r0
    1a48:	0f be       	out	0x3f, r0	; 63
    1a4a:	0e 94 86 10 	call	0x210c	; 0x210c <vTaskSuspendAll>
    1a4e:	0f b6       	in	r0, 0x3f	; 63
    1a50:	f8 94       	cli
    1a52:	0f 92       	push	r0
    1a54:	f8 01       	movw	r30, r16
    1a56:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a58:	8f 3f       	cpi	r24, 0xFF	; 255
    1a5a:	09 f4       	brne	.+2      	; 0x1a5e <xQueueGenericSend+0xd2>
    1a5c:	15 8e       	std	Z+29, r1	; 0x1d
    1a5e:	f8 01       	movw	r30, r16
    1a60:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a62:	8f 3f       	cpi	r24, 0xFF	; 255
    1a64:	09 f4       	brne	.+2      	; 0x1a68 <xQueueGenericSend+0xdc>
    1a66:	16 8e       	std	Z+30, r1	; 0x1e
    1a68:	0f 90       	pop	r0
    1a6a:	0f be       	out	0x3f, r0	; 63
    1a6c:	be 01       	movw	r22, r28
    1a6e:	6c 5f       	subi	r22, 0xFC	; 252
    1a70:	7f 4f       	sbci	r23, 0xFF	; 255
    1a72:	ce 01       	movw	r24, r28
    1a74:	01 96       	adiw	r24, 0x01	; 1
    1a76:	0e 94 24 13 	call	0x2648	; 0x2648 <xTaskCheckForTimeOut>
    1a7a:	81 11       	cpse	r24, r1
    1a7c:	1f c0       	rjmp	.+62     	; 0x1abc <xQueueGenericSend+0x130>
    1a7e:	0f b6       	in	r0, 0x3f	; 63
    1a80:	f8 94       	cli
    1a82:	0f 92       	push	r0
    1a84:	f8 01       	movw	r30, r16
    1a86:	92 8d       	ldd	r25, Z+26	; 0x1a
    1a88:	0f 90       	pop	r0
    1a8a:	0f be       	out	0x3f, r0	; 63
    1a8c:	83 8d       	ldd	r24, Z+27	; 0x1b
    1a8e:	98 13       	cpse	r25, r24
    1a90:	0f c0       	rjmp	.+30     	; 0x1ab0 <xQueueGenericSend+0x124>
    1a92:	6c 81       	ldd	r22, Y+4	; 0x04
    1a94:	7d 81       	ldd	r23, Y+5	; 0x05
    1a96:	c7 01       	movw	r24, r14
    1a98:	0e 94 a6 12 	call	0x254c	; 0x254c <vTaskPlaceOnEventList>
    1a9c:	c8 01       	movw	r24, r16
    1a9e:	0e 94 00 0c 	call	0x1800	; 0x1800 <prvUnlockQueue>
    1aa2:	0e 94 51 11 	call	0x22a2	; 0x22a2 <xTaskResumeAll>
    1aa6:	81 11       	cpse	r24, r1
    1aa8:	8d cf       	rjmp	.-230    	; 0x19c4 <xQueueGenericSend+0x38>
    1aaa:	0e 94 3e 07 	call	0xe7c	; 0xe7c <vPortYield>
    1aae:	8a cf       	rjmp	.-236    	; 0x19c4 <xQueueGenericSend+0x38>
    1ab0:	c8 01       	movw	r24, r16
    1ab2:	0e 94 00 0c 	call	0x1800	; 0x1800 <prvUnlockQueue>
    1ab6:	0e 94 51 11 	call	0x22a2	; 0x22a2 <xTaskResumeAll>
    1aba:	84 cf       	rjmp	.-248    	; 0x19c4 <xQueueGenericSend+0x38>
    1abc:	c8 01       	movw	r24, r16
    1abe:	0e 94 00 0c 	call	0x1800	; 0x1800 <prvUnlockQueue>
    1ac2:	0e 94 51 11 	call	0x22a2	; 0x22a2 <xTaskResumeAll>
    1ac6:	80 e0       	ldi	r24, 0x00	; 0
    1ac8:	0f 90       	pop	r0
    1aca:	0f 90       	pop	r0
    1acc:	0f 90       	pop	r0
    1ace:	0f 90       	pop	r0
    1ad0:	0f 90       	pop	r0
    1ad2:	df 91       	pop	r29
    1ad4:	cf 91       	pop	r28
    1ad6:	1f 91       	pop	r17
    1ad8:	0f 91       	pop	r16
    1ada:	ff 90       	pop	r15
    1adc:	ef 90       	pop	r14
    1ade:	df 90       	pop	r13
    1ae0:	cf 90       	pop	r12
    1ae2:	bf 90       	pop	r11
    1ae4:	af 90       	pop	r10
    1ae6:	9f 90       	pop	r9
    1ae8:	08 95       	ret

00001aea <xQueueCreateMutex>:
    1aea:	cf 93       	push	r28
    1aec:	df 93       	push	r29
    1aee:	48 2f       	mov	r20, r24
    1af0:	60 e0       	ldi	r22, 0x00	; 0
    1af2:	81 e0       	ldi	r24, 0x01	; 1
    1af4:	0e 94 93 0c 	call	0x1926	; 0x1926 <xQueueGenericCreate>
    1af8:	ec 01       	movw	r28, r24
    1afa:	00 97       	sbiw	r24, 0x00	; 0
    1afc:	61 f0       	breq	.+24     	; 0x1b16 <xQueueCreateMutex+0x2c>
    1afe:	1b 82       	std	Y+3, r1	; 0x03
    1b00:	1a 82       	std	Y+2, r1	; 0x02
    1b02:	19 82       	std	Y+1, r1	; 0x01
    1b04:	18 82       	st	Y, r1
    1b06:	1e 82       	std	Y+6, r1	; 0x06
    1b08:	20 e0       	ldi	r18, 0x00	; 0
    1b0a:	40 e0       	ldi	r20, 0x00	; 0
    1b0c:	50 e0       	ldi	r21, 0x00	; 0
    1b0e:	60 e0       	ldi	r22, 0x00	; 0
    1b10:	70 e0       	ldi	r23, 0x00	; 0
    1b12:	0e 94 c6 0c 	call	0x198c	; 0x198c <xQueueGenericSend>
    1b16:	ce 01       	movw	r24, r28
    1b18:	df 91       	pop	r29
    1b1a:	cf 91       	pop	r28
    1b1c:	08 95       	ret

00001b1e <xQueueGenericSendFromISR>:
    1b1e:	ef 92       	push	r14
    1b20:	ff 92       	push	r15
    1b22:	0f 93       	push	r16
    1b24:	1f 93       	push	r17
    1b26:	cf 93       	push	r28
    1b28:	df 93       	push	r29
    1b2a:	7a 01       	movw	r14, r20
    1b2c:	fc 01       	movw	r30, r24
    1b2e:	52 8d       	ldd	r21, Z+26	; 0x1a
    1b30:	33 8d       	ldd	r19, Z+27	; 0x1b
    1b32:	53 17       	cp	r21, r19
    1b34:	10 f0       	brcs	.+4      	; 0x1b3a <xQueueGenericSendFromISR+0x1c>
    1b36:	22 30       	cpi	r18, 0x02	; 2
    1b38:	69 f5       	brne	.+90     	; 0x1b94 <xQueueGenericSendFromISR+0x76>
    1b3a:	12 2f       	mov	r17, r18
    1b3c:	ec 01       	movw	r28, r24
    1b3e:	0e 8d       	ldd	r16, Y+30	; 0x1e
    1b40:	42 2f       	mov	r20, r18
    1b42:	0e 94 4c 0b 	call	0x1698	; 0x1698 <prvCopyDataToQueue>
    1b46:	0f 3f       	cpi	r16, 0xFF	; 255
    1b48:	09 f5       	brne	.+66     	; 0x1b8c <xQueueGenericSendFromISR+0x6e>
    1b4a:	8f 8d       	ldd	r24, Y+31	; 0x1f
    1b4c:	98 a1       	ldd	r25, Y+32	; 0x20
    1b4e:	89 2b       	or	r24, r25
    1b50:	69 f0       	breq	.+26     	; 0x1b6c <xQueueGenericSendFromISR+0x4e>
    1b52:	61 2f       	mov	r22, r17
    1b54:	ce 01       	movw	r24, r28
    1b56:	0e 94 ab 0b 	call	0x1756	; 0x1756 <prvNotifyQueueSetContainer>
    1b5a:	88 23       	and	r24, r24
    1b5c:	e9 f0       	breq	.+58     	; 0x1b98 <xQueueGenericSendFromISR+0x7a>
    1b5e:	e1 14       	cp	r14, r1
    1b60:	f1 04       	cpc	r15, r1
    1b62:	e1 f0       	breq	.+56     	; 0x1b9c <xQueueGenericSendFromISR+0x7e>
    1b64:	81 e0       	ldi	r24, 0x01	; 1
    1b66:	f7 01       	movw	r30, r14
    1b68:	80 83       	st	Z, r24
    1b6a:	1f c0       	rjmp	.+62     	; 0x1baa <xQueueGenericSendFromISR+0x8c>
    1b6c:	89 89       	ldd	r24, Y+17	; 0x11
    1b6e:	88 23       	and	r24, r24
    1b70:	b9 f0       	breq	.+46     	; 0x1ba0 <xQueueGenericSendFromISR+0x82>
    1b72:	ce 01       	movw	r24, r28
    1b74:	41 96       	adiw	r24, 0x11	; 17
    1b76:	0e 94 d1 12 	call	0x25a2	; 0x25a2 <xTaskRemoveFromEventList>
    1b7a:	88 23       	and	r24, r24
    1b7c:	99 f0       	breq	.+38     	; 0x1ba4 <xQueueGenericSendFromISR+0x86>
    1b7e:	e1 14       	cp	r14, r1
    1b80:	f1 04       	cpc	r15, r1
    1b82:	91 f0       	breq	.+36     	; 0x1ba8 <xQueueGenericSendFromISR+0x8a>
    1b84:	81 e0       	ldi	r24, 0x01	; 1
    1b86:	f7 01       	movw	r30, r14
    1b88:	80 83       	st	Z, r24
    1b8a:	0f c0       	rjmp	.+30     	; 0x1baa <xQueueGenericSendFromISR+0x8c>
    1b8c:	0f 5f       	subi	r16, 0xFF	; 255
    1b8e:	0e 8f       	std	Y+30, r16	; 0x1e
    1b90:	81 e0       	ldi	r24, 0x01	; 1
    1b92:	0b c0       	rjmp	.+22     	; 0x1baa <xQueueGenericSendFromISR+0x8c>
    1b94:	80 e0       	ldi	r24, 0x00	; 0
    1b96:	09 c0       	rjmp	.+18     	; 0x1baa <xQueueGenericSendFromISR+0x8c>
    1b98:	81 e0       	ldi	r24, 0x01	; 1
    1b9a:	07 c0       	rjmp	.+14     	; 0x1baa <xQueueGenericSendFromISR+0x8c>
    1b9c:	81 e0       	ldi	r24, 0x01	; 1
    1b9e:	05 c0       	rjmp	.+10     	; 0x1baa <xQueueGenericSendFromISR+0x8c>
    1ba0:	81 e0       	ldi	r24, 0x01	; 1
    1ba2:	03 c0       	rjmp	.+6      	; 0x1baa <xQueueGenericSendFromISR+0x8c>
    1ba4:	81 e0       	ldi	r24, 0x01	; 1
    1ba6:	01 c0       	rjmp	.+2      	; 0x1baa <xQueueGenericSendFromISR+0x8c>
    1ba8:	81 e0       	ldi	r24, 0x01	; 1
    1baa:	df 91       	pop	r29
    1bac:	cf 91       	pop	r28
    1bae:	1f 91       	pop	r17
    1bb0:	0f 91       	pop	r16
    1bb2:	ff 90       	pop	r15
    1bb4:	ef 90       	pop	r14
    1bb6:	08 95       	ret

00001bb8 <xQueueGenericReceive>:
    1bb8:	8f 92       	push	r8
    1bba:	9f 92       	push	r9
    1bbc:	af 92       	push	r10
    1bbe:	bf 92       	push	r11
    1bc0:	cf 92       	push	r12
    1bc2:	df 92       	push	r13
    1bc4:	ef 92       	push	r14
    1bc6:	ff 92       	push	r15
    1bc8:	0f 93       	push	r16
    1bca:	1f 93       	push	r17
    1bcc:	cf 93       	push	r28
    1bce:	df 93       	push	r29
    1bd0:	00 d0       	rcall	.+0      	; 0x1bd2 <xQueueGenericReceive+0x1a>
    1bd2:	00 d0       	rcall	.+0      	; 0x1bd4 <xQueueGenericReceive+0x1c>
    1bd4:	1f 92       	push	r1
    1bd6:	cd b7       	in	r28, 0x3d	; 61
    1bd8:	de b7       	in	r29, 0x3e	; 62
    1bda:	8c 01       	movw	r16, r24
    1bdc:	5b 01       	movw	r10, r22
    1bde:	5d 83       	std	Y+5, r21	; 0x05
    1be0:	4c 83       	std	Y+4, r20	; 0x04
    1be2:	82 2e       	mov	r8, r18
    1be4:	e1 2c       	mov	r14, r1
    1be6:	99 24       	eor	r9, r9
    1be8:	93 94       	inc	r9
    1bea:	6c 01       	movw	r12, r24
    1bec:	81 e1       	ldi	r24, 0x11	; 17
    1bee:	c8 0e       	add	r12, r24
    1bf0:	d1 1c       	adc	r13, r1
    1bf2:	0f b6       	in	r0, 0x3f	; 63
    1bf4:	f8 94       	cli
    1bf6:	0f 92       	push	r0
    1bf8:	f8 01       	movw	r30, r16
    1bfa:	f2 8c       	ldd	r15, Z+26	; 0x1a
    1bfc:	ff 20       	and	r15, r15
    1bfe:	91 f1       	breq	.+100    	; 0x1c64 <xQueueGenericReceive+0xac>
    1c00:	c6 80       	ldd	r12, Z+6	; 0x06
    1c02:	d7 80       	ldd	r13, Z+7	; 0x07
    1c04:	b5 01       	movw	r22, r10
    1c06:	c8 01       	movw	r24, r16
    1c08:	0e 94 e6 0b 	call	0x17cc	; 0x17cc <prvCopyDataFromQueue>
    1c0c:	81 10       	cpse	r8, r1
    1c0e:	19 c0       	rjmp	.+50     	; 0x1c42 <xQueueGenericReceive+0x8a>
    1c10:	fa 94       	dec	r15
    1c12:	f8 01       	movw	r30, r16
    1c14:	f2 8e       	std	Z+26, r15	; 0x1a
    1c16:	80 81       	ld	r24, Z
    1c18:	91 81       	ldd	r25, Z+1	; 0x01
    1c1a:	89 2b       	or	r24, r25
    1c1c:	29 f4       	brne	.+10     	; 0x1c28 <xQueueGenericReceive+0x70>
    1c1e:	0e 94 11 14 	call	0x2822	; 0x2822 <pvTaskIncrementMutexHeldCount>
    1c22:	f8 01       	movw	r30, r16
    1c24:	93 83       	std	Z+3, r25	; 0x03
    1c26:	82 83       	std	Z+2, r24	; 0x02
    1c28:	f8 01       	movw	r30, r16
    1c2a:	80 85       	ldd	r24, Z+8	; 0x08
    1c2c:	88 23       	and	r24, r24
    1c2e:	b1 f0       	breq	.+44     	; 0x1c5c <xQueueGenericReceive+0xa4>
    1c30:	c8 01       	movw	r24, r16
    1c32:	08 96       	adiw	r24, 0x08	; 8
    1c34:	0e 94 d1 12 	call	0x25a2	; 0x25a2 <xTaskRemoveFromEventList>
    1c38:	88 23       	and	r24, r24
    1c3a:	81 f0       	breq	.+32     	; 0x1c5c <xQueueGenericReceive+0xa4>
    1c3c:	0e 94 3e 07 	call	0xe7c	; 0xe7c <vPortYield>
    1c40:	0d c0       	rjmp	.+26     	; 0x1c5c <xQueueGenericReceive+0xa4>
    1c42:	f8 01       	movw	r30, r16
    1c44:	d7 82       	std	Z+7, r13	; 0x07
    1c46:	c6 82       	std	Z+6, r12	; 0x06
    1c48:	81 89       	ldd	r24, Z+17	; 0x11
    1c4a:	88 23       	and	r24, r24
    1c4c:	39 f0       	breq	.+14     	; 0x1c5c <xQueueGenericReceive+0xa4>
    1c4e:	c8 01       	movw	r24, r16
    1c50:	41 96       	adiw	r24, 0x11	; 17
    1c52:	0e 94 d1 12 	call	0x25a2	; 0x25a2 <xTaskRemoveFromEventList>
    1c56:	81 11       	cpse	r24, r1
    1c58:	0e 94 3e 07 	call	0xe7c	; 0xe7c <vPortYield>
    1c5c:	0f 90       	pop	r0
    1c5e:	0f be       	out	0x3f, r0	; 63
    1c60:	81 e0       	ldi	r24, 0x01	; 1
    1c62:	64 c0       	rjmp	.+200    	; 0x1d2c <xQueueGenericReceive+0x174>
    1c64:	8c 81       	ldd	r24, Y+4	; 0x04
    1c66:	9d 81       	ldd	r25, Y+5	; 0x05
    1c68:	89 2b       	or	r24, r25
    1c6a:	21 f4       	brne	.+8      	; 0x1c74 <xQueueGenericReceive+0xbc>
    1c6c:	0f 90       	pop	r0
    1c6e:	0f be       	out	0x3f, r0	; 63
    1c70:	80 e0       	ldi	r24, 0x00	; 0
    1c72:	5c c0       	rjmp	.+184    	; 0x1d2c <xQueueGenericReceive+0x174>
    1c74:	e1 10       	cpse	r14, r1
    1c76:	05 c0       	rjmp	.+10     	; 0x1c82 <xQueueGenericReceive+0xca>
    1c78:	ce 01       	movw	r24, r28
    1c7a:	01 96       	adiw	r24, 0x01	; 1
    1c7c:	0e 94 19 13 	call	0x2632	; 0x2632 <vTaskSetTimeOutState>
    1c80:	e9 2c       	mov	r14, r9
    1c82:	0f 90       	pop	r0
    1c84:	0f be       	out	0x3f, r0	; 63
    1c86:	0e 94 86 10 	call	0x210c	; 0x210c <vTaskSuspendAll>
    1c8a:	0f b6       	in	r0, 0x3f	; 63
    1c8c:	f8 94       	cli
    1c8e:	0f 92       	push	r0
    1c90:	f8 01       	movw	r30, r16
    1c92:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c94:	8f 3f       	cpi	r24, 0xFF	; 255
    1c96:	09 f4       	brne	.+2      	; 0x1c9a <xQueueGenericReceive+0xe2>
    1c98:	15 8e       	std	Z+29, r1	; 0x1d
    1c9a:	f8 01       	movw	r30, r16
    1c9c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c9e:	8f 3f       	cpi	r24, 0xFF	; 255
    1ca0:	09 f4       	brne	.+2      	; 0x1ca4 <xQueueGenericReceive+0xec>
    1ca2:	16 8e       	std	Z+30, r1	; 0x1e
    1ca4:	0f 90       	pop	r0
    1ca6:	0f be       	out	0x3f, r0	; 63
    1ca8:	be 01       	movw	r22, r28
    1caa:	6c 5f       	subi	r22, 0xFC	; 252
    1cac:	7f 4f       	sbci	r23, 0xFF	; 255
    1cae:	ce 01       	movw	r24, r28
    1cb0:	01 96       	adiw	r24, 0x01	; 1
    1cb2:	0e 94 24 13 	call	0x2648	; 0x2648 <xTaskCheckForTimeOut>
    1cb6:	81 11       	cpse	r24, r1
    1cb8:	2b c0       	rjmp	.+86     	; 0x1d10 <xQueueGenericReceive+0x158>
    1cba:	0f b6       	in	r0, 0x3f	; 63
    1cbc:	f8 94       	cli
    1cbe:	0f 92       	push	r0
    1cc0:	f8 01       	movw	r30, r16
    1cc2:	82 8d       	ldd	r24, Z+26	; 0x1a
    1cc4:	0f 90       	pop	r0
    1cc6:	0f be       	out	0x3f, r0	; 63
    1cc8:	81 11       	cpse	r24, r1
    1cca:	1c c0       	rjmp	.+56     	; 0x1d04 <xQueueGenericReceive+0x14c>
    1ccc:	80 81       	ld	r24, Z
    1cce:	91 81       	ldd	r25, Z+1	; 0x01
    1cd0:	89 2b       	or	r24, r25
    1cd2:	49 f4       	brne	.+18     	; 0x1ce6 <xQueueGenericReceive+0x12e>
    1cd4:	0f b6       	in	r0, 0x3f	; 63
    1cd6:	f8 94       	cli
    1cd8:	0f 92       	push	r0
    1cda:	82 81       	ldd	r24, Z+2	; 0x02
    1cdc:	93 81       	ldd	r25, Z+3	; 0x03
    1cde:	0e 94 6f 13 	call	0x26de	; 0x26de <vTaskPriorityInherit>
    1ce2:	0f 90       	pop	r0
    1ce4:	0f be       	out	0x3f, r0	; 63
    1ce6:	6c 81       	ldd	r22, Y+4	; 0x04
    1ce8:	7d 81       	ldd	r23, Y+5	; 0x05
    1cea:	c6 01       	movw	r24, r12
    1cec:	0e 94 a6 12 	call	0x254c	; 0x254c <vTaskPlaceOnEventList>
    1cf0:	c8 01       	movw	r24, r16
    1cf2:	0e 94 00 0c 	call	0x1800	; 0x1800 <prvUnlockQueue>
    1cf6:	0e 94 51 11 	call	0x22a2	; 0x22a2 <xTaskResumeAll>
    1cfa:	81 11       	cpse	r24, r1
    1cfc:	7a cf       	rjmp	.-268    	; 0x1bf2 <xQueueGenericReceive+0x3a>
    1cfe:	0e 94 3e 07 	call	0xe7c	; 0xe7c <vPortYield>
    1d02:	77 cf       	rjmp	.-274    	; 0x1bf2 <xQueueGenericReceive+0x3a>
    1d04:	c8 01       	movw	r24, r16
    1d06:	0e 94 00 0c 	call	0x1800	; 0x1800 <prvUnlockQueue>
    1d0a:	0e 94 51 11 	call	0x22a2	; 0x22a2 <xTaskResumeAll>
    1d0e:	71 cf       	rjmp	.-286    	; 0x1bf2 <xQueueGenericReceive+0x3a>
    1d10:	c8 01       	movw	r24, r16
    1d12:	0e 94 00 0c 	call	0x1800	; 0x1800 <prvUnlockQueue>
    1d16:	0e 94 51 11 	call	0x22a2	; 0x22a2 <xTaskResumeAll>
    1d1a:	0f b6       	in	r0, 0x3f	; 63
    1d1c:	f8 94       	cli
    1d1e:	0f 92       	push	r0
    1d20:	f8 01       	movw	r30, r16
    1d22:	82 8d       	ldd	r24, Z+26	; 0x1a
    1d24:	0f 90       	pop	r0
    1d26:	0f be       	out	0x3f, r0	; 63
    1d28:	81 11       	cpse	r24, r1
    1d2a:	63 cf       	rjmp	.-314    	; 0x1bf2 <xQueueGenericReceive+0x3a>
    1d2c:	0f 90       	pop	r0
    1d2e:	0f 90       	pop	r0
    1d30:	0f 90       	pop	r0
    1d32:	0f 90       	pop	r0
    1d34:	0f 90       	pop	r0
    1d36:	df 91       	pop	r29
    1d38:	cf 91       	pop	r28
    1d3a:	1f 91       	pop	r17
    1d3c:	0f 91       	pop	r16
    1d3e:	ff 90       	pop	r15
    1d40:	ef 90       	pop	r14
    1d42:	df 90       	pop	r13
    1d44:	cf 90       	pop	r12
    1d46:	bf 90       	pop	r11
    1d48:	af 90       	pop	r10
    1d4a:	9f 90       	pop	r9
    1d4c:	8f 90       	pop	r8
    1d4e:	08 95       	ret

00001d50 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    1d50:	cf 93       	push	r28
    1d52:	df 93       	push	r29
    1d54:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    1d56:	0f b6       	in	r0, 0x3f	; 63
    1d58:	f8 94       	cli
    1d5a:	0f 92       	push	r0
    1d5c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1d5e:	8f 3f       	cpi	r24, 0xFF	; 255
    1d60:	09 f4       	brne	.+2      	; 0x1d64 <vQueueWaitForMessageRestricted+0x14>
    1d62:	1d 8e       	std	Y+29, r1	; 0x1d
    1d64:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1d66:	8f 3f       	cpi	r24, 0xFF	; 255
    1d68:	09 f4       	brne	.+2      	; 0x1d6c <vQueueWaitForMessageRestricted+0x1c>
    1d6a:	1e 8e       	std	Y+30, r1	; 0x1e
    1d6c:	0f 90       	pop	r0
    1d6e:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    1d70:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1d72:	81 11       	cpse	r24, r1
    1d74:	04 c0       	rjmp	.+8      	; 0x1d7e <vQueueWaitForMessageRestricted+0x2e>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    1d76:	ce 01       	movw	r24, r28
    1d78:	41 96       	adiw	r24, 0x11	; 17
    1d7a:	0e 94 b8 12 	call	0x2570	; 0x2570 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    1d7e:	ce 01       	movw	r24, r28
    1d80:	0e 94 00 0c 	call	0x1800	; 0x1800 <prvUnlockQueue>
	}
    1d84:	df 91       	pop	r29
    1d86:	cf 91       	pop	r28
    1d88:	08 95       	ret

00001d8a <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1d8a:	e0 91 bb 07 	lds	r30, 0x07BB	; 0x8007bb <pxDelayedTaskList>
    1d8e:	f0 91 bc 07 	lds	r31, 0x07BC	; 0x8007bc <pxDelayedTaskList+0x1>
    1d92:	80 81       	ld	r24, Z
    1d94:	81 11       	cpse	r24, r1
    1d96:	07 c0       	rjmp	.+14     	; 0x1da6 <prvResetNextTaskUnblockTime+0x1c>
    1d98:	8f ef       	ldi	r24, 0xFF	; 255
    1d9a:	9f ef       	ldi	r25, 0xFF	; 255
    1d9c:	90 93 93 07 	sts	0x0793, r25	; 0x800793 <xNextTaskUnblockTime+0x1>
    1da0:	80 93 92 07 	sts	0x0792, r24	; 0x800792 <xNextTaskUnblockTime>
    1da4:	08 95       	ret
    1da6:	e0 91 bb 07 	lds	r30, 0x07BB	; 0x8007bb <pxDelayedTaskList>
    1daa:	f0 91 bc 07 	lds	r31, 0x07BC	; 0x8007bc <pxDelayedTaskList+0x1>
    1dae:	05 80       	ldd	r0, Z+5	; 0x05
    1db0:	f6 81       	ldd	r31, Z+6	; 0x06
    1db2:	e0 2d       	mov	r30, r0
    1db4:	06 80       	ldd	r0, Z+6	; 0x06
    1db6:	f7 81       	ldd	r31, Z+7	; 0x07
    1db8:	e0 2d       	mov	r30, r0
    1dba:	82 81       	ldd	r24, Z+2	; 0x02
    1dbc:	93 81       	ldd	r25, Z+3	; 0x03
    1dbe:	90 93 93 07 	sts	0x0793, r25	; 0x800793 <xNextTaskUnblockTime+0x1>
    1dc2:	80 93 92 07 	sts	0x0792, r24	; 0x800792 <xNextTaskUnblockTime>
    1dc6:	08 95       	ret

00001dc8 <prvAddCurrentTaskToDelayedList>:
    1dc8:	ff 92       	push	r15
    1dca:	0f 93       	push	r16
    1dcc:	1f 93       	push	r17
    1dce:	cf 93       	push	r28
    1dd0:	df 93       	push	r29
    1dd2:	ec 01       	movw	r28, r24
    1dd4:	f6 2e       	mov	r15, r22
    1dd6:	00 91 9a 07 	lds	r16, 0x079A	; 0x80079a <xTickCount>
    1dda:	10 91 9b 07 	lds	r17, 0x079B	; 0x80079b <xTickCount+0x1>
    1dde:	80 91 29 08 	lds	r24, 0x0829	; 0x800829 <pxCurrentTCB>
    1de2:	90 91 2a 08 	lds	r25, 0x082A	; 0x80082a <pxCurrentTCB+0x1>
    1de6:	02 96       	adiw	r24, 0x02	; 2
    1de8:	0e 94 72 06 	call	0xce4	; 0xce4 <uxListRemove>
    1dec:	cf 3f       	cpi	r28, 0xFF	; 255
    1dee:	8f ef       	ldi	r24, 0xFF	; 255
    1df0:	d8 07       	cpc	r29, r24
    1df2:	69 f4       	brne	.+26     	; 0x1e0e <prvAddCurrentTaskToDelayedList+0x46>
    1df4:	ff 20       	and	r15, r15
    1df6:	59 f0       	breq	.+22     	; 0x1e0e <prvAddCurrentTaskToDelayedList+0x46>
    1df8:	60 91 29 08 	lds	r22, 0x0829	; 0x800829 <pxCurrentTCB>
    1dfc:	70 91 2a 08 	lds	r23, 0x082A	; 0x80082a <pxCurrentTCB+0x1>
    1e00:	6e 5f       	subi	r22, 0xFE	; 254
    1e02:	7f 4f       	sbci	r23, 0xFF	; 255
    1e04:	8d e9       	ldi	r24, 0x9D	; 157
    1e06:	97 e0       	ldi	r25, 0x07	; 7
    1e08:	0e 94 20 06 	call	0xc40	; 0xc40 <vListInsertEnd>
    1e0c:	2f c0       	rjmp	.+94     	; 0x1e6c <prvAddCurrentTaskToDelayedList+0xa4>
    1e0e:	c0 0f       	add	r28, r16
    1e10:	d1 1f       	adc	r29, r17
    1e12:	e0 91 29 08 	lds	r30, 0x0829	; 0x800829 <pxCurrentTCB>
    1e16:	f0 91 2a 08 	lds	r31, 0x082A	; 0x80082a <pxCurrentTCB+0x1>
    1e1a:	d3 83       	std	Z+3, r29	; 0x03
    1e1c:	c2 83       	std	Z+2, r28	; 0x02
    1e1e:	c0 17       	cp	r28, r16
    1e20:	d1 07       	cpc	r29, r17
    1e22:	68 f4       	brcc	.+26     	; 0x1e3e <prvAddCurrentTaskToDelayedList+0x76>
    1e24:	60 91 29 08 	lds	r22, 0x0829	; 0x800829 <pxCurrentTCB>
    1e28:	70 91 2a 08 	lds	r23, 0x082A	; 0x80082a <pxCurrentTCB+0x1>
    1e2c:	80 91 b9 07 	lds	r24, 0x07B9	; 0x8007b9 <pxOverflowDelayedTaskList>
    1e30:	90 91 ba 07 	lds	r25, 0x07BA	; 0x8007ba <pxOverflowDelayedTaskList+0x1>
    1e34:	6e 5f       	subi	r22, 0xFE	; 254
    1e36:	7f 4f       	sbci	r23, 0xFF	; 255
    1e38:	0e 94 41 06 	call	0xc82	; 0xc82 <vListInsert>
    1e3c:	17 c0       	rjmp	.+46     	; 0x1e6c <prvAddCurrentTaskToDelayedList+0xa4>
    1e3e:	60 91 29 08 	lds	r22, 0x0829	; 0x800829 <pxCurrentTCB>
    1e42:	70 91 2a 08 	lds	r23, 0x082A	; 0x80082a <pxCurrentTCB+0x1>
    1e46:	80 91 bb 07 	lds	r24, 0x07BB	; 0x8007bb <pxDelayedTaskList>
    1e4a:	90 91 bc 07 	lds	r25, 0x07BC	; 0x8007bc <pxDelayedTaskList+0x1>
    1e4e:	6e 5f       	subi	r22, 0xFE	; 254
    1e50:	7f 4f       	sbci	r23, 0xFF	; 255
    1e52:	0e 94 41 06 	call	0xc82	; 0xc82 <vListInsert>
    1e56:	80 91 92 07 	lds	r24, 0x0792	; 0x800792 <xNextTaskUnblockTime>
    1e5a:	90 91 93 07 	lds	r25, 0x0793	; 0x800793 <xNextTaskUnblockTime+0x1>
    1e5e:	c8 17       	cp	r28, r24
    1e60:	d9 07       	cpc	r29, r25
    1e62:	20 f4       	brcc	.+8      	; 0x1e6c <prvAddCurrentTaskToDelayedList+0xa4>
    1e64:	d0 93 93 07 	sts	0x0793, r29	; 0x800793 <xNextTaskUnblockTime+0x1>
    1e68:	c0 93 92 07 	sts	0x0792, r28	; 0x800792 <xNextTaskUnblockTime>
    1e6c:	df 91       	pop	r29
    1e6e:	cf 91       	pop	r28
    1e70:	1f 91       	pop	r17
    1e72:	0f 91       	pop	r16
    1e74:	ff 90       	pop	r15
    1e76:	08 95       	ret

00001e78 <xTaskCreate>:
    1e78:	4f 92       	push	r4
    1e7a:	5f 92       	push	r5
    1e7c:	6f 92       	push	r6
    1e7e:	7f 92       	push	r7
    1e80:	8f 92       	push	r8
    1e82:	9f 92       	push	r9
    1e84:	af 92       	push	r10
    1e86:	bf 92       	push	r11
    1e88:	cf 92       	push	r12
    1e8a:	df 92       	push	r13
    1e8c:	ef 92       	push	r14
    1e8e:	ff 92       	push	r15
    1e90:	0f 93       	push	r16
    1e92:	1f 93       	push	r17
    1e94:	cf 93       	push	r28
    1e96:	df 93       	push	r29
    1e98:	4c 01       	movw	r8, r24
    1e9a:	6b 01       	movw	r12, r22
    1e9c:	5a 01       	movw	r10, r20
    1e9e:	29 01       	movw	r4, r18
    1ea0:	ca 01       	movw	r24, r20
    1ea2:	0e 94 f6 07 	call	0xfec	; 0xfec <pvPortMalloc>
    1ea6:	3c 01       	movw	r6, r24
    1ea8:	89 2b       	or	r24, r25
    1eaa:	09 f4       	brne	.+2      	; 0x1eae <xTaskCreate+0x36>
    1eac:	ef c0       	rjmp	.+478    	; 0x208c <xTaskCreate+0x214>
    1eae:	88 e2       	ldi	r24, 0x28	; 40
    1eb0:	90 e0       	ldi	r25, 0x00	; 0
    1eb2:	0e 94 f6 07 	call	0xfec	; 0xfec <pvPortMalloc>
    1eb6:	ec 01       	movw	r28, r24
    1eb8:	89 2b       	or	r24, r25
    1eba:	b1 f0       	breq	.+44     	; 0x1ee8 <xTaskCreate+0x70>
    1ebc:	78 8e       	std	Y+24, r7	; 0x18
    1ebe:	6f 8a       	std	Y+23, r6	; 0x17
    1ec0:	a5 01       	movw	r20, r10
    1ec2:	65 ea       	ldi	r22, 0xA5	; 165
    1ec4:	70 e0       	ldi	r23, 0x00	; 0
    1ec6:	c3 01       	movw	r24, r6
    1ec8:	0e 94 c9 17 	call	0x2f92	; 0x2f92 <memset>
    1ecc:	81 e0       	ldi	r24, 0x01	; 1
    1ece:	a8 1a       	sub	r10, r24
    1ed0:	b1 08       	sbc	r11, r1
    1ed2:	8f 89       	ldd	r24, Y+23	; 0x17
    1ed4:	98 8d       	ldd	r25, Y+24	; 0x18
    1ed6:	a8 0e       	add	r10, r24
    1ed8:	b9 1e       	adc	r11, r25
    1eda:	d6 01       	movw	r26, r12
    1edc:	8c 91       	ld	r24, X
    1ede:	89 8f       	std	Y+25, r24	; 0x19
    1ee0:	8c 91       	ld	r24, X
    1ee2:	81 11       	cpse	r24, r1
    1ee4:	05 c0       	rjmp	.+10     	; 0x1ef0 <xTaskCreate+0x78>
    1ee6:	18 c0       	rjmp	.+48     	; 0x1f18 <xTaskCreate+0xa0>
    1ee8:	c3 01       	movw	r24, r6
    1eea:	0e 94 2b 08 	call	0x1056	; 0x1056 <vPortFree>
    1eee:	ce c0       	rjmp	.+412    	; 0x208c <xTaskCreate+0x214>
    1ef0:	ae 01       	movw	r20, r28
    1ef2:	46 5e       	subi	r20, 0xE6	; 230
    1ef4:	5f 4f       	sbci	r21, 0xFF	; 255
    1ef6:	f6 01       	movw	r30, r12
    1ef8:	31 96       	adiw	r30, 0x01	; 1
    1efa:	b4 e0       	ldi	r27, 0x04	; 4
    1efc:	cb 0e       	add	r12, r27
    1efe:	d1 1c       	adc	r13, r1
    1f00:	cf 01       	movw	r24, r30
    1f02:	21 91       	ld	r18, Z+
    1f04:	da 01       	movw	r26, r20
    1f06:	2d 93       	st	X+, r18
    1f08:	ad 01       	movw	r20, r26
    1f0a:	dc 01       	movw	r26, r24
    1f0c:	8c 91       	ld	r24, X
    1f0e:	88 23       	and	r24, r24
    1f10:	19 f0       	breq	.+6      	; 0x1f18 <xTaskCreate+0xa0>
    1f12:	ce 16       	cp	r12, r30
    1f14:	df 06       	cpc	r13, r31
    1f16:	a1 f7       	brne	.-24     	; 0x1f00 <xTaskCreate+0x88>
    1f18:	1c 8e       	std	Y+28, r1	; 0x1c
    1f1a:	0a 30       	cpi	r16, 0x0A	; 10
    1f1c:	08 f0       	brcs	.+2      	; 0x1f20 <xTaskCreate+0xa8>
    1f1e:	09 e0       	ldi	r16, 0x09	; 9
    1f20:	0e 8b       	std	Y+22, r16	; 0x16
    1f22:	0f 8f       	std	Y+31, r16	; 0x1f
    1f24:	18 a2       	std	Y+32, r1	; 0x20
    1f26:	6e 01       	movw	r12, r28
    1f28:	b2 e0       	ldi	r27, 0x02	; 2
    1f2a:	cb 0e       	add	r12, r27
    1f2c:	d1 1c       	adc	r13, r1
    1f2e:	c6 01       	movw	r24, r12
    1f30:	0e 94 1c 06 	call	0xc38	; 0xc38 <vListInitialiseItem>
    1f34:	ce 01       	movw	r24, r28
    1f36:	0c 96       	adiw	r24, 0x0c	; 12
    1f38:	0e 94 1c 06 	call	0xc38	; 0xc38 <vListInitialiseItem>
    1f3c:	d9 87       	std	Y+9, r29	; 0x09
    1f3e:	c8 87       	std	Y+8, r28	; 0x08
    1f40:	8a e0       	ldi	r24, 0x0A	; 10
    1f42:	90 e0       	ldi	r25, 0x00	; 0
    1f44:	80 1b       	sub	r24, r16
    1f46:	91 09       	sbc	r25, r1
    1f48:	9d 87       	std	Y+13, r25	; 0x0d
    1f4a:	8c 87       	std	Y+12, r24	; 0x0c
    1f4c:	db 8b       	std	Y+19, r29	; 0x13
    1f4e:	ca 8b       	std	Y+18, r28	; 0x12
    1f50:	1a a2       	std	Y+34, r1	; 0x22
    1f52:	19 a2       	std	Y+33, r1	; 0x21
    1f54:	1b a2       	std	Y+35, r1	; 0x23
    1f56:	1c a2       	std	Y+36, r1	; 0x24
    1f58:	1d a2       	std	Y+37, r1	; 0x25
    1f5a:	1e a2       	std	Y+38, r1	; 0x26
    1f5c:	1f a2       	std	Y+39, r1	; 0x27
    1f5e:	a2 01       	movw	r20, r4
    1f60:	b4 01       	movw	r22, r8
    1f62:	c5 01       	movw	r24, r10
    1f64:	0e 94 98 06 	call	0xd30	; 0xd30 <pxPortInitialiseStack>
    1f68:	99 83       	std	Y+1, r25	; 0x01
    1f6a:	88 83       	st	Y, r24
    1f6c:	e1 14       	cp	r14, r1
    1f6e:	f1 04       	cpc	r15, r1
    1f70:	19 f0       	breq	.+6      	; 0x1f78 <xTaskCreate+0x100>
    1f72:	f7 01       	movw	r30, r14
    1f74:	d1 83       	std	Z+1, r29	; 0x01
    1f76:	c0 83       	st	Z, r28
    1f78:	0f b6       	in	r0, 0x3f	; 63
    1f7a:	f8 94       	cli
    1f7c:	0f 92       	push	r0
    1f7e:	80 91 9c 07 	lds	r24, 0x079C	; 0x80079c <uxCurrentNumberOfTasks>
    1f82:	8f 5f       	subi	r24, 0xFF	; 255
    1f84:	80 93 9c 07 	sts	0x079C, r24	; 0x80079c <uxCurrentNumberOfTasks>
    1f88:	80 91 29 08 	lds	r24, 0x0829	; 0x800829 <pxCurrentTCB>
    1f8c:	90 91 2a 08 	lds	r25, 0x082A	; 0x80082a <pxCurrentTCB+0x1>
    1f90:	89 2b       	or	r24, r25
    1f92:	d1 f5       	brne	.+116    	; 0x2008 <xTaskCreate+0x190>
    1f94:	d0 93 2a 08 	sts	0x082A, r29	; 0x80082a <pxCurrentTCB+0x1>
    1f98:	c0 93 29 08 	sts	0x0829, r28	; 0x800829 <pxCurrentTCB>
    1f9c:	80 91 9c 07 	lds	r24, 0x079C	; 0x80079c <uxCurrentNumberOfTasks>
    1fa0:	81 30       	cpi	r24, 0x01	; 1
    1fa2:	09 f0       	breq	.+2      	; 0x1fa6 <xTaskCreate+0x12e>
    1fa4:	41 c0       	rjmp	.+130    	; 0x2028 <xTaskCreate+0x1b0>
    1fa6:	0f ec       	ldi	r16, 0xCF	; 207
    1fa8:	17 e0       	ldi	r17, 0x07	; 7
    1faa:	0f 2e       	mov	r0, r31
    1fac:	f9 e2       	ldi	r31, 0x29	; 41
    1fae:	ef 2e       	mov	r14, r31
    1fb0:	f8 e0       	ldi	r31, 0x08	; 8
    1fb2:	ff 2e       	mov	r15, r31
    1fb4:	f0 2d       	mov	r31, r0
    1fb6:	c8 01       	movw	r24, r16
    1fb8:	0e 94 0e 06 	call	0xc1c	; 0xc1c <vListInitialise>
    1fbc:	07 5f       	subi	r16, 0xF7	; 247
    1fbe:	1f 4f       	sbci	r17, 0xFF	; 255
    1fc0:	0e 15       	cp	r16, r14
    1fc2:	1f 05       	cpc	r17, r15
    1fc4:	c1 f7       	brne	.-16     	; 0x1fb6 <xTaskCreate+0x13e>
    1fc6:	86 ec       	ldi	r24, 0xC6	; 198
    1fc8:	97 e0       	ldi	r25, 0x07	; 7
    1fca:	0e 94 0e 06 	call	0xc1c	; 0xc1c <vListInitialise>
    1fce:	8d eb       	ldi	r24, 0xBD	; 189
    1fd0:	97 e0       	ldi	r25, 0x07	; 7
    1fd2:	0e 94 0e 06 	call	0xc1c	; 0xc1c <vListInitialise>
    1fd6:	80 eb       	ldi	r24, 0xB0	; 176
    1fd8:	97 e0       	ldi	r25, 0x07	; 7
    1fda:	0e 94 0e 06 	call	0xc1c	; 0xc1c <vListInitialise>
    1fde:	87 ea       	ldi	r24, 0xA7	; 167
    1fe0:	97 e0       	ldi	r25, 0x07	; 7
    1fe2:	0e 94 0e 06 	call	0xc1c	; 0xc1c <vListInitialise>
    1fe6:	8d e9       	ldi	r24, 0x9D	; 157
    1fe8:	97 e0       	ldi	r25, 0x07	; 7
    1fea:	0e 94 0e 06 	call	0xc1c	; 0xc1c <vListInitialise>
    1fee:	86 ec       	ldi	r24, 0xC6	; 198
    1ff0:	97 e0       	ldi	r25, 0x07	; 7
    1ff2:	90 93 bc 07 	sts	0x07BC, r25	; 0x8007bc <pxDelayedTaskList+0x1>
    1ff6:	80 93 bb 07 	sts	0x07BB, r24	; 0x8007bb <pxDelayedTaskList>
    1ffa:	8d eb       	ldi	r24, 0xBD	; 189
    1ffc:	97 e0       	ldi	r25, 0x07	; 7
    1ffe:	90 93 ba 07 	sts	0x07BA, r25	; 0x8007ba <pxOverflowDelayedTaskList+0x1>
    2002:	80 93 b9 07 	sts	0x07B9, r24	; 0x8007b9 <pxOverflowDelayedTaskList>
    2006:	10 c0       	rjmp	.+32     	; 0x2028 <xTaskCreate+0x1b0>
    2008:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <xSchedulerRunning>
    200c:	81 11       	cpse	r24, r1
    200e:	0c c0       	rjmp	.+24     	; 0x2028 <xTaskCreate+0x1b0>
    2010:	e0 91 29 08 	lds	r30, 0x0829	; 0x800829 <pxCurrentTCB>
    2014:	f0 91 2a 08 	lds	r31, 0x082A	; 0x80082a <pxCurrentTCB+0x1>
    2018:	96 89       	ldd	r25, Z+22	; 0x16
    201a:	8e 89       	ldd	r24, Y+22	; 0x16
    201c:	89 17       	cp	r24, r25
    201e:	20 f0       	brcs	.+8      	; 0x2028 <xTaskCreate+0x1b0>
    2020:	d0 93 2a 08 	sts	0x082A, r29	; 0x80082a <pxCurrentTCB+0x1>
    2024:	c0 93 29 08 	sts	0x0829, r28	; 0x800829 <pxCurrentTCB>
    2028:	80 91 94 07 	lds	r24, 0x0794	; 0x800794 <uxTaskNumber>
    202c:	8f 5f       	subi	r24, 0xFF	; 255
    202e:	80 93 94 07 	sts	0x0794, r24	; 0x800794 <uxTaskNumber>
    2032:	8d 8f       	std	Y+29, r24	; 0x1d
    2034:	8e 89       	ldd	r24, Y+22	; 0x16
    2036:	90 91 99 07 	lds	r25, 0x0799	; 0x800799 <uxTopReadyPriority>
    203a:	98 17       	cp	r25, r24
    203c:	10 f4       	brcc	.+4      	; 0x2042 <xTaskCreate+0x1ca>
    203e:	80 93 99 07 	sts	0x0799, r24	; 0x800799 <uxTopReadyPriority>
    2042:	90 e0       	ldi	r25, 0x00	; 0
    2044:	9c 01       	movw	r18, r24
    2046:	22 0f       	add	r18, r18
    2048:	33 1f       	adc	r19, r19
    204a:	22 0f       	add	r18, r18
    204c:	33 1f       	adc	r19, r19
    204e:	22 0f       	add	r18, r18
    2050:	33 1f       	adc	r19, r19
    2052:	82 0f       	add	r24, r18
    2054:	93 1f       	adc	r25, r19
    2056:	b6 01       	movw	r22, r12
    2058:	81 53       	subi	r24, 0x31	; 49
    205a:	98 4f       	sbci	r25, 0xF8	; 248
    205c:	0e 94 20 06 	call	0xc40	; 0xc40 <vListInsertEnd>
    2060:	0f 90       	pop	r0
    2062:	0f be       	out	0x3f, r0	; 63
    2064:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <xSchedulerRunning>
    2068:	88 23       	and	r24, r24
    206a:	61 f0       	breq	.+24     	; 0x2084 <xTaskCreate+0x20c>
    206c:	e0 91 29 08 	lds	r30, 0x0829	; 0x800829 <pxCurrentTCB>
    2070:	f0 91 2a 08 	lds	r31, 0x082A	; 0x80082a <pxCurrentTCB+0x1>
    2074:	96 89       	ldd	r25, Z+22	; 0x16
    2076:	8e 89       	ldd	r24, Y+22	; 0x16
    2078:	98 17       	cp	r25, r24
    207a:	30 f4       	brcc	.+12     	; 0x2088 <xTaskCreate+0x210>
    207c:	0e 94 3e 07 	call	0xe7c	; 0xe7c <vPortYield>
    2080:	81 e0       	ldi	r24, 0x01	; 1
    2082:	05 c0       	rjmp	.+10     	; 0x208e <xTaskCreate+0x216>
    2084:	81 e0       	ldi	r24, 0x01	; 1
    2086:	03 c0       	rjmp	.+6      	; 0x208e <xTaskCreate+0x216>
    2088:	81 e0       	ldi	r24, 0x01	; 1
    208a:	01 c0       	rjmp	.+2      	; 0x208e <xTaskCreate+0x216>
    208c:	8f ef       	ldi	r24, 0xFF	; 255
    208e:	df 91       	pop	r29
    2090:	cf 91       	pop	r28
    2092:	1f 91       	pop	r17
    2094:	0f 91       	pop	r16
    2096:	ff 90       	pop	r15
    2098:	ef 90       	pop	r14
    209a:	df 90       	pop	r13
    209c:	cf 90       	pop	r12
    209e:	bf 90       	pop	r11
    20a0:	af 90       	pop	r10
    20a2:	9f 90       	pop	r9
    20a4:	8f 90       	pop	r8
    20a6:	7f 90       	pop	r7
    20a8:	6f 90       	pop	r6
    20aa:	5f 90       	pop	r5
    20ac:	4f 90       	pop	r4
    20ae:	08 95       	ret

000020b0 <vTaskStartScheduler>:
    20b0:	ef 92       	push	r14
    20b2:	ff 92       	push	r15
    20b4:	0f 93       	push	r16
    20b6:	0f 2e       	mov	r0, r31
    20b8:	f0 e9       	ldi	r31, 0x90	; 144
    20ba:	ef 2e       	mov	r14, r31
    20bc:	f7 e0       	ldi	r31, 0x07	; 7
    20be:	ff 2e       	mov	r15, r31
    20c0:	f0 2d       	mov	r31, r0
    20c2:	00 e0       	ldi	r16, 0x00	; 0
    20c4:	20 e0       	ldi	r18, 0x00	; 0
    20c6:	30 e0       	ldi	r19, 0x00	; 0
    20c8:	40 e5       	ldi	r20, 0x50	; 80
    20ca:	50 e0       	ldi	r21, 0x00	; 0
    20cc:	60 e9       	ldi	r22, 0x90	; 144
    20ce:	71 e0       	ldi	r23, 0x01	; 1
    20d0:	84 ee       	ldi	r24, 0xE4	; 228
    20d2:	91 e1       	ldi	r25, 0x11	; 17
    20d4:	0e 94 3c 0f 	call	0x1e78	; 0x1e78 <xTaskCreate>
    20d8:	81 30       	cpi	r24, 0x01	; 1
    20da:	a1 f4       	brne	.+40     	; 0x2104 <vTaskStartScheduler+0x54>
    20dc:	0e 94 7b 14 	call	0x28f6	; 0x28f6 <xTimerCreateTimerTask>
    20e0:	81 30       	cpi	r24, 0x01	; 1
    20e2:	81 f4       	brne	.+32     	; 0x2104 <vTaskStartScheduler+0x54>
    20e4:	f8 94       	cli
    20e6:	8f ef       	ldi	r24, 0xFF	; 255
    20e8:	9f ef       	ldi	r25, 0xFF	; 255
    20ea:	90 93 93 07 	sts	0x0793, r25	; 0x800793 <xNextTaskUnblockTime+0x1>
    20ee:	80 93 92 07 	sts	0x0792, r24	; 0x800792 <xNextTaskUnblockTime>
    20f2:	81 e0       	ldi	r24, 0x01	; 1
    20f4:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <xSchedulerRunning>
    20f8:	10 92 9b 07 	sts	0x079B, r1	; 0x80079b <xTickCount+0x1>
    20fc:	10 92 9a 07 	sts	0x079A, r1	; 0x80079a <xTickCount>
    2100:	0e 94 04 07 	call	0xe08	; 0xe08 <xPortStartScheduler>
    2104:	0f 91       	pop	r16
    2106:	ff 90       	pop	r15
    2108:	ef 90       	pop	r14
    210a:	08 95       	ret

0000210c <vTaskSuspendAll>:
    210c:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <uxSchedulerSuspended>
    2110:	8f 5f       	subi	r24, 0xFF	; 255
    2112:	80 93 8f 07 	sts	0x078F, r24	; 0x80078f <uxSchedulerSuspended>
    2116:	08 95       	ret

00002118 <xTaskGetTickCount>:
    2118:	0f b6       	in	r0, 0x3f	; 63
    211a:	f8 94       	cli
    211c:	0f 92       	push	r0
    211e:	80 91 9a 07 	lds	r24, 0x079A	; 0x80079a <xTickCount>
    2122:	90 91 9b 07 	lds	r25, 0x079B	; 0x80079b <xTickCount+0x1>
    2126:	0f 90       	pop	r0
    2128:	0f be       	out	0x3f, r0	; 63
    212a:	08 95       	ret

0000212c <xTaskIncrementTick>:
    212c:	cf 92       	push	r12
    212e:	df 92       	push	r13
    2130:	ef 92       	push	r14
    2132:	ff 92       	push	r15
    2134:	0f 93       	push	r16
    2136:	1f 93       	push	r17
    2138:	cf 93       	push	r28
    213a:	df 93       	push	r29
    213c:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <uxSchedulerSuspended>
    2140:	81 11       	cpse	r24, r1
    2142:	99 c0       	rjmp	.+306    	; 0x2276 <xTaskIncrementTick+0x14a>
    2144:	e0 90 9a 07 	lds	r14, 0x079A	; 0x80079a <xTickCount>
    2148:	f0 90 9b 07 	lds	r15, 0x079B	; 0x80079b <xTickCount+0x1>
    214c:	8f ef       	ldi	r24, 0xFF	; 255
    214e:	e8 1a       	sub	r14, r24
    2150:	f8 0a       	sbc	r15, r24
    2152:	f0 92 9b 07 	sts	0x079B, r15	; 0x80079b <xTickCount+0x1>
    2156:	e0 92 9a 07 	sts	0x079A, r14	; 0x80079a <xTickCount>
    215a:	e1 14       	cp	r14, r1
    215c:	f1 04       	cpc	r15, r1
    215e:	b9 f4       	brne	.+46     	; 0x218e <xTaskIncrementTick+0x62>
    2160:	80 91 bb 07 	lds	r24, 0x07BB	; 0x8007bb <pxDelayedTaskList>
    2164:	90 91 bc 07 	lds	r25, 0x07BC	; 0x8007bc <pxDelayedTaskList+0x1>
    2168:	20 91 b9 07 	lds	r18, 0x07B9	; 0x8007b9 <pxOverflowDelayedTaskList>
    216c:	30 91 ba 07 	lds	r19, 0x07BA	; 0x8007ba <pxOverflowDelayedTaskList+0x1>
    2170:	30 93 bc 07 	sts	0x07BC, r19	; 0x8007bc <pxDelayedTaskList+0x1>
    2174:	20 93 bb 07 	sts	0x07BB, r18	; 0x8007bb <pxDelayedTaskList>
    2178:	90 93 ba 07 	sts	0x07BA, r25	; 0x8007ba <pxOverflowDelayedTaskList+0x1>
    217c:	80 93 b9 07 	sts	0x07B9, r24	; 0x8007b9 <pxOverflowDelayedTaskList>
    2180:	80 91 95 07 	lds	r24, 0x0795	; 0x800795 <xNumOfOverflows>
    2184:	8f 5f       	subi	r24, 0xFF	; 255
    2186:	80 93 95 07 	sts	0x0795, r24	; 0x800795 <xNumOfOverflows>
    218a:	0e 94 c5 0e 	call	0x1d8a	; 0x1d8a <prvResetNextTaskUnblockTime>
    218e:	80 91 92 07 	lds	r24, 0x0792	; 0x800792 <xNextTaskUnblockTime>
    2192:	90 91 93 07 	lds	r25, 0x0793	; 0x800793 <xNextTaskUnblockTime+0x1>
    2196:	e8 16       	cp	r14, r24
    2198:	f9 06       	cpc	r15, r25
    219a:	10 f4       	brcc	.+4      	; 0x21a0 <xTaskIncrementTick+0x74>
    219c:	d1 2c       	mov	r13, r1
    219e:	53 c0       	rjmp	.+166    	; 0x2246 <xTaskIncrementTick+0x11a>
    21a0:	d1 2c       	mov	r13, r1
    21a2:	cc 24       	eor	r12, r12
    21a4:	c3 94       	inc	r12
    21a6:	e0 91 bb 07 	lds	r30, 0x07BB	; 0x8007bb <pxDelayedTaskList>
    21aa:	f0 91 bc 07 	lds	r31, 0x07BC	; 0x8007bc <pxDelayedTaskList+0x1>
    21ae:	80 81       	ld	r24, Z
    21b0:	81 11       	cpse	r24, r1
    21b2:	07 c0       	rjmp	.+14     	; 0x21c2 <xTaskIncrementTick+0x96>
    21b4:	8f ef       	ldi	r24, 0xFF	; 255
    21b6:	9f ef       	ldi	r25, 0xFF	; 255
    21b8:	90 93 93 07 	sts	0x0793, r25	; 0x800793 <xNextTaskUnblockTime+0x1>
    21bc:	80 93 92 07 	sts	0x0792, r24	; 0x800792 <xNextTaskUnblockTime>
    21c0:	42 c0       	rjmp	.+132    	; 0x2246 <xTaskIncrementTick+0x11a>
    21c2:	e0 91 bb 07 	lds	r30, 0x07BB	; 0x8007bb <pxDelayedTaskList>
    21c6:	f0 91 bc 07 	lds	r31, 0x07BC	; 0x8007bc <pxDelayedTaskList+0x1>
    21ca:	05 80       	ldd	r0, Z+5	; 0x05
    21cc:	f6 81       	ldd	r31, Z+6	; 0x06
    21ce:	e0 2d       	mov	r30, r0
    21d0:	c6 81       	ldd	r28, Z+6	; 0x06
    21d2:	d7 81       	ldd	r29, Z+7	; 0x07
    21d4:	8a 81       	ldd	r24, Y+2	; 0x02
    21d6:	9b 81       	ldd	r25, Y+3	; 0x03
    21d8:	e8 16       	cp	r14, r24
    21da:	f9 06       	cpc	r15, r25
    21dc:	28 f4       	brcc	.+10     	; 0x21e8 <xTaskIncrementTick+0xbc>
    21de:	90 93 93 07 	sts	0x0793, r25	; 0x800793 <xNextTaskUnblockTime+0x1>
    21e2:	80 93 92 07 	sts	0x0792, r24	; 0x800792 <xNextTaskUnblockTime>
    21e6:	2f c0       	rjmp	.+94     	; 0x2246 <xTaskIncrementTick+0x11a>
    21e8:	8e 01       	movw	r16, r28
    21ea:	0e 5f       	subi	r16, 0xFE	; 254
    21ec:	1f 4f       	sbci	r17, 0xFF	; 255
    21ee:	c8 01       	movw	r24, r16
    21f0:	0e 94 72 06 	call	0xce4	; 0xce4 <uxListRemove>
    21f4:	8c 89       	ldd	r24, Y+20	; 0x14
    21f6:	9d 89       	ldd	r25, Y+21	; 0x15
    21f8:	89 2b       	or	r24, r25
    21fa:	21 f0       	breq	.+8      	; 0x2204 <xTaskIncrementTick+0xd8>
    21fc:	ce 01       	movw	r24, r28
    21fe:	0c 96       	adiw	r24, 0x0c	; 12
    2200:	0e 94 72 06 	call	0xce4	; 0xce4 <uxListRemove>
    2204:	8e 89       	ldd	r24, Y+22	; 0x16
    2206:	90 91 99 07 	lds	r25, 0x0799	; 0x800799 <uxTopReadyPriority>
    220a:	98 17       	cp	r25, r24
    220c:	10 f4       	brcc	.+4      	; 0x2212 <xTaskIncrementTick+0xe6>
    220e:	80 93 99 07 	sts	0x0799, r24	; 0x800799 <uxTopReadyPriority>
    2212:	90 e0       	ldi	r25, 0x00	; 0
    2214:	9c 01       	movw	r18, r24
    2216:	22 0f       	add	r18, r18
    2218:	33 1f       	adc	r19, r19
    221a:	22 0f       	add	r18, r18
    221c:	33 1f       	adc	r19, r19
    221e:	22 0f       	add	r18, r18
    2220:	33 1f       	adc	r19, r19
    2222:	82 0f       	add	r24, r18
    2224:	93 1f       	adc	r25, r19
    2226:	b8 01       	movw	r22, r16
    2228:	81 53       	subi	r24, 0x31	; 49
    222a:	98 4f       	sbci	r25, 0xF8	; 248
    222c:	0e 94 20 06 	call	0xc40	; 0xc40 <vListInsertEnd>
    2230:	e0 91 29 08 	lds	r30, 0x0829	; 0x800829 <pxCurrentTCB>
    2234:	f0 91 2a 08 	lds	r31, 0x082A	; 0x80082a <pxCurrentTCB+0x1>
    2238:	9e 89       	ldd	r25, Y+22	; 0x16
    223a:	86 89       	ldd	r24, Z+22	; 0x16
    223c:	98 17       	cp	r25, r24
    223e:	08 f4       	brcc	.+2      	; 0x2242 <xTaskIncrementTick+0x116>
    2240:	b2 cf       	rjmp	.-156    	; 0x21a6 <xTaskIncrementTick+0x7a>
    2242:	dc 2c       	mov	r13, r12
    2244:	b0 cf       	rjmp	.-160    	; 0x21a6 <xTaskIncrementTick+0x7a>
    2246:	e0 91 29 08 	lds	r30, 0x0829	; 0x800829 <pxCurrentTCB>
    224a:	f0 91 2a 08 	lds	r31, 0x082A	; 0x80082a <pxCurrentTCB+0x1>
    224e:	86 89       	ldd	r24, Z+22	; 0x16
    2250:	90 e0       	ldi	r25, 0x00	; 0
    2252:	fc 01       	movw	r30, r24
    2254:	ee 0f       	add	r30, r30
    2256:	ff 1f       	adc	r31, r31
    2258:	ee 0f       	add	r30, r30
    225a:	ff 1f       	adc	r31, r31
    225c:	ee 0f       	add	r30, r30
    225e:	ff 1f       	adc	r31, r31
    2260:	8e 0f       	add	r24, r30
    2262:	9f 1f       	adc	r25, r31
    2264:	fc 01       	movw	r30, r24
    2266:	e1 53       	subi	r30, 0x31	; 49
    2268:	f8 4f       	sbci	r31, 0xF8	; 248
    226a:	80 81       	ld	r24, Z
    226c:	82 30       	cpi	r24, 0x02	; 2
    226e:	48 f0       	brcs	.+18     	; 0x2282 <xTaskIncrementTick+0x156>
    2270:	dd 24       	eor	r13, r13
    2272:	d3 94       	inc	r13
    2274:	06 c0       	rjmp	.+12     	; 0x2282 <xTaskIncrementTick+0x156>
    2276:	80 91 97 07 	lds	r24, 0x0797	; 0x800797 <uxPendedTicks>
    227a:	8f 5f       	subi	r24, 0xFF	; 255
    227c:	80 93 97 07 	sts	0x0797, r24	; 0x800797 <uxPendedTicks>
    2280:	d1 2c       	mov	r13, r1
    2282:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <xYieldPending>
    2286:	88 23       	and	r24, r24
    2288:	11 f0       	breq	.+4      	; 0x228e <xTaskIncrementTick+0x162>
    228a:	dd 24       	eor	r13, r13
    228c:	d3 94       	inc	r13
    228e:	8d 2d       	mov	r24, r13
    2290:	df 91       	pop	r29
    2292:	cf 91       	pop	r28
    2294:	1f 91       	pop	r17
    2296:	0f 91       	pop	r16
    2298:	ff 90       	pop	r15
    229a:	ef 90       	pop	r14
    229c:	df 90       	pop	r13
    229e:	cf 90       	pop	r12
    22a0:	08 95       	ret

000022a2 <xTaskResumeAll>:
    22a2:	df 92       	push	r13
    22a4:	ef 92       	push	r14
    22a6:	ff 92       	push	r15
    22a8:	0f 93       	push	r16
    22aa:	1f 93       	push	r17
    22ac:	cf 93       	push	r28
    22ae:	df 93       	push	r29
    22b0:	0f b6       	in	r0, 0x3f	; 63
    22b2:	f8 94       	cli
    22b4:	0f 92       	push	r0
    22b6:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <uxSchedulerSuspended>
    22ba:	81 50       	subi	r24, 0x01	; 1
    22bc:	80 93 8f 07 	sts	0x078F, r24	; 0x80078f <uxSchedulerSuspended>
    22c0:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <uxSchedulerSuspended>
    22c4:	81 11       	cpse	r24, r1
    22c6:	5f c0       	rjmp	.+190    	; 0x2386 <xTaskResumeAll+0xe4>
    22c8:	80 91 9c 07 	lds	r24, 0x079C	; 0x80079c <uxCurrentNumberOfTasks>
    22cc:	81 11       	cpse	r24, r1
    22ce:	33 c0       	rjmp	.+102    	; 0x2336 <xTaskResumeAll+0x94>
    22d0:	5d c0       	rjmp	.+186    	; 0x238c <xTaskResumeAll+0xea>
    22d2:	d7 01       	movw	r26, r14
    22d4:	15 96       	adiw	r26, 0x05	; 5
    22d6:	ed 91       	ld	r30, X+
    22d8:	fc 91       	ld	r31, X
    22da:	16 97       	sbiw	r26, 0x06	; 6
    22dc:	c6 81       	ldd	r28, Z+6	; 0x06
    22de:	d7 81       	ldd	r29, Z+7	; 0x07
    22e0:	ce 01       	movw	r24, r28
    22e2:	0c 96       	adiw	r24, 0x0c	; 12
    22e4:	0e 94 72 06 	call	0xce4	; 0xce4 <uxListRemove>
    22e8:	8e 01       	movw	r16, r28
    22ea:	0e 5f       	subi	r16, 0xFE	; 254
    22ec:	1f 4f       	sbci	r17, 0xFF	; 255
    22ee:	c8 01       	movw	r24, r16
    22f0:	0e 94 72 06 	call	0xce4	; 0xce4 <uxListRemove>
    22f4:	8e 89       	ldd	r24, Y+22	; 0x16
    22f6:	90 91 99 07 	lds	r25, 0x0799	; 0x800799 <uxTopReadyPriority>
    22fa:	98 17       	cp	r25, r24
    22fc:	10 f4       	brcc	.+4      	; 0x2302 <xTaskResumeAll+0x60>
    22fe:	80 93 99 07 	sts	0x0799, r24	; 0x800799 <uxTopReadyPriority>
    2302:	90 e0       	ldi	r25, 0x00	; 0
    2304:	9c 01       	movw	r18, r24
    2306:	22 0f       	add	r18, r18
    2308:	33 1f       	adc	r19, r19
    230a:	22 0f       	add	r18, r18
    230c:	33 1f       	adc	r19, r19
    230e:	22 0f       	add	r18, r18
    2310:	33 1f       	adc	r19, r19
    2312:	82 0f       	add	r24, r18
    2314:	93 1f       	adc	r25, r19
    2316:	b8 01       	movw	r22, r16
    2318:	81 53       	subi	r24, 0x31	; 49
    231a:	98 4f       	sbci	r25, 0xF8	; 248
    231c:	0e 94 20 06 	call	0xc40	; 0xc40 <vListInsertEnd>
    2320:	e0 91 29 08 	lds	r30, 0x0829	; 0x800829 <pxCurrentTCB>
    2324:	f0 91 2a 08 	lds	r31, 0x082A	; 0x80082a <pxCurrentTCB+0x1>
    2328:	9e 89       	ldd	r25, Y+22	; 0x16
    232a:	86 89       	ldd	r24, Z+22	; 0x16
    232c:	98 17       	cp	r25, r24
    232e:	68 f0       	brcs	.+26     	; 0x234a <xTaskResumeAll+0xa8>
    2330:	d0 92 96 07 	sts	0x0796, r13	; 0x800796 <xYieldPending>
    2334:	0a c0       	rjmp	.+20     	; 0x234a <xTaskResumeAll+0xa8>
    2336:	c0 e0       	ldi	r28, 0x00	; 0
    2338:	d0 e0       	ldi	r29, 0x00	; 0
    233a:	0f 2e       	mov	r0, r31
    233c:	f0 eb       	ldi	r31, 0xB0	; 176
    233e:	ef 2e       	mov	r14, r31
    2340:	f7 e0       	ldi	r31, 0x07	; 7
    2342:	ff 2e       	mov	r15, r31
    2344:	f0 2d       	mov	r31, r0
    2346:	dd 24       	eor	r13, r13
    2348:	d3 94       	inc	r13
    234a:	f7 01       	movw	r30, r14
    234c:	80 81       	ld	r24, Z
    234e:	81 11       	cpse	r24, r1
    2350:	c0 cf       	rjmp	.-128    	; 0x22d2 <xTaskResumeAll+0x30>
    2352:	cd 2b       	or	r28, r29
    2354:	11 f0       	breq	.+4      	; 0x235a <xTaskResumeAll+0xb8>
    2356:	0e 94 c5 0e 	call	0x1d8a	; 0x1d8a <prvResetNextTaskUnblockTime>
    235a:	c0 91 97 07 	lds	r28, 0x0797	; 0x800797 <uxPendedTicks>
    235e:	cc 23       	and	r28, r28
    2360:	51 f0       	breq	.+20     	; 0x2376 <xTaskResumeAll+0xd4>
    2362:	d1 e0       	ldi	r29, 0x01	; 1
    2364:	0e 94 96 10 	call	0x212c	; 0x212c <xTaskIncrementTick>
    2368:	81 11       	cpse	r24, r1
    236a:	d0 93 96 07 	sts	0x0796, r29	; 0x800796 <xYieldPending>
    236e:	c1 50       	subi	r28, 0x01	; 1
    2370:	c9 f7       	brne	.-14     	; 0x2364 <xTaskResumeAll+0xc2>
    2372:	10 92 97 07 	sts	0x0797, r1	; 0x800797 <uxPendedTicks>
    2376:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <xYieldPending>
    237a:	88 23       	and	r24, r24
    237c:	31 f0       	breq	.+12     	; 0x238a <xTaskResumeAll+0xe8>
    237e:	0e 94 3e 07 	call	0xe7c	; 0xe7c <vPortYield>
    2382:	81 e0       	ldi	r24, 0x01	; 1
    2384:	03 c0       	rjmp	.+6      	; 0x238c <xTaskResumeAll+0xea>
    2386:	80 e0       	ldi	r24, 0x00	; 0
    2388:	01 c0       	rjmp	.+2      	; 0x238c <xTaskResumeAll+0xea>
    238a:	80 e0       	ldi	r24, 0x00	; 0
    238c:	0f 90       	pop	r0
    238e:	0f be       	out	0x3f, r0	; 63
    2390:	df 91       	pop	r29
    2392:	cf 91       	pop	r28
    2394:	1f 91       	pop	r17
    2396:	0f 91       	pop	r16
    2398:	ff 90       	pop	r15
    239a:	ef 90       	pop	r14
    239c:	df 90       	pop	r13
    239e:	08 95       	ret

000023a0 <vTaskDelay>:
    23a0:	cf 93       	push	r28
    23a2:	df 93       	push	r29
    23a4:	ec 01       	movw	r28, r24
    23a6:	89 2b       	or	r24, r25
    23a8:	51 f0       	breq	.+20     	; 0x23be <vTaskDelay+0x1e>
    23aa:	0e 94 86 10 	call	0x210c	; 0x210c <vTaskSuspendAll>
    23ae:	60 e0       	ldi	r22, 0x00	; 0
    23b0:	ce 01       	movw	r24, r28
    23b2:	0e 94 e4 0e 	call	0x1dc8	; 0x1dc8 <prvAddCurrentTaskToDelayedList>
    23b6:	0e 94 51 11 	call	0x22a2	; 0x22a2 <xTaskResumeAll>
    23ba:	81 11       	cpse	r24, r1
    23bc:	02 c0       	rjmp	.+4      	; 0x23c2 <vTaskDelay+0x22>
    23be:	0e 94 3e 07 	call	0xe7c	; 0xe7c <vPortYield>
    23c2:	df 91       	pop	r29
    23c4:	cf 91       	pop	r28
    23c6:	08 95       	ret

000023c8 <prvIdleTask>:
    23c8:	07 ea       	ldi	r16, 0xA7	; 167
    23ca:	17 e0       	ldi	r17, 0x07	; 7
    23cc:	0f 2e       	mov	r0, r31
    23ce:	ff ec       	ldi	r31, 0xCF	; 207
    23d0:	ef 2e       	mov	r14, r31
    23d2:	f7 e0       	ldi	r31, 0x07	; 7
    23d4:	ff 2e       	mov	r15, r31
    23d6:	f0 2d       	mov	r31, r0
    23d8:	29 c0       	rjmp	.+82     	; 0x242c <prvIdleTask+0x64>
    23da:	0e 94 86 10 	call	0x210c	; 0x210c <vTaskSuspendAll>
    23de:	d8 01       	movw	r26, r16
    23e0:	cc 91       	ld	r28, X
    23e2:	0e 94 51 11 	call	0x22a2	; 0x22a2 <xTaskResumeAll>
    23e6:	cc 23       	and	r28, r28
    23e8:	09 f1       	breq	.+66     	; 0x242c <prvIdleTask+0x64>
    23ea:	0f b6       	in	r0, 0x3f	; 63
    23ec:	f8 94       	cli
    23ee:	0f 92       	push	r0
    23f0:	d8 01       	movw	r26, r16
    23f2:	15 96       	adiw	r26, 0x05	; 5
    23f4:	ed 91       	ld	r30, X+
    23f6:	fc 91       	ld	r31, X
    23f8:	16 97       	sbiw	r26, 0x06	; 6
    23fa:	c6 81       	ldd	r28, Z+6	; 0x06
    23fc:	d7 81       	ldd	r29, Z+7	; 0x07
    23fe:	ce 01       	movw	r24, r28
    2400:	02 96       	adiw	r24, 0x02	; 2
    2402:	0e 94 72 06 	call	0xce4	; 0xce4 <uxListRemove>
    2406:	80 91 9c 07 	lds	r24, 0x079C	; 0x80079c <uxCurrentNumberOfTasks>
    240a:	81 50       	subi	r24, 0x01	; 1
    240c:	80 93 9c 07 	sts	0x079C, r24	; 0x80079c <uxCurrentNumberOfTasks>
    2410:	80 91 a6 07 	lds	r24, 0x07A6	; 0x8007a6 <uxDeletedTasksWaitingCleanUp>
    2414:	81 50       	subi	r24, 0x01	; 1
    2416:	80 93 a6 07 	sts	0x07A6, r24	; 0x8007a6 <uxDeletedTasksWaitingCleanUp>
    241a:	0f 90       	pop	r0
    241c:	0f be       	out	0x3f, r0	; 63
    241e:	8f 89       	ldd	r24, Y+23	; 0x17
    2420:	98 8d       	ldd	r25, Y+24	; 0x18
    2422:	0e 94 2b 08 	call	0x1056	; 0x1056 <vPortFree>
    2426:	ce 01       	movw	r24, r28
    2428:	0e 94 2b 08 	call	0x1056	; 0x1056 <vPortFree>
    242c:	80 91 a6 07 	lds	r24, 0x07A6	; 0x8007a6 <uxDeletedTasksWaitingCleanUp>
    2430:	81 11       	cpse	r24, r1
    2432:	d3 cf       	rjmp	.-90     	; 0x23da <prvIdleTask+0x12>
    2434:	f7 01       	movw	r30, r14
    2436:	80 81       	ld	r24, Z
    2438:	82 30       	cpi	r24, 0x02	; 2
    243a:	10 f0       	brcs	.+4      	; 0x2440 <prvIdleTask+0x78>
    243c:	0e 94 3e 07 	call	0xe7c	; 0xe7c <vPortYield>
    2440:	0e 94 05 05 	call	0xa0a	; 0xa0a <vApplicationIdleHook>
    2444:	f3 cf       	rjmp	.-26     	; 0x242c <prvIdleTask+0x64>

00002446 <vTaskSetApplicationTaskTag>:
    2446:	00 97       	sbiw	r24, 0x00	; 0
    2448:	21 f4       	brne	.+8      	; 0x2452 <vTaskSetApplicationTaskTag+0xc>
    244a:	80 91 29 08 	lds	r24, 0x0829	; 0x800829 <pxCurrentTCB>
    244e:	90 91 2a 08 	lds	r25, 0x082A	; 0x80082a <pxCurrentTCB+0x1>
    2452:	0f b6       	in	r0, 0x3f	; 63
    2454:	f8 94       	cli
    2456:	0f 92       	push	r0
    2458:	fc 01       	movw	r30, r24
    245a:	72 a3       	std	Z+34, r23	; 0x22
    245c:	61 a3       	std	Z+33, r22	; 0x21
    245e:	0f 90       	pop	r0
    2460:	0f be       	out	0x3f, r0	; 63
    2462:	08 95       	ret

00002464 <vTaskSwitchContext>:
    2464:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <uxSchedulerSuspended>
    2468:	88 23       	and	r24, r24
    246a:	21 f0       	breq	.+8      	; 0x2474 <vTaskSwitchContext+0x10>
    246c:	81 e0       	ldi	r24, 0x01	; 1
    246e:	80 93 96 07 	sts	0x0796, r24	; 0x800796 <xYieldPending>
    2472:	08 95       	ret
    2474:	10 92 96 07 	sts	0x0796, r1	; 0x800796 <xYieldPending>
    2478:	e0 91 29 08 	lds	r30, 0x0829	; 0x800829 <pxCurrentTCB>
    247c:	f0 91 2a 08 	lds	r31, 0x082A	; 0x80082a <pxCurrentTCB+0x1>
    2480:	81 a1       	ldd	r24, Z+33	; 0x21
    2482:	0e 94 c7 05 	call	0xb8e	; 0xb8e <switch_out>
    2486:	20 91 99 07 	lds	r18, 0x0799	; 0x800799 <uxTopReadyPriority>
    248a:	82 2f       	mov	r24, r18
    248c:	90 e0       	ldi	r25, 0x00	; 0
    248e:	fc 01       	movw	r30, r24
    2490:	ee 0f       	add	r30, r30
    2492:	ff 1f       	adc	r31, r31
    2494:	ee 0f       	add	r30, r30
    2496:	ff 1f       	adc	r31, r31
    2498:	ee 0f       	add	r30, r30
    249a:	ff 1f       	adc	r31, r31
    249c:	e8 0f       	add	r30, r24
    249e:	f9 1f       	adc	r31, r25
    24a0:	e1 53       	subi	r30, 0x31	; 49
    24a2:	f8 4f       	sbci	r31, 0xF8	; 248
    24a4:	30 81       	ld	r19, Z
    24a6:	31 11       	cpse	r19, r1
    24a8:	11 c0       	rjmp	.+34     	; 0x24cc <vTaskSwitchContext+0x68>
    24aa:	21 50       	subi	r18, 0x01	; 1
    24ac:	82 2f       	mov	r24, r18
    24ae:	90 e0       	ldi	r25, 0x00	; 0
    24b0:	fc 01       	movw	r30, r24
    24b2:	ee 0f       	add	r30, r30
    24b4:	ff 1f       	adc	r31, r31
    24b6:	ee 0f       	add	r30, r30
    24b8:	ff 1f       	adc	r31, r31
    24ba:	ee 0f       	add	r30, r30
    24bc:	ff 1f       	adc	r31, r31
    24be:	e8 0f       	add	r30, r24
    24c0:	f9 1f       	adc	r31, r25
    24c2:	e1 53       	subi	r30, 0x31	; 49
    24c4:	f8 4f       	sbci	r31, 0xF8	; 248
    24c6:	30 81       	ld	r19, Z
    24c8:	33 23       	and	r19, r19
    24ca:	79 f3       	breq	.-34     	; 0x24aa <vTaskSwitchContext+0x46>
    24cc:	ac 01       	movw	r20, r24
    24ce:	44 0f       	add	r20, r20
    24d0:	55 1f       	adc	r21, r21
    24d2:	44 0f       	add	r20, r20
    24d4:	55 1f       	adc	r21, r21
    24d6:	44 0f       	add	r20, r20
    24d8:	55 1f       	adc	r21, r21
    24da:	48 0f       	add	r20, r24
    24dc:	59 1f       	adc	r21, r25
    24de:	da 01       	movw	r26, r20
    24e0:	a1 53       	subi	r26, 0x31	; 49
    24e2:	b8 4f       	sbci	r27, 0xF8	; 248
    24e4:	11 96       	adiw	r26, 0x01	; 1
    24e6:	ed 91       	ld	r30, X+
    24e8:	fc 91       	ld	r31, X
    24ea:	12 97       	sbiw	r26, 0x02	; 2
    24ec:	02 80       	ldd	r0, Z+2	; 0x02
    24ee:	f3 81       	ldd	r31, Z+3	; 0x03
    24f0:	e0 2d       	mov	r30, r0
    24f2:	12 96       	adiw	r26, 0x02	; 2
    24f4:	fc 93       	st	X, r31
    24f6:	ee 93       	st	-X, r30
    24f8:	11 97       	sbiw	r26, 0x01	; 1
    24fa:	4e 52       	subi	r20, 0x2E	; 46
    24fc:	58 4f       	sbci	r21, 0xF8	; 248
    24fe:	e4 17       	cp	r30, r20
    2500:	f5 07       	cpc	r31, r21
    2502:	29 f4       	brne	.+10     	; 0x250e <vTaskSwitchContext+0xaa>
    2504:	42 81       	ldd	r20, Z+2	; 0x02
    2506:	53 81       	ldd	r21, Z+3	; 0x03
    2508:	fd 01       	movw	r30, r26
    250a:	52 83       	std	Z+2, r21	; 0x02
    250c:	41 83       	std	Z+1, r20	; 0x01
    250e:	fc 01       	movw	r30, r24
    2510:	ee 0f       	add	r30, r30
    2512:	ff 1f       	adc	r31, r31
    2514:	ee 0f       	add	r30, r30
    2516:	ff 1f       	adc	r31, r31
    2518:	ee 0f       	add	r30, r30
    251a:	ff 1f       	adc	r31, r31
    251c:	8e 0f       	add	r24, r30
    251e:	9f 1f       	adc	r25, r31
    2520:	fc 01       	movw	r30, r24
    2522:	e1 53       	subi	r30, 0x31	; 49
    2524:	f8 4f       	sbci	r31, 0xF8	; 248
    2526:	01 80       	ldd	r0, Z+1	; 0x01
    2528:	f2 81       	ldd	r31, Z+2	; 0x02
    252a:	e0 2d       	mov	r30, r0
    252c:	86 81       	ldd	r24, Z+6	; 0x06
    252e:	97 81       	ldd	r25, Z+7	; 0x07
    2530:	90 93 2a 08 	sts	0x082A, r25	; 0x80082a <pxCurrentTCB+0x1>
    2534:	80 93 29 08 	sts	0x0829, r24	; 0x800829 <pxCurrentTCB>
    2538:	20 93 99 07 	sts	0x0799, r18	; 0x800799 <uxTopReadyPriority>
    253c:	e0 91 29 08 	lds	r30, 0x0829	; 0x800829 <pxCurrentTCB>
    2540:	f0 91 2a 08 	lds	r31, 0x082A	; 0x80082a <pxCurrentTCB+0x1>
    2544:	81 a1       	ldd	r24, Z+33	; 0x21
    2546:	0e 94 bc 05 	call	0xb78	; 0xb78 <switch_in>
    254a:	08 95       	ret

0000254c <vTaskPlaceOnEventList>:
    254c:	cf 93       	push	r28
    254e:	df 93       	push	r29
    2550:	eb 01       	movw	r28, r22
    2552:	60 91 29 08 	lds	r22, 0x0829	; 0x800829 <pxCurrentTCB>
    2556:	70 91 2a 08 	lds	r23, 0x082A	; 0x80082a <pxCurrentTCB+0x1>
    255a:	64 5f       	subi	r22, 0xF4	; 244
    255c:	7f 4f       	sbci	r23, 0xFF	; 255
    255e:	0e 94 41 06 	call	0xc82	; 0xc82 <vListInsert>
    2562:	61 e0       	ldi	r22, 0x01	; 1
    2564:	ce 01       	movw	r24, r28
    2566:	0e 94 e4 0e 	call	0x1dc8	; 0x1dc8 <prvAddCurrentTaskToDelayedList>
    256a:	df 91       	pop	r29
    256c:	cf 91       	pop	r28
    256e:	08 95       	ret

00002570 <vTaskPlaceOnEventListRestricted>:
    2570:	0f 93       	push	r16
    2572:	1f 93       	push	r17
    2574:	cf 93       	push	r28
    2576:	8b 01       	movw	r16, r22
    2578:	c4 2f       	mov	r28, r20
    257a:	60 91 29 08 	lds	r22, 0x0829	; 0x800829 <pxCurrentTCB>
    257e:	70 91 2a 08 	lds	r23, 0x082A	; 0x80082a <pxCurrentTCB+0x1>
    2582:	64 5f       	subi	r22, 0xF4	; 244
    2584:	7f 4f       	sbci	r23, 0xFF	; 255
    2586:	0e 94 20 06 	call	0xc40	; 0xc40 <vListInsertEnd>
    258a:	cc 23       	and	r28, r28
    258c:	11 f0       	breq	.+4      	; 0x2592 <vTaskPlaceOnEventListRestricted+0x22>
    258e:	0f ef       	ldi	r16, 0xFF	; 255
    2590:	1f ef       	ldi	r17, 0xFF	; 255
    2592:	6c 2f       	mov	r22, r28
    2594:	c8 01       	movw	r24, r16
    2596:	0e 94 e4 0e 	call	0x1dc8	; 0x1dc8 <prvAddCurrentTaskToDelayedList>
    259a:	cf 91       	pop	r28
    259c:	1f 91       	pop	r17
    259e:	0f 91       	pop	r16
    25a0:	08 95       	ret

000025a2 <xTaskRemoveFromEventList>:
    25a2:	0f 93       	push	r16
    25a4:	1f 93       	push	r17
    25a6:	cf 93       	push	r28
    25a8:	df 93       	push	r29
    25aa:	dc 01       	movw	r26, r24
    25ac:	15 96       	adiw	r26, 0x05	; 5
    25ae:	ed 91       	ld	r30, X+
    25b0:	fc 91       	ld	r31, X
    25b2:	16 97       	sbiw	r26, 0x06	; 6
    25b4:	c6 81       	ldd	r28, Z+6	; 0x06
    25b6:	d7 81       	ldd	r29, Z+7	; 0x07
    25b8:	8e 01       	movw	r16, r28
    25ba:	04 5f       	subi	r16, 0xF4	; 244
    25bc:	1f 4f       	sbci	r17, 0xFF	; 255
    25be:	c8 01       	movw	r24, r16
    25c0:	0e 94 72 06 	call	0xce4	; 0xce4 <uxListRemove>
    25c4:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <uxSchedulerSuspended>
    25c8:	81 11       	cpse	r24, r1
    25ca:	1c c0       	rjmp	.+56     	; 0x2604 <xTaskRemoveFromEventList+0x62>
    25cc:	0a 50       	subi	r16, 0x0A	; 10
    25ce:	11 09       	sbc	r17, r1
    25d0:	c8 01       	movw	r24, r16
    25d2:	0e 94 72 06 	call	0xce4	; 0xce4 <uxListRemove>
    25d6:	8e 89       	ldd	r24, Y+22	; 0x16
    25d8:	90 91 99 07 	lds	r25, 0x0799	; 0x800799 <uxTopReadyPriority>
    25dc:	98 17       	cp	r25, r24
    25de:	10 f4       	brcc	.+4      	; 0x25e4 <xTaskRemoveFromEventList+0x42>
    25e0:	80 93 99 07 	sts	0x0799, r24	; 0x800799 <uxTopReadyPriority>
    25e4:	90 e0       	ldi	r25, 0x00	; 0
    25e6:	9c 01       	movw	r18, r24
    25e8:	22 0f       	add	r18, r18
    25ea:	33 1f       	adc	r19, r19
    25ec:	22 0f       	add	r18, r18
    25ee:	33 1f       	adc	r19, r19
    25f0:	22 0f       	add	r18, r18
    25f2:	33 1f       	adc	r19, r19
    25f4:	82 0f       	add	r24, r18
    25f6:	93 1f       	adc	r25, r19
    25f8:	b8 01       	movw	r22, r16
    25fa:	81 53       	subi	r24, 0x31	; 49
    25fc:	98 4f       	sbci	r25, 0xF8	; 248
    25fe:	0e 94 20 06 	call	0xc40	; 0xc40 <vListInsertEnd>
    2602:	05 c0       	rjmp	.+10     	; 0x260e <xTaskRemoveFromEventList+0x6c>
    2604:	b8 01       	movw	r22, r16
    2606:	80 eb       	ldi	r24, 0xB0	; 176
    2608:	97 e0       	ldi	r25, 0x07	; 7
    260a:	0e 94 20 06 	call	0xc40	; 0xc40 <vListInsertEnd>
    260e:	e0 91 29 08 	lds	r30, 0x0829	; 0x800829 <pxCurrentTCB>
    2612:	f0 91 2a 08 	lds	r31, 0x082A	; 0x80082a <pxCurrentTCB+0x1>
    2616:	9e 89       	ldd	r25, Y+22	; 0x16
    2618:	86 89       	ldd	r24, Z+22	; 0x16
    261a:	89 17       	cp	r24, r25
    261c:	20 f4       	brcc	.+8      	; 0x2626 <xTaskRemoveFromEventList+0x84>
    261e:	81 e0       	ldi	r24, 0x01	; 1
    2620:	80 93 96 07 	sts	0x0796, r24	; 0x800796 <xYieldPending>
    2624:	01 c0       	rjmp	.+2      	; 0x2628 <xTaskRemoveFromEventList+0x86>
    2626:	80 e0       	ldi	r24, 0x00	; 0
    2628:	df 91       	pop	r29
    262a:	cf 91       	pop	r28
    262c:	1f 91       	pop	r17
    262e:	0f 91       	pop	r16
    2630:	08 95       	ret

00002632 <vTaskSetTimeOutState>:
    2632:	20 91 95 07 	lds	r18, 0x0795	; 0x800795 <xNumOfOverflows>
    2636:	fc 01       	movw	r30, r24
    2638:	20 83       	st	Z, r18
    263a:	20 91 9a 07 	lds	r18, 0x079A	; 0x80079a <xTickCount>
    263e:	30 91 9b 07 	lds	r19, 0x079B	; 0x80079b <xTickCount+0x1>
    2642:	32 83       	std	Z+2, r19	; 0x02
    2644:	21 83       	std	Z+1, r18	; 0x01
    2646:	08 95       	ret

00002648 <xTaskCheckForTimeOut>:
    2648:	0f b6       	in	r0, 0x3f	; 63
    264a:	f8 94       	cli
    264c:	0f 92       	push	r0
    264e:	40 91 9a 07 	lds	r20, 0x079A	; 0x80079a <xTickCount>
    2652:	50 91 9b 07 	lds	r21, 0x079B	; 0x80079b <xTickCount+0x1>
    2656:	db 01       	movw	r26, r22
    2658:	2d 91       	ld	r18, X+
    265a:	3c 91       	ld	r19, X
    265c:	2f 3f       	cpi	r18, 0xFF	; 255
    265e:	bf ef       	ldi	r27, 0xFF	; 255
    2660:	3b 07       	cpc	r19, r27
    2662:	19 f1       	breq	.+70     	; 0x26aa <xTaskCheckForTimeOut+0x62>
    2664:	e0 91 95 07 	lds	r30, 0x0795	; 0x800795 <xNumOfOverflows>
    2668:	dc 01       	movw	r26, r24
    266a:	fc 91       	ld	r31, X
    266c:	fe 17       	cp	r31, r30
    266e:	39 f0       	breq	.+14     	; 0x267e <xTaskCheckForTimeOut+0x36>
    2670:	11 96       	adiw	r26, 0x01	; 1
    2672:	ed 91       	ld	r30, X+
    2674:	fc 91       	ld	r31, X
    2676:	12 97       	sbiw	r26, 0x02	; 2
    2678:	4e 17       	cp	r20, r30
    267a:	5f 07       	cpc	r21, r31
    267c:	c0 f4       	brcc	.+48     	; 0x26ae <xTaskCheckForTimeOut+0x66>
    267e:	dc 01       	movw	r26, r24
    2680:	11 96       	adiw	r26, 0x01	; 1
    2682:	ed 91       	ld	r30, X+
    2684:	fc 91       	ld	r31, X
    2686:	12 97       	sbiw	r26, 0x02	; 2
    2688:	da 01       	movw	r26, r20
    268a:	ae 1b       	sub	r26, r30
    268c:	bf 0b       	sbc	r27, r31
    268e:	a2 17       	cp	r26, r18
    2690:	b3 07       	cpc	r27, r19
    2692:	78 f4       	brcc	.+30     	; 0x26b2 <xTaskCheckForTimeOut+0x6a>
    2694:	db 01       	movw	r26, r22
    2696:	e4 1b       	sub	r30, r20
    2698:	f5 0b       	sbc	r31, r21
    269a:	2e 0f       	add	r18, r30
    269c:	3f 1f       	adc	r19, r31
    269e:	2d 93       	st	X+, r18
    26a0:	3c 93       	st	X, r19
    26a2:	0e 94 19 13 	call	0x2632	; 0x2632 <vTaskSetTimeOutState>
    26a6:	80 e0       	ldi	r24, 0x00	; 0
    26a8:	05 c0       	rjmp	.+10     	; 0x26b4 <xTaskCheckForTimeOut+0x6c>
    26aa:	80 e0       	ldi	r24, 0x00	; 0
    26ac:	03 c0       	rjmp	.+6      	; 0x26b4 <xTaskCheckForTimeOut+0x6c>
    26ae:	81 e0       	ldi	r24, 0x01	; 1
    26b0:	01 c0       	rjmp	.+2      	; 0x26b4 <xTaskCheckForTimeOut+0x6c>
    26b2:	81 e0       	ldi	r24, 0x01	; 1
    26b4:	0f 90       	pop	r0
    26b6:	0f be       	out	0x3f, r0	; 63
    26b8:	08 95       	ret

000026ba <vTaskMissedYield>:
    26ba:	81 e0       	ldi	r24, 0x01	; 1
    26bc:	80 93 96 07 	sts	0x0796, r24	; 0x800796 <xYieldPending>
    26c0:	08 95       	ret

000026c2 <xTaskGetSchedulerState>:
    26c2:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <xSchedulerRunning>
    26c6:	88 23       	and	r24, r24
    26c8:	31 f0       	breq	.+12     	; 0x26d6 <xTaskGetSchedulerState+0x14>
    26ca:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <uxSchedulerSuspended>
    26ce:	88 23       	and	r24, r24
    26d0:	21 f0       	breq	.+8      	; 0x26da <xTaskGetSchedulerState+0x18>
    26d2:	80 e0       	ldi	r24, 0x00	; 0
    26d4:	08 95       	ret
    26d6:	81 e0       	ldi	r24, 0x01	; 1
    26d8:	08 95       	ret
    26da:	82 e0       	ldi	r24, 0x02	; 2
    26dc:	08 95       	ret

000026de <vTaskPriorityInherit>:
    26de:	0f 93       	push	r16
    26e0:	1f 93       	push	r17
    26e2:	cf 93       	push	r28
    26e4:	df 93       	push	r29
    26e6:	fc 01       	movw	r30, r24
    26e8:	89 2b       	or	r24, r25
    26ea:	09 f4       	brne	.+2      	; 0x26ee <vTaskPriorityInherit+0x10>
    26ec:	55 c0       	rjmp	.+170    	; 0x2798 <vTaskPriorityInherit+0xba>
    26ee:	26 89       	ldd	r18, Z+22	; 0x16
    26f0:	a0 91 29 08 	lds	r26, 0x0829	; 0x800829 <pxCurrentTCB>
    26f4:	b0 91 2a 08 	lds	r27, 0x082A	; 0x80082a <pxCurrentTCB+0x1>
    26f8:	56 96       	adiw	r26, 0x16	; 22
    26fa:	8c 91       	ld	r24, X
    26fc:	28 17       	cp	r18, r24
    26fe:	08 f0       	brcs	.+2      	; 0x2702 <vTaskPriorityInherit+0x24>
    2700:	4b c0       	rjmp	.+150    	; 0x2798 <vTaskPriorityInherit+0xba>
    2702:	84 85       	ldd	r24, Z+12	; 0x0c
    2704:	95 85       	ldd	r25, Z+13	; 0x0d
    2706:	99 23       	and	r25, r25
    2708:	64 f0       	brlt	.+24     	; 0x2722 <vTaskPriorityInherit+0x44>
    270a:	a0 91 29 08 	lds	r26, 0x0829	; 0x800829 <pxCurrentTCB>
    270e:	b0 91 2a 08 	lds	r27, 0x082A	; 0x80082a <pxCurrentTCB+0x1>
    2712:	56 96       	adiw	r26, 0x16	; 22
    2714:	3c 91       	ld	r19, X
    2716:	8a e0       	ldi	r24, 0x0A	; 10
    2718:	90 e0       	ldi	r25, 0x00	; 0
    271a:	83 1b       	sub	r24, r19
    271c:	91 09       	sbc	r25, r1
    271e:	95 87       	std	Z+13, r25	; 0x0d
    2720:	84 87       	std	Z+12, r24	; 0x0c
    2722:	30 e0       	ldi	r19, 0x00	; 0
    2724:	c9 01       	movw	r24, r18
    2726:	88 0f       	add	r24, r24
    2728:	99 1f       	adc	r25, r25
    272a:	88 0f       	add	r24, r24
    272c:	99 1f       	adc	r25, r25
    272e:	88 0f       	add	r24, r24
    2730:	99 1f       	adc	r25, r25
    2732:	28 0f       	add	r18, r24
    2734:	39 1f       	adc	r19, r25
    2736:	21 53       	subi	r18, 0x31	; 49
    2738:	38 4f       	sbci	r19, 0xF8	; 248
    273a:	82 85       	ldd	r24, Z+10	; 0x0a
    273c:	93 85       	ldd	r25, Z+11	; 0x0b
    273e:	82 17       	cp	r24, r18
    2740:	93 07       	cpc	r25, r19
    2742:	19 f5       	brne	.+70     	; 0x278a <vTaskPriorityInherit+0xac>
    2744:	8f 01       	movw	r16, r30
    2746:	ef 01       	movw	r28, r30
    2748:	22 96       	adiw	r28, 0x02	; 2
    274a:	ce 01       	movw	r24, r28
    274c:	0e 94 72 06 	call	0xce4	; 0xce4 <uxListRemove>
    2750:	e0 91 29 08 	lds	r30, 0x0829	; 0x800829 <pxCurrentTCB>
    2754:	f0 91 2a 08 	lds	r31, 0x082A	; 0x80082a <pxCurrentTCB+0x1>
    2758:	86 89       	ldd	r24, Z+22	; 0x16
    275a:	f8 01       	movw	r30, r16
    275c:	86 8b       	std	Z+22, r24	; 0x16
    275e:	90 91 99 07 	lds	r25, 0x0799	; 0x800799 <uxTopReadyPriority>
    2762:	98 17       	cp	r25, r24
    2764:	10 f4       	brcc	.+4      	; 0x276a <vTaskPriorityInherit+0x8c>
    2766:	80 93 99 07 	sts	0x0799, r24	; 0x800799 <uxTopReadyPriority>
    276a:	90 e0       	ldi	r25, 0x00	; 0
    276c:	9c 01       	movw	r18, r24
    276e:	22 0f       	add	r18, r18
    2770:	33 1f       	adc	r19, r19
    2772:	22 0f       	add	r18, r18
    2774:	33 1f       	adc	r19, r19
    2776:	22 0f       	add	r18, r18
    2778:	33 1f       	adc	r19, r19
    277a:	82 0f       	add	r24, r18
    277c:	93 1f       	adc	r25, r19
    277e:	be 01       	movw	r22, r28
    2780:	81 53       	subi	r24, 0x31	; 49
    2782:	98 4f       	sbci	r25, 0xF8	; 248
    2784:	0e 94 20 06 	call	0xc40	; 0xc40 <vListInsertEnd>
    2788:	07 c0       	rjmp	.+14     	; 0x2798 <vTaskPriorityInherit+0xba>
    278a:	a0 91 29 08 	lds	r26, 0x0829	; 0x800829 <pxCurrentTCB>
    278e:	b0 91 2a 08 	lds	r27, 0x082A	; 0x80082a <pxCurrentTCB+0x1>
    2792:	56 96       	adiw	r26, 0x16	; 22
    2794:	8c 91       	ld	r24, X
    2796:	86 8b       	std	Z+22, r24	; 0x16
    2798:	df 91       	pop	r29
    279a:	cf 91       	pop	r28
    279c:	1f 91       	pop	r17
    279e:	0f 91       	pop	r16
    27a0:	08 95       	ret

000027a2 <xTaskPriorityDisinherit>:
    27a2:	0f 93       	push	r16
    27a4:	1f 93       	push	r17
    27a6:	cf 93       	push	r28
    27a8:	df 93       	push	r29
    27aa:	fc 01       	movw	r30, r24
    27ac:	89 2b       	or	r24, r25
    27ae:	79 f1       	breq	.+94     	; 0x280e <xTaskPriorityDisinherit+0x6c>
    27b0:	80 a1       	ldd	r24, Z+32	; 0x20
    27b2:	81 50       	subi	r24, 0x01	; 1
    27b4:	80 a3       	std	Z+32, r24	; 0x20
    27b6:	26 89       	ldd	r18, Z+22	; 0x16
    27b8:	97 8d       	ldd	r25, Z+31	; 0x1f
    27ba:	29 17       	cp	r18, r25
    27bc:	51 f1       	breq	.+84     	; 0x2812 <xTaskPriorityDisinherit+0x70>
    27be:	81 11       	cpse	r24, r1
    27c0:	2a c0       	rjmp	.+84     	; 0x2816 <xTaskPriorityDisinherit+0x74>
    27c2:	ef 01       	movw	r28, r30
    27c4:	8f 01       	movw	r16, r30
    27c6:	0e 5f       	subi	r16, 0xFE	; 254
    27c8:	1f 4f       	sbci	r17, 0xFF	; 255
    27ca:	c8 01       	movw	r24, r16
    27cc:	0e 94 72 06 	call	0xce4	; 0xce4 <uxListRemove>
    27d0:	8f 8d       	ldd	r24, Y+31	; 0x1f
    27d2:	8e 8b       	std	Y+22, r24	; 0x16
    27d4:	2a e0       	ldi	r18, 0x0A	; 10
    27d6:	30 e0       	ldi	r19, 0x00	; 0
    27d8:	28 1b       	sub	r18, r24
    27da:	31 09       	sbc	r19, r1
    27dc:	3d 87       	std	Y+13, r19	; 0x0d
    27de:	2c 87       	std	Y+12, r18	; 0x0c
    27e0:	90 91 99 07 	lds	r25, 0x0799	; 0x800799 <uxTopReadyPriority>
    27e4:	98 17       	cp	r25, r24
    27e6:	10 f4       	brcc	.+4      	; 0x27ec <xTaskPriorityDisinherit+0x4a>
    27e8:	80 93 99 07 	sts	0x0799, r24	; 0x800799 <uxTopReadyPriority>
    27ec:	90 e0       	ldi	r25, 0x00	; 0
    27ee:	9c 01       	movw	r18, r24
    27f0:	22 0f       	add	r18, r18
    27f2:	33 1f       	adc	r19, r19
    27f4:	22 0f       	add	r18, r18
    27f6:	33 1f       	adc	r19, r19
    27f8:	22 0f       	add	r18, r18
    27fa:	33 1f       	adc	r19, r19
    27fc:	82 0f       	add	r24, r18
    27fe:	93 1f       	adc	r25, r19
    2800:	b8 01       	movw	r22, r16
    2802:	81 53       	subi	r24, 0x31	; 49
    2804:	98 4f       	sbci	r25, 0xF8	; 248
    2806:	0e 94 20 06 	call	0xc40	; 0xc40 <vListInsertEnd>
    280a:	81 e0       	ldi	r24, 0x01	; 1
    280c:	05 c0       	rjmp	.+10     	; 0x2818 <xTaskPriorityDisinherit+0x76>
    280e:	80 e0       	ldi	r24, 0x00	; 0
    2810:	03 c0       	rjmp	.+6      	; 0x2818 <xTaskPriorityDisinherit+0x76>
    2812:	80 e0       	ldi	r24, 0x00	; 0
    2814:	01 c0       	rjmp	.+2      	; 0x2818 <xTaskPriorityDisinherit+0x76>
    2816:	80 e0       	ldi	r24, 0x00	; 0
    2818:	df 91       	pop	r29
    281a:	cf 91       	pop	r28
    281c:	1f 91       	pop	r17
    281e:	0f 91       	pop	r16
    2820:	08 95       	ret

00002822 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    2822:	80 91 29 08 	lds	r24, 0x0829	; 0x800829 <pxCurrentTCB>
    2826:	90 91 2a 08 	lds	r25, 0x082A	; 0x80082a <pxCurrentTCB+0x1>
    282a:	89 2b       	or	r24, r25
    282c:	39 f0       	breq	.+14     	; 0x283c <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    282e:	e0 91 29 08 	lds	r30, 0x0829	; 0x800829 <pxCurrentTCB>
    2832:	f0 91 2a 08 	lds	r31, 0x082A	; 0x80082a <pxCurrentTCB+0x1>
    2836:	80 a1       	ldd	r24, Z+32	; 0x20
    2838:	8f 5f       	subi	r24, 0xFF	; 255
    283a:	80 a3       	std	Z+32, r24	; 0x20
		}

		return pxCurrentTCB;
    283c:	80 91 29 08 	lds	r24, 0x0829	; 0x800829 <pxCurrentTCB>
    2840:	90 91 2a 08 	lds	r25, 0x082A	; 0x80082a <pxCurrentTCB+0x1>
	}
    2844:	08 95       	ret

00002846 <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
    2846:	fc 01       	movw	r30, r24
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    2848:	73 83       	std	Z+3, r23	; 0x03
    284a:	62 83       	std	Z+2, r22	; 0x02
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    284c:	91 87       	std	Z+9, r25	; 0x09
    284e:	80 87       	std	Z+8, r24	; 0x08

	if( xNextExpiryTime <= xTimeNow )
    2850:	46 17       	cp	r20, r22
    2852:	57 07       	cpc	r21, r23
    2854:	90 f0       	brcs	.+36     	; 0x287a <prvInsertTimerInActiveList+0x34>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2856:	42 1b       	sub	r20, r18
    2858:	53 0b       	sbc	r21, r19
    285a:	84 85       	ldd	r24, Z+12	; 0x0c
    285c:	95 85       	ldd	r25, Z+13	; 0x0d
    285e:	48 17       	cp	r20, r24
    2860:	59 07       	cpc	r21, r25
    2862:	e0 f4       	brcc	.+56     	; 0x289c <prvInsertTimerInActiveList+0x56>
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    2864:	bf 01       	movw	r22, r30
    2866:	6e 5f       	subi	r22, 0xFE	; 254
    2868:	7f 4f       	sbci	r23, 0xFF	; 255
    286a:	80 91 31 08 	lds	r24, 0x0831	; 0x800831 <pxOverflowTimerList>
    286e:	90 91 32 08 	lds	r25, 0x0832	; 0x800832 <pxOverflowTimerList+0x1>
    2872:	0e 94 41 06 	call	0xc82	; 0xc82 <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    2876:	80 e0       	ldi	r24, 0x00	; 0
    2878:	08 95       	ret
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    287a:	42 17       	cp	r20, r18
    287c:	53 07       	cpc	r21, r19
    287e:	18 f4       	brcc	.+6      	; 0x2886 <prvInsertTimerInActiveList+0x40>
    2880:	62 17       	cp	r22, r18
    2882:	73 07       	cpc	r23, r19
    2884:	68 f4       	brcc	.+26     	; 0x28a0 <prvInsertTimerInActiveList+0x5a>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2886:	bf 01       	movw	r22, r30
    2888:	6e 5f       	subi	r22, 0xFE	; 254
    288a:	7f 4f       	sbci	r23, 0xFF	; 255
    288c:	80 91 33 08 	lds	r24, 0x0833	; 0x800833 <pxCurrentTimerList>
    2890:	90 91 34 08 	lds	r25, 0x0834	; 0x800834 <pxCurrentTimerList+0x1>
    2894:	0e 94 41 06 	call	0xc82	; 0xc82 <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    2898:	80 e0       	ldi	r24, 0x00	; 0
    289a:	08 95       	ret
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    289c:	81 e0       	ldi	r24, 0x01	; 1
    289e:	08 95       	ret
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
    28a0:	81 e0       	ldi	r24, 0x01	; 1
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
    28a2:	08 95       	ret

000028a4 <prvCheckForValidListAndQueue>:
static void prvCheckForValidListAndQueue( void )
{
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    28a4:	0f b6       	in	r0, 0x3f	; 63
    28a6:	f8 94       	cli
    28a8:	0f 92       	push	r0
	{
		if( xTimerQueue == NULL )
    28aa:	80 91 2f 08 	lds	r24, 0x082F	; 0x80082f <xTimerQueue>
    28ae:	90 91 30 08 	lds	r25, 0x0830	; 0x800830 <xTimerQueue+0x1>
    28b2:	89 2b       	or	r24, r25
    28b4:	e9 f4       	brne	.+58     	; 0x28f0 <prvCheckForValidListAndQueue+0x4c>
		{
			vListInitialise( &xActiveTimerList1 );
    28b6:	8e e3       	ldi	r24, 0x3E	; 62
    28b8:	98 e0       	ldi	r25, 0x08	; 8
    28ba:	0e 94 0e 06 	call	0xc1c	; 0xc1c <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
    28be:	85 e3       	ldi	r24, 0x35	; 53
    28c0:	98 e0       	ldi	r25, 0x08	; 8
    28c2:	0e 94 0e 06 	call	0xc1c	; 0xc1c <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
    28c6:	8e e3       	ldi	r24, 0x3E	; 62
    28c8:	98 e0       	ldi	r25, 0x08	; 8
    28ca:	90 93 34 08 	sts	0x0834, r25	; 0x800834 <pxCurrentTimerList+0x1>
    28ce:	80 93 33 08 	sts	0x0833, r24	; 0x800833 <pxCurrentTimerList>
			pxOverflowTimerList = &xActiveTimerList2;
    28d2:	85 e3       	ldi	r24, 0x35	; 53
    28d4:	98 e0       	ldi	r25, 0x08	; 8
    28d6:	90 93 32 08 	sts	0x0832, r25	; 0x800832 <pxOverflowTimerList+0x1>
    28da:	80 93 31 08 	sts	0x0831, r24	; 0x800831 <pxOverflowTimerList>

				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
			}
			#else
			{
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    28de:	40 e0       	ldi	r20, 0x00	; 0
    28e0:	65 e0       	ldi	r22, 0x05	; 5
    28e2:	85 e0       	ldi	r24, 0x05	; 5
    28e4:	0e 94 93 0c 	call	0x1926	; 0x1926 <xQueueGenericCreate>
    28e8:	90 93 30 08 	sts	0x0830, r25	; 0x800830 <xTimerQueue+0x1>
    28ec:	80 93 2f 08 	sts	0x082F, r24	; 0x80082f <xTimerQueue>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    28f0:	0f 90       	pop	r0
    28f2:	0f be       	out	0x3f, r0	; 63
    28f4:	08 95       	ret

000028f6 <xTimerCreateTimerTask>:
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
    28f6:	ef 92       	push	r14
    28f8:	ff 92       	push	r15
    28fa:	0f 93       	push	r16

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
    28fc:	0e 94 52 14 	call	0x28a4	; 0x28a4 <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
    2900:	80 91 2f 08 	lds	r24, 0x082F	; 0x80082f <xTimerQueue>
    2904:	90 91 30 08 	lds	r25, 0x0830	; 0x800830 <xTimerQueue+0x1>
    2908:	89 2b       	or	r24, r25
    290a:	91 f0       	breq	.+36     	; 0x2930 <xTimerCreateTimerTask+0x3a>
				xReturn = pdPASS;
			}
		}
		#else
		{
			xReturn = xTaskCreate(	prvTimerTask,
    290c:	0f 2e       	mov	r0, r31
    290e:	fd e2       	ldi	r31, 0x2D	; 45
    2910:	ef 2e       	mov	r14, r31
    2912:	f8 e0       	ldi	r31, 0x08	; 8
    2914:	ff 2e       	mov	r15, r31
    2916:	f0 2d       	mov	r31, r0
    2918:	0f e0       	ldi	r16, 0x0F	; 15
    291a:	20 e0       	ldi	r18, 0x00	; 0
    291c:	30 e0       	ldi	r19, 0x00	; 0
    291e:	48 e2       	ldi	r20, 0x28	; 40
    2920:	50 e0       	ldi	r21, 0x00	; 0
    2922:	65 e9       	ldi	r22, 0x95	; 149
    2924:	71 e0       	ldi	r23, 0x01	; 1
    2926:	87 e8       	ldi	r24, 0x87	; 135
    2928:	95 e1       	ldi	r25, 0x15	; 21
    292a:	0e 94 3c 0f 	call	0x1e78	; 0x1e78 <xTaskCreate>
    292e:	01 c0       	rjmp	.+2      	; 0x2932 <xTimerCreateTimerTask+0x3c>
									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
BaseType_t xReturn = pdFAIL;
    2930:	80 e0       	ldi	r24, 0x00	; 0
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
	return xReturn;
}
    2932:	0f 91       	pop	r16
    2934:	ff 90       	pop	r15
    2936:	ef 90       	pop	r14
    2938:	08 95       	ret

0000293a <xTimerCreate>:
	TimerHandle_t xTimerCreate(	const char * const pcTimerName,
								const TickType_t xTimerPeriodInTicks,
								const UBaseType_t uxAutoReload,
								void * const pvTimerID,
								TimerCallbackFunction_t pxCallbackFunction ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
    293a:	9f 92       	push	r9
    293c:	af 92       	push	r10
    293e:	bf 92       	push	r11
    2940:	cf 92       	push	r12
    2942:	df 92       	push	r13
    2944:	ef 92       	push	r14
    2946:	ff 92       	push	r15
    2948:	0f 93       	push	r16
    294a:	1f 93       	push	r17
    294c:	cf 93       	push	r28
    294e:	df 93       	push	r29
    2950:	5c 01       	movw	r10, r24
    2952:	6b 01       	movw	r12, r22
    2954:	94 2e       	mov	r9, r20
    2956:	79 01       	movw	r14, r18
	Timer_t *pxNewTimer;

		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
    2958:	84 e1       	ldi	r24, 0x14	; 20
    295a:	90 e0       	ldi	r25, 0x00	; 0
    295c:	0e 94 f6 07 	call	0xfec	; 0xfec <pvPortMalloc>
    2960:	ec 01       	movw	r28, r24
									Timer_t *pxNewTimer ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );

	if( pxNewTimer != NULL )
    2962:	89 2b       	or	r24, r25
    2964:	79 f0       	breq	.+30     	; 0x2984 <xTimerCreate+0x4a>
	{
		/* Ensure the infrastructure used by the timer service task has been
		created/initialised. */
		prvCheckForValidListAndQueue();
    2966:	0e 94 52 14 	call	0x28a4	; 0x28a4 <prvCheckForValidListAndQueue>

		/* Initialise the timer structure members using the function
		parameters. */
		pxNewTimer->pcTimerName = pcTimerName;
    296a:	b9 82       	std	Y+1, r11	; 0x01
    296c:	a8 82       	st	Y, r10
		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    296e:	dd 86       	std	Y+13, r13	; 0x0d
    2970:	cc 86       	std	Y+12, r12	; 0x0c
		pxNewTimer->uxAutoReload = uxAutoReload;
    2972:	9e 86       	std	Y+14, r9	; 0x0e
		pxNewTimer->pvTimerID = pvTimerID;
    2974:	f8 8a       	std	Y+16, r15	; 0x10
    2976:	ef 86       	std	Y+15, r14	; 0x0f
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    2978:	1a 8b       	std	Y+18, r17	; 0x12
    297a:	09 8b       	std	Y+17, r16	; 0x11
		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    297c:	ce 01       	movw	r24, r28
    297e:	02 96       	adiw	r24, 0x02	; 2
    2980:	0e 94 1c 06 	call	0xc38	; 0xc38 <vListInitialiseItem>
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */
		}

		return pxNewTimer;
	}
    2984:	ce 01       	movw	r24, r28
    2986:	df 91       	pop	r29
    2988:	cf 91       	pop	r28
    298a:	1f 91       	pop	r17
    298c:	0f 91       	pop	r16
    298e:	ff 90       	pop	r15
    2990:	ef 90       	pop	r14
    2992:	df 90       	pop	r13
    2994:	cf 90       	pop	r12
    2996:	bf 90       	pop	r11
    2998:	af 90       	pop	r10
    299a:	9f 90       	pop	r9
    299c:	08 95       	ret

0000299e <xTimerGenericCommand>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    299e:	0f 93       	push	r16
    29a0:	1f 93       	push	r17
    29a2:	cf 93       	push	r28
    29a4:	df 93       	push	r29
    29a6:	00 d0       	rcall	.+0      	; 0x29a8 <xTimerGenericCommand+0xa>
    29a8:	00 d0       	rcall	.+0      	; 0x29aa <xTimerGenericCommand+0xc>
    29aa:	1f 92       	push	r1
    29ac:	cd b7       	in	r28, 0x3d	; 61
    29ae:	de b7       	in	r29, 0x3e	; 62

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    29b0:	e0 91 2f 08 	lds	r30, 0x082F	; 0x80082f <xTimerQueue>
    29b4:	f0 91 30 08 	lds	r31, 0x0830	; 0x800830 <xTimerQueue+0x1>
    29b8:	30 97       	sbiw	r30, 0x00	; 0
    29ba:	71 f1       	breq	.+92     	; 0x2a18 <xTimerGenericCommand+0x7a>
    29bc:	d9 01       	movw	r26, r18
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    29be:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    29c0:	5b 83       	std	Y+3, r21	; 0x03
    29c2:	4a 83       	std	Y+2, r20	; 0x02
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    29c4:	9d 83       	std	Y+5, r25	; 0x05
    29c6:	8c 83       	std	Y+4, r24	; 0x04

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    29c8:	66 30       	cpi	r22, 0x06	; 6
    29ca:	ec f4       	brge	.+58     	; 0x2a06 <xTimerGenericCommand+0x68>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    29cc:	0e 94 61 13 	call	0x26c2	; 0x26c2 <xTaskGetSchedulerState>
    29d0:	82 30       	cpi	r24, 0x02	; 2
    29d2:	61 f4       	brne	.+24     	; 0x29ec <xTimerGenericCommand+0x4e>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    29d4:	20 e0       	ldi	r18, 0x00	; 0
    29d6:	a8 01       	movw	r20, r16
    29d8:	be 01       	movw	r22, r28
    29da:	6f 5f       	subi	r22, 0xFF	; 255
    29dc:	7f 4f       	sbci	r23, 0xFF	; 255
    29de:	80 91 2f 08 	lds	r24, 0x082F	; 0x80082f <xTimerQueue>
    29e2:	90 91 30 08 	lds	r25, 0x0830	; 0x800830 <xTimerQueue+0x1>
    29e6:	0e 94 c6 0c 	call	0x198c	; 0x198c <xQueueGenericSend>
    29ea:	17 c0       	rjmp	.+46     	; 0x2a1a <xTimerGenericCommand+0x7c>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    29ec:	20 e0       	ldi	r18, 0x00	; 0
    29ee:	40 e0       	ldi	r20, 0x00	; 0
    29f0:	50 e0       	ldi	r21, 0x00	; 0
    29f2:	be 01       	movw	r22, r28
    29f4:	6f 5f       	subi	r22, 0xFF	; 255
    29f6:	7f 4f       	sbci	r23, 0xFF	; 255
    29f8:	80 91 2f 08 	lds	r24, 0x082F	; 0x80082f <xTimerQueue>
    29fc:	90 91 30 08 	lds	r25, 0x0830	; 0x800830 <xTimerQueue+0x1>
    2a00:	0e 94 c6 0c 	call	0x198c	; 0x198c <xQueueGenericSend>
    2a04:	0a c0       	rjmp	.+20     	; 0x2a1a <xTimerGenericCommand+0x7c>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    2a06:	20 e0       	ldi	r18, 0x00	; 0
    2a08:	ad 01       	movw	r20, r26
    2a0a:	be 01       	movw	r22, r28
    2a0c:	6f 5f       	subi	r22, 0xFF	; 255
    2a0e:	7f 4f       	sbci	r23, 0xFF	; 255
    2a10:	cf 01       	movw	r24, r30
    2a12:	0e 94 8f 0d 	call	0x1b1e	; 0x1b1e <xQueueGenericSendFromISR>
    2a16:	01 c0       	rjmp	.+2      	; 0x2a1a <xTimerGenericCommand+0x7c>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    2a18:	80 e0       	ldi	r24, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    2a1a:	0f 90       	pop	r0
    2a1c:	0f 90       	pop	r0
    2a1e:	0f 90       	pop	r0
    2a20:	0f 90       	pop	r0
    2a22:	0f 90       	pop	r0
    2a24:	df 91       	pop	r29
    2a26:	cf 91       	pop	r28
    2a28:	1f 91       	pop	r17
    2a2a:	0f 91       	pop	r16
    2a2c:	08 95       	ret

00002a2e <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    2a2e:	af 92       	push	r10
    2a30:	bf 92       	push	r11
    2a32:	cf 92       	push	r12
    2a34:	df 92       	push	r13
    2a36:	ef 92       	push	r14
    2a38:	ff 92       	push	r15
    2a3a:	0f 93       	push	r16
    2a3c:	1f 93       	push	r17
    2a3e:	cf 93       	push	r28
    2a40:	df 93       	push	r29
    2a42:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    2a44:	0e 94 8c 10 	call	0x2118	; 0x2118 <xTaskGetTickCount>
    2a48:	7c 01       	movw	r14, r24

	if( xTimeNow < xLastTime )
    2a4a:	80 91 2b 08 	lds	r24, 0x082B	; 0x80082b <xLastTime.2362>
    2a4e:	90 91 2c 08 	lds	r25, 0x082C	; 0x80082c <xLastTime.2362+0x1>
    2a52:	e8 16       	cp	r14, r24
    2a54:	f9 06       	cpc	r15, r25
    2a56:	08 f0       	brcs	.+2      	; 0x2a5a <prvSampleTimeNow+0x2c>
    2a58:	48 c0       	rjmp	.+144    	; 0x2aea <prvSampleTimeNow+0xbc>
    2a5a:	30 c0       	rjmp	.+96     	; 0x2abc <prvSampleTimeNow+0x8e>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2a5c:	05 80       	ldd	r0, Z+5	; 0x05
    2a5e:	f6 81       	ldd	r31, Z+6	; 0x06
    2a60:	e0 2d       	mov	r30, r0
    2a62:	a0 80       	ld	r10, Z
    2a64:	b1 80       	ldd	r11, Z+1	; 0x01

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    2a66:	c6 81       	ldd	r28, Z+6	; 0x06
    2a68:	d7 81       	ldd	r29, Z+7	; 0x07
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2a6a:	8e 01       	movw	r16, r28
    2a6c:	0e 5f       	subi	r16, 0xFE	; 254
    2a6e:	1f 4f       	sbci	r17, 0xFF	; 255
    2a70:	c8 01       	movw	r24, r16
    2a72:	0e 94 72 06 	call	0xce4	; 0xce4 <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2a76:	e9 89       	ldd	r30, Y+17	; 0x11
    2a78:	fa 89       	ldd	r31, Y+18	; 0x12
    2a7a:	ce 01       	movw	r24, r28
    2a7c:	09 95       	icall

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2a7e:	8e 85       	ldd	r24, Y+14	; 0x0e
    2a80:	81 30       	cpi	r24, 0x01	; 1
    2a82:	e1 f4       	brne	.+56     	; 0x2abc <prvSampleTimeNow+0x8e>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    2a84:	8c 85       	ldd	r24, Y+12	; 0x0c
    2a86:	9d 85       	ldd	r25, Y+13	; 0x0d
    2a88:	8a 0d       	add	r24, r10
    2a8a:	9b 1d       	adc	r25, r11
			if( xReloadTime > xNextExpireTime )
    2a8c:	a8 16       	cp	r10, r24
    2a8e:	b9 06       	cpc	r11, r25
    2a90:	60 f4       	brcc	.+24     	; 0x2aaa <prvSampleTimeNow+0x7c>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    2a92:	9b 83       	std	Y+3, r25	; 0x03
    2a94:	8a 83       	std	Y+2, r24	; 0x02
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2a96:	d9 87       	std	Y+9, r29	; 0x09
    2a98:	c8 87       	std	Y+8, r28	; 0x08
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2a9a:	b8 01       	movw	r22, r16
    2a9c:	80 91 33 08 	lds	r24, 0x0833	; 0x800833 <pxCurrentTimerList>
    2aa0:	90 91 34 08 	lds	r25, 0x0834	; 0x800834 <pxCurrentTimerList+0x1>
    2aa4:	0e 94 41 06 	call	0xc82	; 0xc82 <vListInsert>
    2aa8:	09 c0       	rjmp	.+18     	; 0x2abc <prvSampleTimeNow+0x8e>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2aaa:	00 e0       	ldi	r16, 0x00	; 0
    2aac:	10 e0       	ldi	r17, 0x00	; 0
    2aae:	20 e0       	ldi	r18, 0x00	; 0
    2ab0:	30 e0       	ldi	r19, 0x00	; 0
    2ab2:	a5 01       	movw	r20, r10
    2ab4:	60 e0       	ldi	r22, 0x00	; 0
    2ab6:	ce 01       	movw	r24, r28
    2ab8:	0e 94 cf 14 	call	0x299e	; 0x299e <xTimerGenericCommand>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    2abc:	e0 91 33 08 	lds	r30, 0x0833	; 0x800833 <pxCurrentTimerList>
    2ac0:	f0 91 34 08 	lds	r31, 0x0834	; 0x800834 <pxCurrentTimerList+0x1>
    2ac4:	80 81       	ld	r24, Z
    2ac6:	81 11       	cpse	r24, r1
    2ac8:	c9 cf       	rjmp	.-110    	; 0x2a5c <prvSampleTimeNow+0x2e>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    2aca:	80 91 31 08 	lds	r24, 0x0831	; 0x800831 <pxOverflowTimerList>
    2ace:	90 91 32 08 	lds	r25, 0x0832	; 0x800832 <pxOverflowTimerList+0x1>
    2ad2:	90 93 34 08 	sts	0x0834, r25	; 0x800834 <pxCurrentTimerList+0x1>
    2ad6:	80 93 33 08 	sts	0x0833, r24	; 0x800833 <pxCurrentTimerList>
	pxOverflowTimerList = pxTemp;
    2ada:	f0 93 32 08 	sts	0x0832, r31	; 0x800832 <pxOverflowTimerList+0x1>
    2ade:	e0 93 31 08 	sts	0x0831, r30	; 0x800831 <pxOverflowTimerList>
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    2ae2:	81 e0       	ldi	r24, 0x01	; 1
    2ae4:	f6 01       	movw	r30, r12
    2ae6:	80 83       	st	Z, r24
    2ae8:	02 c0       	rjmp	.+4      	; 0x2aee <prvSampleTimeNow+0xc0>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    2aea:	f6 01       	movw	r30, r12
    2aec:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
    2aee:	f0 92 2c 08 	sts	0x082C, r15	; 0x80082c <xLastTime.2362+0x1>
    2af2:	e0 92 2b 08 	sts	0x082B, r14	; 0x80082b <xLastTime.2362>

	return xTimeNow;
}
    2af6:	c7 01       	movw	r24, r14
    2af8:	df 91       	pop	r29
    2afa:	cf 91       	pop	r28
    2afc:	1f 91       	pop	r17
    2afe:	0f 91       	pop	r16
    2b00:	ff 90       	pop	r15
    2b02:	ef 90       	pop	r14
    2b04:	df 90       	pop	r13
    2b06:	cf 90       	pop	r12
    2b08:	bf 90       	pop	r11
    2b0a:	af 90       	pop	r10
    2b0c:	08 95       	ret

00002b0e <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    2b0e:	cf 93       	push	r28
    2b10:	df 93       	push	r29
    2b12:	00 d0       	rcall	.+0      	; 0x2b14 <prvTimerTask+0x6>
    2b14:	00 d0       	rcall	.+0      	; 0x2b16 <prvTimerTask+0x8>
    2b16:	00 d0       	rcall	.+0      	; 0x2b18 <prvTimerTask+0xa>
    2b18:	cd b7       	in	r28, 0x3d	; 61
    2b1a:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2b1c:	ce 01       	movw	r24, r28
    2b1e:	01 96       	adiw	r24, 0x01	; 1
    2b20:	4c 01       	movw	r8, r24
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2b22:	44 24       	eor	r4, r4
    2b24:	43 94       	inc	r4
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    2b26:	d1 2c       	mov	r13, r1
    2b28:	e1 2c       	mov	r14, r1
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2b2a:	f1 2c       	mov	r15, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    2b2c:	58 2e       	mov	r5, r24
    2b2e:	c9 2c       	mov	r12, r9
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    2b30:	e0 91 33 08 	lds	r30, 0x0833	; 0x800833 <pxCurrentTimerList>
    2b34:	f0 91 34 08 	lds	r31, 0x0834	; 0x800834 <pxCurrentTimerList+0x1>
	if( *pxListWasEmpty == pdFALSE )
    2b38:	80 81       	ld	r24, Z
    2b3a:	88 23       	and	r24, r24
    2b3c:	09 f4       	brne	.+2      	; 0x2b40 <prvTimerTask+0x32>
    2b3e:	c3 c0       	rjmp	.+390    	; 0x2cc6 <prvTimerTask+0x1b8>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2b40:	05 80       	ldd	r0, Z+5	; 0x05
    2b42:	f6 81       	ldd	r31, Z+6	; 0x06
    2b44:	e0 2d       	mov	r30, r0
    2b46:	a0 80       	ld	r10, Z
    2b48:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    2b4a:	0e 94 86 10 	call	0x210c	; 0x210c <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2b4e:	c4 01       	movw	r24, r8
    2b50:	0e 94 17 15 	call	0x2a2e	; 0x2a2e <prvSampleTimeNow>
    2b54:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    2b56:	89 81       	ldd	r24, Y+1	; 0x01
    2b58:	81 11       	cpse	r24, r1
    2b5a:	47 c0       	rjmp	.+142    	; 0x2bea <prvTimerTask+0xdc>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2b5c:	0a 15       	cp	r16, r10
    2b5e:	1b 05       	cpc	r17, r11
    2b60:	98 f1       	brcs	.+102    	; 0x2bc8 <prvTimerTask+0xba>
			{
				( void ) xTaskResumeAll();
    2b62:	0e 94 51 11 	call	0x22a2	; 0x22a2 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    2b66:	e0 91 33 08 	lds	r30, 0x0833	; 0x800833 <pxCurrentTimerList>
    2b6a:	f0 91 34 08 	lds	r31, 0x0834	; 0x800834 <pxCurrentTimerList+0x1>
    2b6e:	05 80       	ldd	r0, Z+5	; 0x05
    2b70:	f6 81       	ldd	r31, Z+6	; 0x06
    2b72:	e0 2d       	mov	r30, r0
    2b74:	66 80       	ldd	r6, Z+6	; 0x06
    2b76:	77 80       	ldd	r7, Z+7	; 0x07

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2b78:	c3 01       	movw	r24, r6
    2b7a:	02 96       	adiw	r24, 0x02	; 2
    2b7c:	0e 94 72 06 	call	0xce4	; 0xce4 <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2b80:	d3 01       	movw	r26, r6
    2b82:	1e 96       	adiw	r26, 0x0e	; 14
    2b84:	8c 91       	ld	r24, X
    2b86:	1e 97       	sbiw	r26, 0x0e	; 14
    2b88:	81 30       	cpi	r24, 0x01	; 1
    2b8a:	b1 f4       	brne	.+44     	; 0x2bb8 <prvTimerTask+0xaa>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    2b8c:	1c 96       	adiw	r26, 0x0c	; 12
    2b8e:	6d 91       	ld	r22, X+
    2b90:	7c 91       	ld	r23, X
    2b92:	1d 97       	sbiw	r26, 0x0d	; 13
    2b94:	6a 0d       	add	r22, r10
    2b96:	7b 1d       	adc	r23, r11
    2b98:	95 01       	movw	r18, r10
    2b9a:	a8 01       	movw	r20, r16
    2b9c:	c3 01       	movw	r24, r6
    2b9e:	0e 94 23 14 	call	0x2846	; 0x2846 <prvInsertTimerInActiveList>
    2ba2:	88 23       	and	r24, r24
    2ba4:	49 f0       	breq	.+18     	; 0x2bb8 <prvTimerTask+0xaa>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2ba6:	0d 2d       	mov	r16, r13
    2ba8:	1e 2d       	mov	r17, r14
    2baa:	2d 2d       	mov	r18, r13
    2bac:	3e 2d       	mov	r19, r14
    2bae:	a5 01       	movw	r20, r10
    2bb0:	6f 2d       	mov	r22, r15
    2bb2:	c3 01       	movw	r24, r6
    2bb4:	0e 94 cf 14 	call	0x299e	; 0x299e <xTimerGenericCommand>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2bb8:	d3 01       	movw	r26, r6
    2bba:	51 96       	adiw	r26, 0x11	; 17
    2bbc:	ed 91       	ld	r30, X+
    2bbe:	fc 91       	ld	r31, X
    2bc0:	52 97       	sbiw	r26, 0x12	; 18
    2bc2:	c3 01       	movw	r24, r6
    2bc4:	09 95       	icall
    2bc6:	71 c0       	rjmp	.+226    	; 0x2caa <prvTimerTask+0x19c>
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2bc8:	4f 2d       	mov	r20, r15
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    2bca:	b5 01       	movw	r22, r10
    2bcc:	60 1b       	sub	r22, r16
    2bce:	71 0b       	sbc	r23, r17
    2bd0:	80 91 2f 08 	lds	r24, 0x082F	; 0x80082f <xTimerQueue>
    2bd4:	90 91 30 08 	lds	r25, 0x0830	; 0x800830 <xTimerQueue+0x1>
    2bd8:	0e 94 a8 0e 	call	0x1d50	; 0x1d50 <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
    2bdc:	0e 94 51 11 	call	0x22a2	; 0x22a2 <xTaskResumeAll>
    2be0:	81 11       	cpse	r24, r1
    2be2:	63 c0       	rjmp	.+198    	; 0x2caa <prvTimerTask+0x19c>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    2be4:	0e 94 3e 07 	call	0xe7c	; 0xe7c <vPortYield>
    2be8:	60 c0       	rjmp	.+192    	; 0x2caa <prvTimerTask+0x19c>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    2bea:	0e 94 51 11 	call	0x22a2	; 0x22a2 <xTaskResumeAll>
    2bee:	5d c0       	rjmp	.+186    	; 0x2caa <prvTimerTask+0x19c>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    2bf0:	89 81       	ldd	r24, Y+1	; 0x01
    2bf2:	88 23       	and	r24, r24
    2bf4:	0c f4       	brge	.+2      	; 0x2bf8 <prvTimerTask+0xea>
    2bf6:	59 c0       	rjmp	.+178    	; 0x2caa <prvTimerTask+0x19c>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    2bf8:	ac 80       	ldd	r10, Y+4	; 0x04
    2bfa:	bd 80       	ldd	r11, Y+5	; 0x05

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    2bfc:	f5 01       	movw	r30, r10
    2bfe:	82 85       	ldd	r24, Z+10	; 0x0a
    2c00:	93 85       	ldd	r25, Z+11	; 0x0b
    2c02:	89 2b       	or	r24, r25
    2c04:	21 f0       	breq	.+8      	; 0x2c0e <prvTimerTask+0x100>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2c06:	c5 01       	movw	r24, r10
    2c08:	02 96       	adiw	r24, 0x02	; 2
    2c0a:	0e 94 72 06 	call	0xce4	; 0xce4 <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2c0e:	ce 01       	movw	r24, r28
    2c10:	06 96       	adiw	r24, 0x06	; 6
    2c12:	0e 94 17 15 	call	0x2a2e	; 0x2a2e <prvSampleTimeNow>

			switch( xMessage.xMessageID )
    2c16:	e9 81       	ldd	r30, Y+1	; 0x01
    2c18:	0e 2f       	mov	r16, r30
    2c1a:	ee 0f       	add	r30, r30
    2c1c:	11 0b       	sbc	r17, r17
    2c1e:	22 0b       	sbc	r18, r18
    2c20:	33 0b       	sbc	r19, r19
    2c22:	0a 30       	cpi	r16, 0x0A	; 10
    2c24:	11 05       	cpc	r17, r1
    2c26:	08 f0       	brcs	.+2      	; 0x2c2a <prvTimerTask+0x11c>
    2c28:	40 c0       	rjmp	.+128    	; 0x2caa <prvTimerTask+0x19c>
    2c2a:	f8 01       	movw	r30, r16
    2c2c:	e2 5c       	subi	r30, 0xC2	; 194
    2c2e:	ff 4f       	sbci	r31, 0xFF	; 255
    2c30:	0c 94 99 16 	jmp	0x2d32	; 0x2d32 <__tablejump2__>
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    2c34:	2a 81       	ldd	r18, Y+2	; 0x02
    2c36:	3b 81       	ldd	r19, Y+3	; 0x03
    2c38:	d5 01       	movw	r26, r10
    2c3a:	1c 96       	adiw	r26, 0x0c	; 12
    2c3c:	6d 91       	ld	r22, X+
    2c3e:	7c 91       	ld	r23, X
    2c40:	1d 97       	sbiw	r26, 0x0d	; 13
    2c42:	62 0f       	add	r22, r18
    2c44:	73 1f       	adc	r23, r19
    2c46:	ac 01       	movw	r20, r24
    2c48:	c5 01       	movw	r24, r10
    2c4a:	0e 94 23 14 	call	0x2846	; 0x2846 <prvInsertTimerInActiveList>
    2c4e:	88 23       	and	r24, r24
    2c50:	61 f1       	breq	.+88     	; 0x2caa <prvTimerTask+0x19c>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2c52:	d5 01       	movw	r26, r10
    2c54:	51 96       	adiw	r26, 0x11	; 17
    2c56:	ed 91       	ld	r30, X+
    2c58:	fc 91       	ld	r31, X
    2c5a:	52 97       	sbiw	r26, 0x12	; 18
    2c5c:	c5 01       	movw	r24, r10
    2c5e:	09 95       	icall
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2c60:	f5 01       	movw	r30, r10
    2c62:	86 85       	ldd	r24, Z+14	; 0x0e
    2c64:	81 30       	cpi	r24, 0x01	; 1
    2c66:	09 f5       	brne	.+66     	; 0x2caa <prvTimerTask+0x19c>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    2c68:	4a 81       	ldd	r20, Y+2	; 0x02
    2c6a:	5b 81       	ldd	r21, Y+3	; 0x03
    2c6c:	84 85       	ldd	r24, Z+12	; 0x0c
    2c6e:	95 85       	ldd	r25, Z+13	; 0x0d
    2c70:	48 0f       	add	r20, r24
    2c72:	59 1f       	adc	r21, r25
    2c74:	0d 2d       	mov	r16, r13
    2c76:	1e 2d       	mov	r17, r14
    2c78:	2d 2d       	mov	r18, r13
    2c7a:	3e 2d       	mov	r19, r14
    2c7c:	6f 2d       	mov	r22, r15
    2c7e:	c5 01       	movw	r24, r10
    2c80:	0e 94 cf 14 	call	0x299e	; 0x299e <xTimerGenericCommand>
    2c84:	12 c0       	rjmp	.+36     	; 0x2caa <prvTimerTask+0x19c>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    2c86:	6a 81       	ldd	r22, Y+2	; 0x02
    2c88:	7b 81       	ldd	r23, Y+3	; 0x03
    2c8a:	d5 01       	movw	r26, r10
    2c8c:	1d 96       	adiw	r26, 0x0d	; 13
    2c8e:	7c 93       	st	X, r23
    2c90:	6e 93       	st	-X, r22
    2c92:	1c 97       	sbiw	r26, 0x0c	; 12
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    2c94:	68 0f       	add	r22, r24
    2c96:	79 1f       	adc	r23, r25
    2c98:	9c 01       	movw	r18, r24
    2c9a:	ac 01       	movw	r20, r24
    2c9c:	c5 01       	movw	r24, r10
    2c9e:	0e 94 23 14 	call	0x2846	; 0x2846 <prvInsertTimerInActiveList>
    2ca2:	03 c0       	rjmp	.+6      	; 0x2caa <prvTimerTask+0x19c>
					allocated. */
					#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
					{
						/* The timer can only have been allocated dynamically -
						free it again. */
						vPortFree( pxTimer );
    2ca4:	c5 01       	movw	r24, r10
    2ca6:	0e 94 2b 08 	call	0x1056	; 0x1056 <vPortFree>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    2caa:	2f 2d       	mov	r18, r15
    2cac:	4d 2d       	mov	r20, r13
    2cae:	5e 2d       	mov	r21, r14
    2cb0:	65 2d       	mov	r22, r5
    2cb2:	7c 2d       	mov	r23, r12
    2cb4:	80 91 2f 08 	lds	r24, 0x082F	; 0x80082f <xTimerQueue>
    2cb8:	90 91 30 08 	lds	r25, 0x0830	; 0x800830 <xTimerQueue+0x1>
    2cbc:	0e 94 dc 0d 	call	0x1bb8	; 0x1bb8 <xQueueGenericReceive>
    2cc0:	81 11       	cpse	r24, r1
    2cc2:	96 cf       	rjmp	.-212    	; 0x2bf0 <prvTimerTask+0xe2>
    2cc4:	35 cf       	rjmp	.-406    	; 0x2b30 <prvTimerTask+0x22>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    2cc6:	0e 94 86 10 	call	0x210c	; 0x210c <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2cca:	c4 01       	movw	r24, r8
    2ccc:	0e 94 17 15 	call	0x2a2e	; 0x2a2e <prvSampleTimeNow>
    2cd0:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    2cd2:	89 81       	ldd	r24, Y+1	; 0x01
    2cd4:	81 11       	cpse	r24, r1
    2cd6:	89 cf       	rjmp	.-238    	; 0x2bea <prvTimerTask+0xdc>
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2cd8:	e0 91 31 08 	lds	r30, 0x0831	; 0x800831 <pxOverflowTimerList>
    2cdc:	f0 91 32 08 	lds	r31, 0x0832	; 0x800832 <pxOverflowTimerList+0x1>
    2ce0:	44 2d       	mov	r20, r4
    2ce2:	80 81       	ld	r24, Z
    2ce4:	81 11       	cpse	r24, r1
    2ce6:	4f 2d       	mov	r20, r15
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    2ce8:	ad 2c       	mov	r10, r13
    2cea:	be 2c       	mov	r11, r14
    2cec:	6e cf       	rjmp	.-292    	; 0x2bca <prvTimerTask+0xbc>

00002cee <__udivmodsi4>:
    2cee:	a1 e2       	ldi	r26, 0x21	; 33
    2cf0:	1a 2e       	mov	r1, r26
    2cf2:	aa 1b       	sub	r26, r26
    2cf4:	bb 1b       	sub	r27, r27
    2cf6:	fd 01       	movw	r30, r26
    2cf8:	0d c0       	rjmp	.+26     	; 0x2d14 <__udivmodsi4_ep>

00002cfa <__udivmodsi4_loop>:
    2cfa:	aa 1f       	adc	r26, r26
    2cfc:	bb 1f       	adc	r27, r27
    2cfe:	ee 1f       	adc	r30, r30
    2d00:	ff 1f       	adc	r31, r31
    2d02:	a2 17       	cp	r26, r18
    2d04:	b3 07       	cpc	r27, r19
    2d06:	e4 07       	cpc	r30, r20
    2d08:	f5 07       	cpc	r31, r21
    2d0a:	20 f0       	brcs	.+8      	; 0x2d14 <__udivmodsi4_ep>
    2d0c:	a2 1b       	sub	r26, r18
    2d0e:	b3 0b       	sbc	r27, r19
    2d10:	e4 0b       	sbc	r30, r20
    2d12:	f5 0b       	sbc	r31, r21

00002d14 <__udivmodsi4_ep>:
    2d14:	66 1f       	adc	r22, r22
    2d16:	77 1f       	adc	r23, r23
    2d18:	88 1f       	adc	r24, r24
    2d1a:	99 1f       	adc	r25, r25
    2d1c:	1a 94       	dec	r1
    2d1e:	69 f7       	brne	.-38     	; 0x2cfa <__udivmodsi4_loop>
    2d20:	60 95       	com	r22
    2d22:	70 95       	com	r23
    2d24:	80 95       	com	r24
    2d26:	90 95       	com	r25
    2d28:	9b 01       	movw	r18, r22
    2d2a:	ac 01       	movw	r20, r24
    2d2c:	bd 01       	movw	r22, r26
    2d2e:	cf 01       	movw	r24, r30
    2d30:	08 95       	ret

00002d32 <__tablejump2__>:
    2d32:	ee 0f       	add	r30, r30
    2d34:	ff 1f       	adc	r31, r31
    2d36:	05 90       	lpm	r0, Z+
    2d38:	f4 91       	lpm	r31, Z
    2d3a:	e0 2d       	mov	r30, r0
    2d3c:	09 94       	ijmp

00002d3e <malloc>:
    2d3e:	0f 93       	push	r16
    2d40:	1f 93       	push	r17
    2d42:	cf 93       	push	r28
    2d44:	df 93       	push	r29
    2d46:	82 30       	cpi	r24, 0x02	; 2
    2d48:	91 05       	cpc	r25, r1
    2d4a:	10 f4       	brcc	.+4      	; 0x2d50 <malloc+0x12>
    2d4c:	82 e0       	ldi	r24, 0x02	; 2
    2d4e:	90 e0       	ldi	r25, 0x00	; 0
    2d50:	e0 91 62 08 	lds	r30, 0x0862	; 0x800862 <__flp>
    2d54:	f0 91 63 08 	lds	r31, 0x0863	; 0x800863 <__flp+0x1>
    2d58:	20 e0       	ldi	r18, 0x00	; 0
    2d5a:	30 e0       	ldi	r19, 0x00	; 0
    2d5c:	a0 e0       	ldi	r26, 0x00	; 0
    2d5e:	b0 e0       	ldi	r27, 0x00	; 0
    2d60:	30 97       	sbiw	r30, 0x00	; 0
    2d62:	19 f1       	breq	.+70     	; 0x2daa <malloc+0x6c>
    2d64:	40 81       	ld	r20, Z
    2d66:	51 81       	ldd	r21, Z+1	; 0x01
    2d68:	02 81       	ldd	r16, Z+2	; 0x02
    2d6a:	13 81       	ldd	r17, Z+3	; 0x03
    2d6c:	48 17       	cp	r20, r24
    2d6e:	59 07       	cpc	r21, r25
    2d70:	c8 f0       	brcs	.+50     	; 0x2da4 <malloc+0x66>
    2d72:	84 17       	cp	r24, r20
    2d74:	95 07       	cpc	r25, r21
    2d76:	69 f4       	brne	.+26     	; 0x2d92 <malloc+0x54>
    2d78:	10 97       	sbiw	r26, 0x00	; 0
    2d7a:	31 f0       	breq	.+12     	; 0x2d88 <malloc+0x4a>
    2d7c:	12 96       	adiw	r26, 0x02	; 2
    2d7e:	0c 93       	st	X, r16
    2d80:	12 97       	sbiw	r26, 0x02	; 2
    2d82:	13 96       	adiw	r26, 0x03	; 3
    2d84:	1c 93       	st	X, r17
    2d86:	27 c0       	rjmp	.+78     	; 0x2dd6 <malloc+0x98>
    2d88:	00 93 62 08 	sts	0x0862, r16	; 0x800862 <__flp>
    2d8c:	10 93 63 08 	sts	0x0863, r17	; 0x800863 <__flp+0x1>
    2d90:	22 c0       	rjmp	.+68     	; 0x2dd6 <malloc+0x98>
    2d92:	21 15       	cp	r18, r1
    2d94:	31 05       	cpc	r19, r1
    2d96:	19 f0       	breq	.+6      	; 0x2d9e <malloc+0x60>
    2d98:	42 17       	cp	r20, r18
    2d9a:	53 07       	cpc	r21, r19
    2d9c:	18 f4       	brcc	.+6      	; 0x2da4 <malloc+0x66>
    2d9e:	9a 01       	movw	r18, r20
    2da0:	bd 01       	movw	r22, r26
    2da2:	ef 01       	movw	r28, r30
    2da4:	df 01       	movw	r26, r30
    2da6:	f8 01       	movw	r30, r16
    2da8:	db cf       	rjmp	.-74     	; 0x2d60 <malloc+0x22>
    2daa:	21 15       	cp	r18, r1
    2dac:	31 05       	cpc	r19, r1
    2dae:	f9 f0       	breq	.+62     	; 0x2dee <malloc+0xb0>
    2db0:	28 1b       	sub	r18, r24
    2db2:	39 0b       	sbc	r19, r25
    2db4:	24 30       	cpi	r18, 0x04	; 4
    2db6:	31 05       	cpc	r19, r1
    2db8:	80 f4       	brcc	.+32     	; 0x2dda <malloc+0x9c>
    2dba:	8a 81       	ldd	r24, Y+2	; 0x02
    2dbc:	9b 81       	ldd	r25, Y+3	; 0x03
    2dbe:	61 15       	cp	r22, r1
    2dc0:	71 05       	cpc	r23, r1
    2dc2:	21 f0       	breq	.+8      	; 0x2dcc <malloc+0x8e>
    2dc4:	fb 01       	movw	r30, r22
    2dc6:	93 83       	std	Z+3, r25	; 0x03
    2dc8:	82 83       	std	Z+2, r24	; 0x02
    2dca:	04 c0       	rjmp	.+8      	; 0x2dd4 <malloc+0x96>
    2dcc:	90 93 63 08 	sts	0x0863, r25	; 0x800863 <__flp+0x1>
    2dd0:	80 93 62 08 	sts	0x0862, r24	; 0x800862 <__flp>
    2dd4:	fe 01       	movw	r30, r28
    2dd6:	32 96       	adiw	r30, 0x02	; 2
    2dd8:	44 c0       	rjmp	.+136    	; 0x2e62 <malloc+0x124>
    2dda:	fe 01       	movw	r30, r28
    2ddc:	e2 0f       	add	r30, r18
    2dde:	f3 1f       	adc	r31, r19
    2de0:	81 93       	st	Z+, r24
    2de2:	91 93       	st	Z+, r25
    2de4:	22 50       	subi	r18, 0x02	; 2
    2de6:	31 09       	sbc	r19, r1
    2de8:	39 83       	std	Y+1, r19	; 0x01
    2dea:	28 83       	st	Y, r18
    2dec:	3a c0       	rjmp	.+116    	; 0x2e62 <malloc+0x124>
    2dee:	20 91 60 08 	lds	r18, 0x0860	; 0x800860 <__brkval>
    2df2:	30 91 61 08 	lds	r19, 0x0861	; 0x800861 <__brkval+0x1>
    2df6:	23 2b       	or	r18, r19
    2df8:	41 f4       	brne	.+16     	; 0x2e0a <malloc+0xcc>
    2dfa:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__malloc_heap_start>
    2dfe:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__malloc_heap_start+0x1>
    2e02:	30 93 61 08 	sts	0x0861, r19	; 0x800861 <__brkval+0x1>
    2e06:	20 93 60 08 	sts	0x0860, r18	; 0x800860 <__brkval>
    2e0a:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
    2e0e:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
    2e12:	21 15       	cp	r18, r1
    2e14:	31 05       	cpc	r19, r1
    2e16:	41 f4       	brne	.+16     	; 0x2e28 <malloc+0xea>
    2e18:	2d b7       	in	r18, 0x3d	; 61
    2e1a:	3e b7       	in	r19, 0x3e	; 62
    2e1c:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__malloc_margin>
    2e20:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__malloc_margin+0x1>
    2e24:	24 1b       	sub	r18, r20
    2e26:	35 0b       	sbc	r19, r21
    2e28:	e0 91 60 08 	lds	r30, 0x0860	; 0x800860 <__brkval>
    2e2c:	f0 91 61 08 	lds	r31, 0x0861	; 0x800861 <__brkval+0x1>
    2e30:	e2 17       	cp	r30, r18
    2e32:	f3 07       	cpc	r31, r19
    2e34:	a0 f4       	brcc	.+40     	; 0x2e5e <malloc+0x120>
    2e36:	2e 1b       	sub	r18, r30
    2e38:	3f 0b       	sbc	r19, r31
    2e3a:	28 17       	cp	r18, r24
    2e3c:	39 07       	cpc	r19, r25
    2e3e:	78 f0       	brcs	.+30     	; 0x2e5e <malloc+0x120>
    2e40:	ac 01       	movw	r20, r24
    2e42:	4e 5f       	subi	r20, 0xFE	; 254
    2e44:	5f 4f       	sbci	r21, 0xFF	; 255
    2e46:	24 17       	cp	r18, r20
    2e48:	35 07       	cpc	r19, r21
    2e4a:	48 f0       	brcs	.+18     	; 0x2e5e <malloc+0x120>
    2e4c:	4e 0f       	add	r20, r30
    2e4e:	5f 1f       	adc	r21, r31
    2e50:	50 93 61 08 	sts	0x0861, r21	; 0x800861 <__brkval+0x1>
    2e54:	40 93 60 08 	sts	0x0860, r20	; 0x800860 <__brkval>
    2e58:	81 93       	st	Z+, r24
    2e5a:	91 93       	st	Z+, r25
    2e5c:	02 c0       	rjmp	.+4      	; 0x2e62 <malloc+0x124>
    2e5e:	e0 e0       	ldi	r30, 0x00	; 0
    2e60:	f0 e0       	ldi	r31, 0x00	; 0
    2e62:	cf 01       	movw	r24, r30
    2e64:	df 91       	pop	r29
    2e66:	cf 91       	pop	r28
    2e68:	1f 91       	pop	r17
    2e6a:	0f 91       	pop	r16
    2e6c:	08 95       	ret

00002e6e <free>:
    2e6e:	cf 93       	push	r28
    2e70:	df 93       	push	r29
    2e72:	00 97       	sbiw	r24, 0x00	; 0
    2e74:	09 f4       	brne	.+2      	; 0x2e78 <free+0xa>
    2e76:	81 c0       	rjmp	.+258    	; 0x2f7a <free+0x10c>
    2e78:	fc 01       	movw	r30, r24
    2e7a:	32 97       	sbiw	r30, 0x02	; 2
    2e7c:	13 82       	std	Z+3, r1	; 0x03
    2e7e:	12 82       	std	Z+2, r1	; 0x02
    2e80:	a0 91 62 08 	lds	r26, 0x0862	; 0x800862 <__flp>
    2e84:	b0 91 63 08 	lds	r27, 0x0863	; 0x800863 <__flp+0x1>
    2e88:	10 97       	sbiw	r26, 0x00	; 0
    2e8a:	81 f4       	brne	.+32     	; 0x2eac <free+0x3e>
    2e8c:	20 81       	ld	r18, Z
    2e8e:	31 81       	ldd	r19, Z+1	; 0x01
    2e90:	82 0f       	add	r24, r18
    2e92:	93 1f       	adc	r25, r19
    2e94:	20 91 60 08 	lds	r18, 0x0860	; 0x800860 <__brkval>
    2e98:	30 91 61 08 	lds	r19, 0x0861	; 0x800861 <__brkval+0x1>
    2e9c:	28 17       	cp	r18, r24
    2e9e:	39 07       	cpc	r19, r25
    2ea0:	51 f5       	brne	.+84     	; 0x2ef6 <free+0x88>
    2ea2:	f0 93 61 08 	sts	0x0861, r31	; 0x800861 <__brkval+0x1>
    2ea6:	e0 93 60 08 	sts	0x0860, r30	; 0x800860 <__brkval>
    2eaa:	67 c0       	rjmp	.+206    	; 0x2f7a <free+0x10c>
    2eac:	ed 01       	movw	r28, r26
    2eae:	20 e0       	ldi	r18, 0x00	; 0
    2eb0:	30 e0       	ldi	r19, 0x00	; 0
    2eb2:	ce 17       	cp	r28, r30
    2eb4:	df 07       	cpc	r29, r31
    2eb6:	40 f4       	brcc	.+16     	; 0x2ec8 <free+0x5a>
    2eb8:	4a 81       	ldd	r20, Y+2	; 0x02
    2eba:	5b 81       	ldd	r21, Y+3	; 0x03
    2ebc:	9e 01       	movw	r18, r28
    2ebe:	41 15       	cp	r20, r1
    2ec0:	51 05       	cpc	r21, r1
    2ec2:	f1 f0       	breq	.+60     	; 0x2f00 <free+0x92>
    2ec4:	ea 01       	movw	r28, r20
    2ec6:	f5 cf       	rjmp	.-22     	; 0x2eb2 <free+0x44>
    2ec8:	d3 83       	std	Z+3, r29	; 0x03
    2eca:	c2 83       	std	Z+2, r28	; 0x02
    2ecc:	40 81       	ld	r20, Z
    2ece:	51 81       	ldd	r21, Z+1	; 0x01
    2ed0:	84 0f       	add	r24, r20
    2ed2:	95 1f       	adc	r25, r21
    2ed4:	c8 17       	cp	r28, r24
    2ed6:	d9 07       	cpc	r29, r25
    2ed8:	59 f4       	brne	.+22     	; 0x2ef0 <free+0x82>
    2eda:	88 81       	ld	r24, Y
    2edc:	99 81       	ldd	r25, Y+1	; 0x01
    2ede:	84 0f       	add	r24, r20
    2ee0:	95 1f       	adc	r25, r21
    2ee2:	02 96       	adiw	r24, 0x02	; 2
    2ee4:	91 83       	std	Z+1, r25	; 0x01
    2ee6:	80 83       	st	Z, r24
    2ee8:	8a 81       	ldd	r24, Y+2	; 0x02
    2eea:	9b 81       	ldd	r25, Y+3	; 0x03
    2eec:	93 83       	std	Z+3, r25	; 0x03
    2eee:	82 83       	std	Z+2, r24	; 0x02
    2ef0:	21 15       	cp	r18, r1
    2ef2:	31 05       	cpc	r19, r1
    2ef4:	29 f4       	brne	.+10     	; 0x2f00 <free+0x92>
    2ef6:	f0 93 63 08 	sts	0x0863, r31	; 0x800863 <__flp+0x1>
    2efa:	e0 93 62 08 	sts	0x0862, r30	; 0x800862 <__flp>
    2efe:	3d c0       	rjmp	.+122    	; 0x2f7a <free+0x10c>
    2f00:	e9 01       	movw	r28, r18
    2f02:	fb 83       	std	Y+3, r31	; 0x03
    2f04:	ea 83       	std	Y+2, r30	; 0x02
    2f06:	49 91       	ld	r20, Y+
    2f08:	59 91       	ld	r21, Y+
    2f0a:	c4 0f       	add	r28, r20
    2f0c:	d5 1f       	adc	r29, r21
    2f0e:	ec 17       	cp	r30, r28
    2f10:	fd 07       	cpc	r31, r29
    2f12:	61 f4       	brne	.+24     	; 0x2f2c <free+0xbe>
    2f14:	80 81       	ld	r24, Z
    2f16:	91 81       	ldd	r25, Z+1	; 0x01
    2f18:	84 0f       	add	r24, r20
    2f1a:	95 1f       	adc	r25, r21
    2f1c:	02 96       	adiw	r24, 0x02	; 2
    2f1e:	e9 01       	movw	r28, r18
    2f20:	99 83       	std	Y+1, r25	; 0x01
    2f22:	88 83       	st	Y, r24
    2f24:	82 81       	ldd	r24, Z+2	; 0x02
    2f26:	93 81       	ldd	r25, Z+3	; 0x03
    2f28:	9b 83       	std	Y+3, r25	; 0x03
    2f2a:	8a 83       	std	Y+2, r24	; 0x02
    2f2c:	e0 e0       	ldi	r30, 0x00	; 0
    2f2e:	f0 e0       	ldi	r31, 0x00	; 0
    2f30:	12 96       	adiw	r26, 0x02	; 2
    2f32:	8d 91       	ld	r24, X+
    2f34:	9c 91       	ld	r25, X
    2f36:	13 97       	sbiw	r26, 0x03	; 3
    2f38:	00 97       	sbiw	r24, 0x00	; 0
    2f3a:	19 f0       	breq	.+6      	; 0x2f42 <free+0xd4>
    2f3c:	fd 01       	movw	r30, r26
    2f3e:	dc 01       	movw	r26, r24
    2f40:	f7 cf       	rjmp	.-18     	; 0x2f30 <free+0xc2>
    2f42:	8d 91       	ld	r24, X+
    2f44:	9c 91       	ld	r25, X
    2f46:	11 97       	sbiw	r26, 0x01	; 1
    2f48:	9d 01       	movw	r18, r26
    2f4a:	2e 5f       	subi	r18, 0xFE	; 254
    2f4c:	3f 4f       	sbci	r19, 0xFF	; 255
    2f4e:	82 0f       	add	r24, r18
    2f50:	93 1f       	adc	r25, r19
    2f52:	20 91 60 08 	lds	r18, 0x0860	; 0x800860 <__brkval>
    2f56:	30 91 61 08 	lds	r19, 0x0861	; 0x800861 <__brkval+0x1>
    2f5a:	28 17       	cp	r18, r24
    2f5c:	39 07       	cpc	r19, r25
    2f5e:	69 f4       	brne	.+26     	; 0x2f7a <free+0x10c>
    2f60:	30 97       	sbiw	r30, 0x00	; 0
    2f62:	29 f4       	brne	.+10     	; 0x2f6e <free+0x100>
    2f64:	10 92 63 08 	sts	0x0863, r1	; 0x800863 <__flp+0x1>
    2f68:	10 92 62 08 	sts	0x0862, r1	; 0x800862 <__flp>
    2f6c:	02 c0       	rjmp	.+4      	; 0x2f72 <free+0x104>
    2f6e:	13 82       	std	Z+3, r1	; 0x03
    2f70:	12 82       	std	Z+2, r1	; 0x02
    2f72:	b0 93 61 08 	sts	0x0861, r27	; 0x800861 <__brkval+0x1>
    2f76:	a0 93 60 08 	sts	0x0860, r26	; 0x800860 <__brkval>
    2f7a:	df 91       	pop	r29
    2f7c:	cf 91       	pop	r28
    2f7e:	08 95       	ret

00002f80 <memcpy>:
    2f80:	fb 01       	movw	r30, r22
    2f82:	dc 01       	movw	r26, r24
    2f84:	02 c0       	rjmp	.+4      	; 0x2f8a <memcpy+0xa>
    2f86:	01 90       	ld	r0, Z+
    2f88:	0d 92       	st	X+, r0
    2f8a:	41 50       	subi	r20, 0x01	; 1
    2f8c:	50 40       	sbci	r21, 0x00	; 0
    2f8e:	d8 f7       	brcc	.-10     	; 0x2f86 <memcpy+0x6>
    2f90:	08 95       	ret

00002f92 <memset>:
    2f92:	dc 01       	movw	r26, r24
    2f94:	01 c0       	rjmp	.+2      	; 0x2f98 <memset+0x6>
    2f96:	6d 93       	st	X+, r22
    2f98:	41 50       	subi	r20, 0x01	; 1
    2f9a:	50 40       	sbci	r21, 0x00	; 0
    2f9c:	e0 f7       	brcc	.-8      	; 0x2f96 <memset+0x4>
    2f9e:	08 95       	ret

00002fa0 <_exit>:
    2fa0:	f8 94       	cli

00002fa2 <__stop_program>:
    2fa2:	ff cf       	rjmp	.-2      	; 0x2fa2 <__stop_program>
